(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/operators'), require('rxjs'), require('@angular/core/testing')) :
    typeof define === 'function' && define.amd ? define('@ngxs/store', ['exports', '@angular/core', 'rxjs/operators', 'rxjs', '@angular/core/testing'], factory) :
    (factory((global.ngxs = global.ngxs || {}, global.ngxs.store = {}),global.ng.core,global.rxjs.operators,global.rxjs,global.ng.core.testing));
}(this, (function (exports,core,operators,rxjs,testing) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ROOT_STATE_TOKEN = new core.InjectionToken('ROOT_STATE_TOKEN');
    /** @type {?} */
    var FEATURE_STATE_TOKEN = new core.InjectionToken('FEATURE_STATE_TOKEN');
    /** @type {?} */
    var META_KEY = 'NGXS_META';
    /** @type {?} */
    var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
    /** @type {?} */
    var NGXS_PLUGINS = new core.InjectionToken('NGXS_PLUGINS');
    /**
     * The NGXS config settings.
     */
    var /**
     * The NGXS config settings.
     */ NgxsConfig = /** @class */ (function () {
        function NgxsConfig() {
            this.compatibility = {
                strictContentSecurityPolicy: false
            };
        }
        return NgxsConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Ensures metadata is attached to the class and returns it.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function ensureStoreMetadata(target) {
        if (!target.hasOwnProperty(META_KEY)) {
            /** @type {?} */
            var defaultMetadata = {
                name: null,
                actions: {},
                defaults: {},
                path: null,
                selectFromAppState: null,
                children: [],
                instance: null
            };
            Object.defineProperty(target, META_KEY, { value: defaultMetadata });
        }
        return getStoreMetadata(target);
    }
    /**
     * Get the metadata attached to the class if it exists.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function getStoreMetadata(target) {
        return target[META_KEY];
    }
    /**
     * Ensures metadata is attached to the selector and returns it.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function ensureSelectorMetadata(target) {
        if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
            /** @type {?} */
            var defaultMetadata = {
                selectFromAppState: null,
                originalFn: null,
                containerClass: null,
                selectorName: null
            };
            Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
        }
        return getSelectorMetadata(target);
    }
    /**
     * Get the metadata attached to the selector if it exists.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function getSelectorMetadata(target) {
        return target[SELECTOR_META_KEY];
    }
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
     * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
     *
     * @ignore
     * @param {?} paths
     * @return {?}
     */
    function compliantPropGetter(paths) {
        /** @type {?} */
        var copyOfPaths = __spread(paths);
        return function (obj) { return copyOfPaths.reduce(function (acc, part) { return acc && acc[part]; }, obj); };
    }
    /**
     * The generated function is faster than:
     * - pluck (Observable operator)
     * - memoize
     *
     * @ignore
     * @param {?} paths
     * @return {?}
     */
    function fastPropGetter(paths) {
        /** @type {?} */
        var segments = paths;
        /** @type {?} */
        var seg = 'store.' + segments[0];
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var l = segments.length;
        /** @type {?} */
        var expr = seg;
        while (++i < l) {
            expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
        }
        /** @type {?} */
        var fn = new Function('store', 'return ' + expr + ';');
        return ( /** @type {?} */(fn));
    }
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * @ignore
     * @param {?} paths
     * @param {?} config
     * @return {?}
     */
    function propGetter(paths, config) {
        if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
            return compliantPropGetter(paths);
        }
        else {
            return fastPropGetter(paths);
        }
    }
    /**
     * Given an array of states, it will return a object graph. Example:
     *    const states = [
     *      Cart,
     *      CartSaved,
     *      CartSavedItems
     *    ]
     *
     * would return:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * @ignore
     * @param {?} stateClasses
     * @return {?}
     */
    function buildGraph(stateClasses) {
        /** @type {?} */
        var findName = function (stateClass) {
            /** @type {?} */
            var meta = stateClasses.find(function (g) { return g === stateClass; });
            if (!meta) {
                throw new Error("Child state not found: " + stateClass);
            }
            if (!meta[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            return meta[META_KEY].name;
        };
        return stateClasses.reduce(function (result, stateClass) {
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            var _a = stateClass[META_KEY], name = _a.name, children = _a.children;
            result[name] = (children || []).map(findName);
            return result;
        }, {});
    }
    /**
     * Given a states array, returns object graph
     * returning the name and state metadata. Example:
     *
     *  const graph = {
     *    cart: { metadata }
     *  };
     *
     * @ignore
     * @param {?} states
     * @return {?}
     */
    function nameToState(states) {
        return states.reduce(function (result, stateClass) {
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            /** @type {?} */
            var meta = stateClass[META_KEY];
            result[meta.name] = stateClass;
            return result;
        }, {});
    }
    /**
     * Given a object relationship graph will return the full path
     * for the child items. Example:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * would return:
     *
     *  const r = {
     *    cart: 'cart',
     *    saved: 'cart.saved',
     *    items: 'cart.saved.items'
     *  };
     *
     * @ignore
     * @param {?} obj
     * @param {?=} newObj
     * @return {?}
     */
    function findFullParentPath(obj, newObj) {
        if (newObj === void 0) {
            newObj = {};
        }
        /** @type {?} */
        var visit = function (child, keyToFind) {
            for (var key in child) {
                if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                    /** @type {?} */
                    var parent_1 = visit(child, key);
                    return parent_1 !== null ? parent_1 + "." + key : key;
                }
            }
            return null;
        };
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                /** @type {?} */
                var parent_2 = visit(obj, key);
                newObj[key] = parent_2 ? parent_2 + "." + key : key;
            }
        }
        return newObj;
    }
    /**
     * Given a object graph, it will return the items topologically sorted Example:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * would return:
     *
     *  const results = [
     *    'items',
     *    'saved',
     *    'cart'
     *  ];
     *
     * @ignore
     * @param {?} graph
     * @return {?}
     */
    function topologicalSort(graph) {
        /** @type {?} */
        var sorted = [];
        /** @type {?} */
        var visited = {};
        /** @type {?} */
        var visit = function (name, ancestors) {
            if (ancestors === void 0) {
                ancestors = [];
            }
            if (!Array.isArray(ancestors)) {
                ancestors = [];
            }
            ancestors.push(name);
            visited[name] = true;
            graph[name].forEach(function (dep) {
                if (ancestors.indexOf(dep) >= 0) {
                    throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
                }
                if (visited[dep]) {
                    return;
                }
                visit(dep, ancestors.slice(0));
            });
            if (sorted.indexOf(name) < 0) {
                sorted.push(name);
            }
        };
        Object.keys(graph).forEach(function (k) { return visit(k); });
        return sorted.reverse();
    }
    /**
     * Returns if the parameter is a object or not.
     *
     * @ignore
     * @param {?} obj
     * @return {?}
     */
    function isObject(obj) {
        return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns the type from an action instance.
     * @ignore
     * @param {?} action
     * @return {?}
     */
    function getActionTypeFromInstance(action) {
        if (action.constructor && action.constructor.type) {
            return action.constructor.type;
        }
        return action.type;
    }
    /**
     * Matches a action
     * @ignore
     * @param {?} action1
     * @return {?}
     */
    function actionMatcher(action1) {
        /** @type {?} */
        var type1 = getActionTypeFromInstance(action1);
        return function (action2) {
            return type1 === getActionTypeFromInstance(action2);
        };
    }
    /**
     * Set a deeply nested value. Example:
     *
     *   setValue({ foo: { bar: { eat: false } } },
     *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
     *
     * While it traverses it also creates new objects from top down.
     *
     * @ignore
     * @type {?}
     */
    var setValue = function (obj, prop, val) {
        obj = __assign({}, obj);
        /** @type {?} */
        var split = prop.split('.');
        /** @type {?} */
        var lastIndex = split.length - 1;
        split.reduce(function (acc, part, index) {
            if (index === lastIndex) {
                acc[part] = val;
            }
            else {
                acc[part] = Array.isArray(acc[part]) ? __spread(acc[part]) : __assign({}, acc[part]);
            }
            return acc && acc[part];
        }, obj);
        return obj;
    };
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * @ignore
     * @type {?}
     */
    var getValue = function (obj, prop) {
        return prop.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj);
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will grab actions that have just been dispatched as well as actions that have completed
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofAction() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been dispatched
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionDispatched() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, "DISPATCHED" /* Dispatched */);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been successfully completed
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionSuccessful() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, "SUCCESSFUL" /* Successful */);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been canceled
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionCanceled() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, "CANCELED" /* Canceled */);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just thrown an error
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionErrored() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, "ERRORED" /* Errored */);
    }
    /**
     * @param {?} allowedTypes
     * @param {?=} status
     * @return {?}
     */
    function ofActionOperator(allowedTypes, status) {
        /** @type {?} */
        var allowedMap = createAllowedMap(allowedTypes);
        return function (o) {
            return o.pipe(filterStatus(allowedMap, status), mapAction());
        };
    }
    /**
     * @param {?} allowedTypes
     * @param {?=} status
     * @return {?}
     */
    function filterStatus(allowedTypes, status) {
        return operators.filter(function (ctx) {
            /** @type {?} */
            var actionType = getActionTypeFromInstance(ctx.action);
            /** @type {?} */
            var type = allowedTypes[actionType];
            return status ? type && ctx.status === status : type;
        });
    }
    /**
     * @return {?}
     */
    function mapAction() {
        return operators.map(function (ctx) { return ctx.action; });
    }
    /**
     * @param {?} types
     * @return {?}
     */
    function createAllowedMap(types) {
        return types.reduce(function (acc, klass) {
            acc[getActionTypeFromInstance(klass)] = true;
            return acc;
        }, {});
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Operator to run the `subscribe` in a Angular zone.
     * @template T
     * @param {?} zone
     * @return {?}
     */
    function enterZone(zone) {
        return function (source) {
            return new rxjs.Observable(function (sink) {
                return source.subscribe({
                    next: /**
                     * @param {?} x
                     * @return {?}
                     */ function (x) {
                        zone.run(function () { return sink.next(x); });
                    },
                    error: /**
                     * @param {?} e
                     * @return {?}
                     */ function (e) {
                        zone.run(function () { return sink.error(e); });
                    },
                    complete: /**
                     * @return {?}
                     */ function () {
                        zone.run(function () { return sink.complete(); });
                    }
                });
            });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
     * A standard Subject does not have this guarantee.
     * For example, given the following code:
     * ```typescript
     *   const subject = new Subject<string>();
     * subject.subscribe(value => {
     * if (value === 'start') subject.next('end');
     * });
     * subject.subscribe(value => { });
     * subject.next('start');
     * ```
     * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
     * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
     * @template T
     */
    var /**
     * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
     * A standard Subject does not have this guarantee.
     * For example, given the following code:
     * ```typescript
     *   const subject = new Subject<string>();
     * subject.subscribe(value => {
     * if (value === 'start') subject.next('end');
     * });
     * subject.subscribe(value => { });
     * subject.next('start');
     * ```
     * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
     * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
     * @template T
     */ OrderedSubject = /** @class */ (function (_super) {
        __extends(OrderedSubject, _super);
        function OrderedSubject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._itemQueue = [];
            _this._busyPushingNext = false;
            return _this;
        }
        /**
         * @param {?=} value
         * @return {?}
         */
        OrderedSubject.prototype.next = /**
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                if (this._busyPushingNext) {
                    this._itemQueue.unshift(value);
                    return;
                }
                this._busyPushingNext = true;
                _super.prototype.next.call(this, value);
                while (this._itemQueue.length > 0) {
                    /** @type {?} */
                    var nextValue = this._itemQueue.pop();
                    _super.prototype.next.call(this, nextValue);
                }
                this._busyPushingNext = false;
            };
        return OrderedSubject;
    }(rxjs.Subject));
    /**
     * Internal Action stream that is emitted anytime an action is dispatched.
     */
    var InternalActions = /** @class */ (function (_super) {
        __extends(InternalActions, _super);
        function InternalActions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InternalActions.decorators = [
            { type: core.Injectable }
        ];
        return InternalActions;
    }(OrderedSubject));
    /**
     * Action stream that is emitted anytime an action is dispatched.
     *
     * You can listen to this in services to react without stores.
     */
    var Actions = /** @class */ (function (_super) {
        __extends(Actions, _super);
        function Actions(actions$, ngZone) {
            return _super.call(this, function (observer) {
                actions$
                    .pipe(enterZone(ngZone))
                    .subscribe(function (res) { return observer.next(res); }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
            }) || this;
        }
        Actions.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        Actions.ctorParameters = function () {
            return [
                { type: InternalActions },
                { type: core.NgZone }
            ];
        };
        return Actions;
    }(rxjs.Observable));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Composes a array of functions from left to right. Example:
     *
     *      compose([fn, final])(state, action);
     *
     * then the funcs have a signature like:
     *
     *      function fn (state, action, next) {
     *          console.log('here', state, action, next);
     *          return next(state, action);
     *      }
     *
     *      function final (state, action) {
     *          console.log('here', state, action);
     *          return state;
     *      }
     *
     * the last function should not call `next`.
     *
     * @ignore
     * @type {?}
     */
    var compose = function (funcs) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            /** @type {?} */
            var curr = funcs.shift();
            return curr.apply(void 0, __spread(args, [function () {
                    var nextArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        nextArgs[_i] = arguments[_i];
                    }
                    return compose(funcs).apply(void 0, __spread(nextArgs));
                }]));
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * BehaviorSubject of the entire state.
     * @ignore
     */
    var StateStream = /** @class */ (function (_super) {
        __extends(StateStream, _super);
        function StateStream() {
            return _super.call(this, {}) || this;
        }
        StateStream.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateStream.ctorParameters = function () { return []; };
        return StateStream;
    }(rxjs.BehaviorSubject));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Plugin manager class
     * @ignore
     */
    var PluginManager = /** @class */ (function () {
        function PluginManager(_parentManager, _plugins) {
            this._parentManager = _parentManager;
            this._plugins = _plugins;
            this.plugins = [];
            this.register();
        }
        /**
         * @private
         * @return {?}
         */
        PluginManager.prototype.register = /**
         * @private
         * @return {?}
         */
            function () {
                var _a;
                if (!this._plugins) {
                    return;
                }
                this.plugins = this._plugins.map(function (plugin) {
                    if (plugin.handle) {
                        return plugin.handle.bind(plugin);
                    }
                    else {
                        return plugin;
                    }
                });
                if (this._parentManager) {
                    (_a = this._parentManager.plugins).push.apply(_a, __spread(this.plugins));
                }
            };
        PluginManager.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        PluginManager.ctorParameters = function () {
            return [
                { type: PluginManager, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
                { type: Array, decorators: [{ type: core.Inject, args: [NGXS_PLUGINS,] }, { type: core.Optional }] }
            ];
        };
        return PluginManager;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Internal Action result stream that is emitted when an action is completed.
     * This is used as a method of returning the action result to the dispatcher
     * for the observable returned by the dispatch(...) call.
     * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
     */
    var InternalDispatchedActionResults = /** @class */ (function (_super) {
        __extends(InternalDispatchedActionResults, _super);
        function InternalDispatchedActionResults() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InternalDispatchedActionResults.decorators = [
            { type: core.Injectable }
        ];
        return InternalDispatchedActionResults;
    }(rxjs.Subject));
    var InternalDispatcher = /** @class */ (function () {
        function InternalDispatcher(_errorHandler, _actions, _actionResults, _pluginManager, _stateStream, _ngZone) {
            this._errorHandler = _errorHandler;
            this._actions = _actions;
            this._actionResults = _actionResults;
            this._pluginManager = _pluginManager;
            this._stateStream = _stateStream;
            this._ngZone = _ngZone;
        }
        /**
         * Dispatches event(s).
         */
        /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
        InternalDispatcher.prototype.dispatch = /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var result = this._ngZone.runOutsideAngular(function () {
                    if (Array.isArray(event)) {
                        return rxjs.forkJoin(event.map(function (a) { return _this.dispatchSingle(a); }));
                    }
                    else {
                        return _this.dispatchSingle(event);
                    }
                });
                result.subscribe({
                    error: function (error) { return _this._ngZone.run(function () { return _this._errorHandler.handleError(error); }); }
                });
                return result.pipe(enterZone(this._ngZone));
            };
        /**
         * @private
         * @param {?} action
         * @return {?}
         */
        InternalDispatcher.prototype.dispatchSingle = /**
         * @private
         * @param {?} action
         * @return {?}
         */
            function (action) {
                var _this = this;
                /** @type {?} */
                var prevState = this._stateStream.getValue();
                /** @type {?} */
                var plugins = this._pluginManager.plugins;
                return (( /** @type {?} */(compose(__spread(plugins, [
                    function (nextState, nextAction) {
                        if (nextState !== prevState) {
                            _this._stateStream.next(nextState);
                        }
                        /** @type {?} */
                        var actionResult$ = _this.getActionResultStream(nextAction);
                        actionResult$.subscribe(function (ctx) { return _this._actions.next(ctx); });
                        _this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                        return _this.createDispatchObservable(actionResult$);
                    }
                ]))(prevState, action)))).pipe(operators.shareReplay());
            };
        /**
         * @private
         * @param {?} action
         * @return {?}
         */
        InternalDispatcher.prototype.getActionResultStream = /**
         * @private
         * @param {?} action
         * @return {?}
         */
            function (action) {
                return this._actionResults.pipe(operators.filter(function (ctx) { return ctx.action === action && ctx.status !== "DISPATCHED" /* Dispatched */; }), operators.take(1), operators.shareReplay());
            };
        /**
         * @private
         * @param {?} actionResult$
         * @return {?}
         */
        InternalDispatcher.prototype.createDispatchObservable = /**
         * @private
         * @param {?} actionResult$
         * @return {?}
         */
            function (actionResult$) {
                var _this = this;
                return actionResult$
                    .pipe(operators.exhaustMap(function (ctx) {
                    switch (ctx.status) {
                        case "SUCCESSFUL" /* Successful */:
                            return rxjs.of(_this._stateStream.getValue());
                        case "ERRORED" /* Errored */:
                            return rxjs.throwError(ctx.error);
                        default:
                            return rxjs.empty();
                    }
                }))
                    .pipe(operators.shareReplay());
            };
        InternalDispatcher.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        InternalDispatcher.ctorParameters = function () {
            return [
                { type: core.ErrorHandler },
                { type: InternalActions },
                { type: InternalDispatchedActionResults },
                { type: PluginManager },
                { type: StateStream },
                { type: core.NgZone }
            ];
        };
        return InternalDispatcher;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Object freeze code
     * https://github.com/jsdf/deep-freeze
     * @type {?}
     */
    var deepFreeze = function (o) {
        Object.freeze(o);
        /** @type {?} */
        var oIsFunction = typeof o === 'function';
        /** @type {?} */
        var hasOwnProp = Object.prototype.hasOwnProperty;
        Object.getOwnPropertyNames(o).forEach(function (prop) {
            if (hasOwnProp.call(o, prop) &&
                (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
                o[prop] !== null &&
                (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
                !Object.isFrozen(o[prop])) {
                deepFreeze(o[prop]);
            }
        });
        return o;
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State Context factory class
     * @ignore
     */
    var InternalStateOperations = /** @class */ (function () {
        function InternalStateOperations(_stateStream, _dispatcher, _config, _testBed) {
            this._stateStream = _stateStream;
            this._dispatcher = _dispatcher;
            this._config = _config;
            this._testBed = _testBed;
            this.verifyDevMode();
        }
        /**
         * Returns the root state operators.
         */
        /**
         * Returns the root state operators.
         * @return {?}
         */
        InternalStateOperations.prototype.getRootStateOperations = /**
         * Returns the root state operators.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var rootStateOperations = {
                    getState: function () { return _this._stateStream.getValue(); },
                    setState: function (newState) { return _this._stateStream.next(newState); },
                    dispatch: function (actions) { return _this._dispatcher.dispatch(actions); }
                };
                if (this._config.developmentMode) {
                    return this.ensureStateAndActionsAreImmutable(rootStateOperations);
                }
                return rootStateOperations;
            };
        /**
         * @private
         * @return {?}
         */
        InternalStateOperations.prototype.verifyDevMode = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var isTestMode = this._testBed !== null;
                if (isTestMode)
                    return;
                /** @type {?} */
                var isNgxsDevMode = this._config.developmentMode;
                /** @type {?} */
                var isNgDevMode = core.isDevMode();
                /** @type {?} */
                var incorrectProduction = !isNgDevMode && isNgxsDevMode;
                /** @type {?} */
                var incorrectDevelopment = isNgDevMode && !isNgxsDevMode;
                /** @type {?} */
                var example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
                if (incorrectProduction) {
                    console.warn('Angular is running in production mode but NGXS is still running in the development mode!\n', 'Please set developmentMode to false on the NgxsModule options when in production mode.\n', example);
                }
                else if (incorrectDevelopment) {
                    console.warn('RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n', example);
                }
            };
        /**
         * @private
         * @param {?} root
         * @return {?}
         */
        InternalStateOperations.prototype.ensureStateAndActionsAreImmutable = /**
         * @private
         * @param {?} root
         * @return {?}
         */
            function (root) {
                return {
                    getState: function () { return root.getState(); },
                    setState: function (value) {
                        /** @type {?} */
                        var frozenValue = deepFreeze(value);
                        return root.setState(frozenValue);
                    },
                    dispatch: function (actions) {
                        return root.dispatch(actions);
                    }
                };
            };
        InternalStateOperations.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        InternalStateOperations.ctorParameters = function () {
            return [
                { type: StateStream },
                { type: InternalDispatcher },
                { type: NgxsConfig },
                { type: testing.TestBed, decorators: [{ type: core.Optional }] }
            ];
        };
        return InternalStateOperations;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State Context factory class
     * @ignore
     */
    var StateContextFactory = /** @class */ (function () {
        function StateContextFactory(_internalStateOperations) {
            this._internalStateOperations = _internalStateOperations;
        }
        /**
         * Create the state context
         */
        /**
         * Create the state context
         * @param {?} metadata
         * @return {?}
         */
        StateContextFactory.prototype.createStateContext = /**
         * Create the state context
         * @param {?} metadata
         * @return {?}
         */
            function (metadata) {
                /** @type {?} */
                var root = this._internalStateOperations.getRootStateOperations();
                return {
                    getState: /**
                     * @return {?}
                     */ function () {
                        /** @type {?} */
                        var state = root.getState();
                        return getValue(state, metadata.depth);
                    },
                    patchState: /**
                     * @param {?} val
                     * @return {?}
                     */ function (val) {
                        /** @type {?} */
                        var isArray = Array.isArray(val);
                        /** @type {?} */
                        var isPrimitive = typeof val !== 'object';
                        if (isArray) {
                            throw new Error('Patching arrays is not supported.');
                        }
                        else if (isPrimitive) {
                            throw new Error('Patching primitives is not supported.');
                        }
                        /** @type {?} */
                        var state = root.getState();
                        /** @type {?} */
                        var local = getValue(state, metadata.depth);
                        /** @type {?} */
                        var clone = __assign({}, local);
                        for (var k in val) {
                            clone[k] = val[k];
                        }
                        /** @type {?} */
                        var newState = setValue(state, metadata.depth, clone);
                        root.setState(newState);
                        return newState;
                    },
                    setState: /**
                     * @param {?} val
                     * @return {?}
                     */ function (val) {
                        /** @type {?} */
                        var state = root.getState();
                        state = setValue(state, metadata.depth, val);
                        root.setState(state);
                        return state;
                    },
                    dispatch: /**
                     * @param {?} actions
                     * @return {?}
                     */ function (actions) {
                        return root.dispatch(actions);
                    }
                };
            };
        StateContextFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateContextFactory.ctorParameters = function () {
            return [
                { type: InternalStateOperations }
            ];
        };
        return StateContextFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State factory class
     * @ignore
     */
    var StateFactory = /** @class */ (function () {
        function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory) {
            this._injector = _injector;
            this._config = _config;
            this._parentFactory = _parentFactory;
            this._actions = _actions;
            this._actionResults = _actionResults;
            this._stateContextFactory = _stateContextFactory;
            this._states = [];
            this._connected = false;
        }
        Object.defineProperty(StateFactory.prototype, "states", {
            get: /**
             * @return {?}
             */ function () {
                return this._parentFactory ? this._parentFactory.states : this._states;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add a new state to the global defs.
         */
        /**
         * Add a new state to the global defs.
         * @param {?} oneOrManyStateClasses
         * @return {?}
         */
        StateFactory.prototype.add = /**
         * Add a new state to the global defs.
         * @param {?} oneOrManyStateClasses
         * @return {?}
         */
            function (oneOrManyStateClasses) {
                var e_1, _a, _b;
                /** @type {?} */
                var stateClasses;
                if (!Array.isArray(oneOrManyStateClasses)) {
                    stateClasses = [oneOrManyStateClasses];
                }
                else {
                    stateClasses = oneOrManyStateClasses;
                }
                /** @type {?} */
                var stateGraph = buildGraph(stateClasses);
                /** @type {?} */
                var sortedStates = topologicalSort(stateGraph);
                /** @type {?} */
                var depths = findFullParentPath(stateGraph);
                /** @type {?} */
                var nameGraph = nameToState(stateClasses);
                /** @type {?} */
                var mappedStores = [];
                var _loop_1 = function (name_1) {
                    /** @type {?} */
                    var stateClass = nameGraph[name_1];
                    if (!stateClass[META_KEY]) {
                        throw new Error('States must be decorated with @State() decorator');
                    }
                    /** @type {?} */
                    var depth = depths[name_1];
                    var actions = stateClass[META_KEY].actions;
                    var defaults = stateClass[META_KEY].defaults;
                    stateClass[META_KEY].path = depth;
                    stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this_1._config);
                    // ensure our store hasn't already been added
                    // but dont throw since it could be lazy
                    // loaded from different paths
                    /** @type {?} */
                    var has = this_1.states.find(function (s) { return s.name === name_1; });
                    if (!has) {
                        // create new instance of defaults
                        if (Array.isArray(defaults)) {
                            defaults = __spread(defaults);
                        }
                        else if (isObject(defaults)) {
                            defaults = __assign({}, defaults);
                        }
                        else if (defaults === undefined) {
                            defaults = {};
                        }
                        /** @type {?} */
                        var instance = this_1._injector.get(stateClass);
                        mappedStores.push({
                            actions: actions,
                            instance: instance,
                            defaults: defaults,
                            name: name_1,
                            depth: depth
                        });
                    }
                };
                var this_1 = this;
                try {
                    for (var sortedStates_1 = __values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                        var name_1 = sortedStates_1_1.value;
                        _loop_1(name_1);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return))
                            _a.call(sortedStates_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                (_b = this.states).push.apply(_b, __spread(mappedStores));
                return mappedStores;
            };
        /**
         * Add a set of states to the store and return the defaulsts
         */
        /**
         * Add a set of states to the store and return the defaulsts
         * @param {?} stateClasses
         * @return {?}
         */
        StateFactory.prototype.addAndReturnDefaults = /**
         * Add a set of states to the store and return the defaulsts
         * @param {?} stateClasses
         * @return {?}
         */
            function (stateClasses) {
                if (stateClasses) {
                    /** @type {?} */
                    var states = this.add(stateClasses);
                    /** @type {?} */
                    var defaults = states.reduce(function (result, meta) { return setValue(result, meta.depth, meta.defaults); }, {});
                    return { defaults: defaults, states: states };
                }
            };
        /**
         * Bind the actions to the handlers
         */
        /**
         * Bind the actions to the handlers
         * @return {?}
         */
        StateFactory.prototype.connectActionHandlers = /**
         * Bind the actions to the handlers
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._connected)
                    return;
                this._actions
                    .pipe(operators.filter(function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; }), operators.mergeMap(function (_a) {
                    var action = _a.action;
                    return _this.invokeActions(_this._actions, action).pipe(operators.map(function () { return ( /** @type {?} */({ action: action, status: "SUCCESSFUL" /* Successful */ })); }), operators.defaultIfEmpty(( /** @type {?} */({ action: action, status: "CANCELED" /* Canceled */ }))), operators.catchError(function (error) { return rxjs.of(( /** @type {?} */({ action: action, status: "ERRORED" /* Errored */, error: error }))); }));
                }))
                    .subscribe(function (ctx) { return _this._actionResults.next(ctx); });
                this._connected = true;
            };
        /**
         * Invoke the init function on the states.
         */
        /**
         * Invoke the init function on the states.
         * @param {?} stateMetadatas
         * @return {?}
         */
        StateFactory.prototype.invokeInit = /**
         * Invoke the init function on the states.
         * @param {?} stateMetadatas
         * @return {?}
         */
            function (stateMetadatas) {
                var e_2, _a;
                try {
                    for (var stateMetadatas_1 = __values(stateMetadatas), stateMetadatas_1_1 = stateMetadatas_1.next(); !stateMetadatas_1_1.done; stateMetadatas_1_1 = stateMetadatas_1.next()) {
                        var metadata = stateMetadatas_1_1.value;
                        /** @type {?} */
                        var instance = metadata.instance;
                        if (instance.ngxsOnInit) {
                            /** @type {?} */
                            var stateContext = this.createStateContext(metadata);
                            instance.ngxsOnInit(stateContext);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (stateMetadatas_1_1 && !stateMetadatas_1_1.done && (_a = stateMetadatas_1.return))
                            _a.call(stateMetadatas_1);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
            };
        /**
         * Invoke actions on the states.
         */
        /**
         * Invoke actions on the states.
         * @param {?} actions$
         * @param {?} action
         * @return {?}
         */
        StateFactory.prototype.invokeActions = /**
         * Invoke actions on the states.
         * @param {?} actions$
         * @param {?} action
         * @return {?}
         */
            function (actions$, action) {
                var e_3, _a, e_4, _b;
                /** @type {?} */
                var results = [];
                try {
                    for (var _c = __values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var metadata = _d.value;
                        /** @type {?} */
                        var type = getActionTypeFromInstance(action);
                        /** @type {?} */
                        var actionMetas = metadata.actions[type];
                        if (actionMetas) {
                            try {
                                for (var actionMetas_1 = __values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                                    var actionMeta = actionMetas_1_1.value;
                                    /** @type {?} */
                                    var stateContext = this.createStateContext(metadata);
                                    try {
                                        /** @type {?} */
                                        var result = metadata.instance[actionMeta.fn](stateContext, action);
                                        if (result instanceof Promise) {
                                            result = rxjs.from(result);
                                        }
                                        if (result instanceof rxjs.Observable) {
                                            result = result.pipe(actionMeta.options.cancelUncompleted
                                                ? operators.takeUntil(actions$.pipe(ofActionDispatched(action)))
                                                : operators.map(function (r) { return r; })); // map acts like a noop
                                        }
                                        else {
                                            result = rxjs.of({}).pipe(operators.shareReplay());
                                        }
                                        results.push(result);
                                    }
                                    catch (e) {
                                        results.push(rxjs.throwError(e));
                                    }
                                }
                            }
                            catch (e_4_1) {
                                e_4 = { error: e_4_1 };
                            }
                            finally {
                                try {
                                    if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return))
                                        _b.call(actionMetas_1);
                                }
                                finally {
                                    if (e_4)
                                        throw e_4.error;
                                }
                            }
                        }
                    }
                }
                catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return))
                            _a.call(_c);
                    }
                    finally {
                        if (e_3)
                            throw e_3.error;
                    }
                }
                if (!results.length) {
                    results.push(rxjs.of({}));
                }
                return rxjs.forkJoin(results);
            };
        /**
         * Create the state context
         */
        /**
         * Create the state context
         * @private
         * @param {?} metadata
         * @return {?}
         */
        StateFactory.prototype.createStateContext = /**
         * Create the state context
         * @private
         * @param {?} metadata
         * @return {?}
         */
            function (metadata) {
                return this._stateContextFactory.createStateContext(metadata);
            };
        StateFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateFactory.ctorParameters = function () {
            return [
                { type: core.Injector },
                { type: NgxsConfig },
                { type: StateFactory, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
                { type: InternalActions },
                { type: InternalDispatchedActionResults },
                { type: StateContextFactory }
            ];
        };
        return StateFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function defaultEqualityCheck(a, b) {
        return a === b;
    }
    /**
     * @param {?} equalityCheck
     * @param {?} prev
     * @param {?} next
     * @return {?}
     */
    function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
        if (prev === null || next === null || prev.length !== next.length) {
            return false;
        }
        // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
        /** @type {?} */
        var length = prev.length;
        for (var i = 0; i < length; i++) {
            if (!equalityCheck(prev[i], next[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Memoize a function on its last inputs only.
     * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
     *
     * @ignore
     * @template R, T
     * @param {?} func
     * @param {?=} equalityCheck
     * @return {?}
     */
    function memoize(func, equalityCheck) {
        if (equalityCheck === void 0) {
            equalityCheck = defaultEqualityCheck;
        }
        /** @type {?} */
        var lastArgs = null;
        /** @type {?} */
        var lastResult = null;
        // we reference arguments instead of spreading them for performance reasons
        /**
         * @return {?}
         */
        function memoized() {
            if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
                // apply arguments instead of spreading for performance.
                lastResult = func.apply(null, arguments);
            }
            lastArgs = arguments;
            return lastResult;
        }
        (( /** @type {?} */(memoized))).reset = function () {
            // The hidden (for now) ability to reset the memoization
            lastArgs = null;
            lastResult = null;
        };
        return ( /** @type {?} */(memoized));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Function for creating a selector
     * @param {?} selectors The selectors to use to create the arguments of this function
     * @param {?} originalFn The original function being made into a selector
     * @param {?=} creationMetadata
     * @return {?}
     */
    function createSelector(selectors, originalFn, creationMetadata) {
        /** @type {?} */
        var wrappedFn = function wrappedSelectorFn() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            /** @type {?} */
            var returnValue = originalFn.apply(void 0, __spread(args));
            if (returnValue instanceof Function) {
                /** @type {?} */
                var innerMemoizedFn = memoize.apply(null, [returnValue]);
                return innerMemoizedFn;
            }
            return returnValue;
        };
        /** @type {?} */
        var memoizedFn = memoize(wrappedFn);
        /** @type {?} */
        var containerClass = creationMetadata && creationMetadata.containerClass;
        /** @type {?} */
        var fn = function (state) {
            /** @type {?} */
            var results = [];
            /** @type {?} */
            var selectorsToApply = [];
            if (containerClass) {
                // If we are on a state class, add it as the first selector parameter
                /** @type {?} */
                var metadata = getStoreMetadata(containerClass);
                if (metadata) {
                    selectorsToApply.push(containerClass);
                }
            }
            if (selectors) {
                selectorsToApply.push.apply(selectorsToApply, __spread(selectors));
            }
            // Determine arguments from the app state using the selectors
            if (selectorsToApply) {
                results.push.apply(results, __spread(selectorsToApply.map(function (a) { return getSelectorFn(a)(state); })));
            }
            // if the lambda tries to access a something on the
            // state that doesn't exist, it will throw a TypeError.
            // since this is quite usual behaviour, we simply return undefined if so.
            try {
                return memoizedFn.apply(void 0, __spread(results));
            }
            catch (ex) {
                if (ex instanceof TypeError) {
                    return undefined;
                }
                throw ex;
            }
        };
        /** @type {?} */
        var selectorMetaData = ensureSelectorMetadata(memoizedFn);
        selectorMetaData.originalFn = originalFn;
        selectorMetaData.selectFromAppState = fn;
        if (creationMetadata) {
            selectorMetaData.containerClass = creationMetadata.containerClass;
            selectorMetaData.selectorName = creationMetadata.selectorName;
        }
        return memoizedFn;
    }
    /**
     * This function gets the selector function to be used to get the selected slice from the app state
     * @ignore
     * @param {?} selector
     * @return {?}
     */
    function getSelectorFn(selector) {
        /** @type {?} */
        var metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
        return (metadata && metadata.selectFromAppState) || selector;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Store = /** @class */ (function () {
        function Store(_ngZone, _stateStream, _internalStateOperations) {
            this._ngZone = _ngZone;
            this._stateStream = _stateStream;
            this._internalStateOperations = _internalStateOperations;
        }
        /**
         * Dispatches event(s).
         */
        /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
        Store.prototype.dispatch = /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
            function (event) {
                return this._internalStateOperations.getRootStateOperations().dispatch(event);
            };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.select = /**
         * @param {?} selector
         * @return {?}
         */
            function (selector) {
                /** @type {?} */
                var selectorFn = getSelectorFn(selector);
                return this._stateStream.pipe(operators.map(selectorFn), operators.catchError(function (err) {
                    // if error is TypeError we swallow it to prevent usual errors with property access
                    if (err instanceof TypeError) {
                        return rxjs.of(undefined);
                    }
                    // rethrow other errors
                    throw err;
                }), operators.distinctUntilChanged(), enterZone(this._ngZone));
            };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.selectOnce = /**
         * @param {?} selector
         * @return {?}
         */
            function (selector) {
                return this.select(selector).pipe(operators.take(1));
            };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.selectSnapshot = /**
         * @param {?} selector
         * @return {?}
         */
            function (selector) {
                /** @type {?} */
                var selectorFn = getSelectorFn(selector);
                return selectorFn(this._stateStream.getValue());
            };
        /**
         * Allow the user to subscribe to the root of the state
         */
        /**
         * Allow the user to subscribe to the root of the state
         * @param {?=} fn
         * @return {?}
         */
        Store.prototype.subscribe = /**
         * Allow the user to subscribe to the root of the state
         * @param {?=} fn
         * @return {?}
         */
            function (fn) {
                return this._stateStream.pipe(enterZone(this._ngZone)).subscribe(fn);
            };
        /**
         * Return the raw value of the state.
         */
        /**
         * Return the raw value of the state.
         * @return {?}
         */
        Store.prototype.snapshot = /**
         * Return the raw value of the state.
         * @return {?}
         */
            function () {
                return this._internalStateOperations.getRootStateOperations().getState();
            };
        /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         */
        /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         * @param {?} state
         * @return {?}
         */
        Store.prototype.reset = /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         * @param {?} state
         * @return {?}
         */
            function (state) {
                return this._internalStateOperations.getRootStateOperations().setState(state);
            };
        Store.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        Store.ctorParameters = function () {
            return [
                { type: core.NgZone },
                { type: StateStream },
                { type: InternalStateOperations }
            ];
        };
        return Store;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Allows the select decorator to get access to the DI store.
     * @ignore
     */
    var SelectFactory = /** @class */ (function () {
        function SelectFactory(store, config) {
            SelectFactory.store = store;
            SelectFactory.config = config;
        }
        SelectFactory.store = undefined;
        SelectFactory.config = undefined;
        SelectFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SelectFactory.ctorParameters = function () {
            return [
                { type: Store },
                { type: NgxsConfig }
            ];
        };
        return SelectFactory;
    }());
    /**
     * Decorator for selecting a slice of state from the store.
     * @param {?=} selectorOrFeature
     * @param {...?} paths
     * @return {?}
     */
    function Select(selectorOrFeature) {
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        return function (target, name) {
            /** @type {?} */
            var selectorFnName = '__' + name + '__selector';
            if (!selectorOrFeature) {
                // if foo$ => make it just foo
                selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;
            }
            /** @type {?} */
            var createSelect = function (fn) {
                /** @type {?} */
                var store = SelectFactory.store;
                if (!store) {
                    throw new Error('SelectFactory not connected to store!');
                }
                return store.select(fn);
            };
            /** @type {?} */
            var createSelector = function () {
                /** @type {?} */
                var config = SelectFactory.config;
                if (typeof selectorOrFeature === 'string') {
                    /** @type {?} */
                    var propsArray = paths.length ? __spread([selectorOrFeature], paths) : selectorOrFeature.split('.');
                    return propGetter(propsArray, config);
                }
                else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                    return propGetter(selectorOrFeature[META_KEY].path.split('.'), config);
                }
                else {
                    return selectorOrFeature;
                }
            };
            if (target[selectorFnName]) {
                throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
            }
            if (delete target[name]) {
                Object.defineProperty(target, selectorFnName, {
                    writable: true,
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(target, name, {
                    get: function () {
                        return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));
                    },
                    enumerable: true,
                    configurable: true
                });
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Init action
     */
    var /**
     * Init action
     */ InitState = /** @class */ (function () {
        function InitState() {
        }
        Object.defineProperty(InitState, "type", {
            get: /**
             * @return {?}
             */ function () {
                // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
                return '@@INIT';
            },
            enumerable: true,
            configurable: true
        });
        return InitState;
    }());
    /**
     * Update action
     */
    var /**
     * Update action
     */ UpdateState = /** @class */ (function () {
        function UpdateState() {
        }
        Object.defineProperty(UpdateState, "type", {
            get: /**
             * @return {?}
             */ function () {
                // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
                return '@@UPDATE_STATE';
            },
            enumerable: true,
            configurable: true
        });
        return UpdateState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Root module
     * @ignore
     */
    var NgxsRootModule = /** @class */ (function () {
        function NgxsRootModule(factory, internalStateOperations, store, select, states) {
            // add stores to the state graph and return their defaults
            /** @type {?} */
            var results = factory.addAndReturnDefaults(states);
            /** @type {?} */
            var stateOperations = internalStateOperations.getRootStateOperations();
            if (results) {
                // get our current stream
                /** @type {?} */
                var cur = stateOperations.getState();
                // set the state to the current + new
                stateOperations.setState(__assign({}, cur, results.defaults));
            }
            // connect our actions stream
            factory.connectActionHandlers();
            // dispatch the init action and invoke init function after
            stateOperations.dispatch(new InitState()).subscribe(function () {
                if (results) {
                    factory.invokeInit(results.states);
                }
            });
        }
        NgxsRootModule.decorators = [
            { type: core.NgModule }
        ];
        /** @nocollapse */
        NgxsRootModule.ctorParameters = function () {
            return [
                { type: StateFactory },
                { type: InternalStateOperations },
                { type: Store },
                { type: SelectFactory },
                { type: Array, decorators: [{ type: core.Optional }, { type: core.Inject, args: [ROOT_STATE_TOKEN,] }] }
            ];
        };
        return NgxsRootModule;
    }());
    /**
     * Feature module
     * @ignore
     */
    var NgxsFeatureModule = /** @class */ (function () {
        function NgxsFeatureModule(store, internalStateOperations, factory, states) {
            // Since FEATURE_STATE_TOKEN is a multi token, we need to
            // flatten it [[Feature1State, Feature2State], [Feature3State]]
            /** @type {?} */
            var flattenedStates = (( /** @type {?} */([]))).concat.apply((( /** @type {?} */([]))), __spread(states));
            // add stores to the state graph and return their defaults
            /** @type {?} */
            var results = factory.addAndReturnDefaults(flattenedStates);
            /** @type {?} */
            var stateOperations = internalStateOperations.getRootStateOperations();
            if (results) {
                // get our current stream
                /** @type {?} */
                var cur = stateOperations.getState();
                // set the state to the current + new
                stateOperations.setState(__assign({}, cur, results.defaults));
            }
            stateOperations.dispatch(new UpdateState()).subscribe(function () {
                if (results) {
                    factory.invokeInit(results.states);
                }
            });
        }
        NgxsFeatureModule.decorators = [
            { type: core.NgModule, args: [{},] }
        ];
        /** @nocollapse */
        NgxsFeatureModule.ctorParameters = function () {
            return [
                { type: Store },
                { type: InternalStateOperations },
                { type: StateFactory },
                { type: Array, decorators: [{ type: core.Optional }, { type: core.Inject, args: [FEATURE_STATE_TOKEN,] }] }
            ];
        };
        return NgxsFeatureModule;
    }());
    /**
     * @param {?} options
     * @return {?}
     */
    function ngxsConfigFactory(options) {
        /** @type {?} */
        var config = Object.assign(new NgxsConfig(), options);
        return config;
    }
    /** @type {?} */
    var ROOT_OPTIONS = new core.InjectionToken('ROOT_OPTIONS');
    /**
     * Ngxs Module
     */
    var NgxsModule = /** @class */ (function () {
        function NgxsModule() {
        }
        /**
         * Root module factory
         */
        /**
         * Root module factory
         * @param {?=} states
         * @param {?=} options
         * @return {?}
         */
        NgxsModule.forRoot = /**
         * Root module factory
         * @param {?=} states
         * @param {?=} options
         * @return {?}
         */
            function (states, options) {
                if (states === void 0) {
                    states = [];
                }
                if (options === void 0) {
                    options = {};
                }
                return {
                    ngModule: NgxsRootModule,
                    providers: __spread([
                        StateFactory,
                        StateContextFactory,
                        Actions,
                        InternalActions,
                        InternalDispatcher,
                        InternalDispatchedActionResults,
                        InternalStateOperations,
                        Store,
                        StateStream,
                        SelectFactory,
                        PluginManager
                    ], states, [
                        {
                            provide: ROOT_STATE_TOKEN,
                            useValue: states
                        },
                        {
                            provide: ROOT_OPTIONS,
                            useValue: options
                        },
                        {
                            provide: NgxsConfig,
                            useFactory: ngxsConfigFactory,
                            deps: [ROOT_OPTIONS]
                        }
                    ])
                };
            };
        /**
         * Feature module factory
         */
        /**
         * Feature module factory
         * @param {?} states
         * @return {?}
         */
        NgxsModule.forFeature = /**
         * Feature module factory
         * @param {?} states
         * @return {?}
         */
            function (states) {
                return {
                    ngModule: NgxsFeatureModule,
                    providers: __spread([
                        StateFactory,
                        PluginManager
                    ], states, [
                        {
                            provide: FEATURE_STATE_TOKEN,
                            multi: true,
                            useValue: states
                        }
                    ])
                };
            };
        NgxsModule.decorators = [
            { type: core.NgModule, args: [{},] }
        ];
        return NgxsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorates a method with a action information.
     * @param {?} actions
     * @param {?=} options
     * @return {?}
     */
    function Action(actions, options) {
        return function (target, name, descriptor) {
            var e_1, _a;
            /** @type {?} */
            var meta = ensureStoreMetadata(target.constructor);
            if (!Array.isArray(actions)) {
                actions = [actions];
            }
            try {
                for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                    var action = actions_1_1.value;
                    /** @type {?} */
                    var type = action.type;
                    if (!action.type) {
                        throw new Error("Action " + action.name + " is missing a static \"type\" property");
                    }
                    if (!meta.actions[type]) {
                        meta.actions[type] = [];
                    }
                    meta.actions[type].push({
                        fn: name,
                        options: options || {},
                        type: type
                    });
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return))
                        _a.call(actions_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');
    /**
     * Error message
     * @ignore
     * @type {?}
     */
    var stateNameErrorMessage = function (name) {
        return name + " is not a valid state name. It needs to be a valid object property name.";
    };
    /**
     * Decorates a class with ngxs state information.
     * @template T
     * @param {?} options
     * @return {?}
     */
    function State(options) {
        return function (target) {
            /** @type {?} */
            var meta = ensureStoreMetadata(target);
            // Handle inheritance
            if (Object.getPrototypeOf(target).hasOwnProperty(META_KEY)) {
                /** @type {?} */
                var parentMeta = Object.getPrototypeOf(target)[META_KEY];
                meta.actions = __assign({}, meta.actions, parentMeta.actions);
            }
            meta.children = options.children;
            meta.defaults = options.defaults;
            meta.name = options.name;
            if (!options.name) {
                throw new Error("States must register a 'name' property");
            }
            if (!stateNameRegex.test(options.name)) {
                throw new Error(stateNameErrorMessage(options.name));
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorator for memoizing a state selector.
     * @param {?=} selectors
     * @return {?}
     */
    function Selector(selectors) {
        return function (target, key, descriptor) {
            if (descriptor.value !== null) {
                /** @type {?} */
                var originalFn = descriptor.value;
                /** @type {?} */
                var memoizedFn_1 = createSelector(selectors, originalFn, { containerClass: target, selectorName: key });
                return {
                    configurable: true,
                    get: /**
                     * @return {?}
                     */ function () {
                        return memoizedFn_1;
                    }
                };
            }
            else {
                throw new Error('Selectors only work on methods');
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NgxsModule = NgxsModule;
    exports.Action = Action;
    exports.Store = Store;
    exports.State = State;
    exports.Select = Select;
    exports.Actions = Actions;
    exports.getSelectorMetadata = getSelectorMetadata;
    exports.getStoreMetadata = getStoreMetadata;
    exports.ensureStoreMetadata = ensureStoreMetadata;
    exports.ensureSelectorMetadata = ensureSelectorMetadata;
    exports.ofAction = ofAction;
    exports.ofActionDispatched = ofActionDispatched;
    exports.ofActionSuccessful = ofActionSuccessful;
    exports.ofActionCanceled = ofActionCanceled;
    exports.ofActionErrored = ofActionErrored;
    exports.Selector = Selector;
    exports.getActionTypeFromInstance = getActionTypeFromInstance;
    exports.actionMatcher = actionMatcher;
    exports.createSelector = createSelector;
    exports.NGXS_PLUGINS = NGXS_PLUGINS;
    exports.StateStream = StateStream;
    exports.setValue = setValue;
    exports.getValue = getValue;
    exports.InitState = InitState;
    exports.UpdateState = UpdateState;
    exports.ɵg = InternalActions;
    exports.ɵf = OrderedSubject;
    exports.ɵe = SelectFactory;
    exports.ɵn = InternalDispatchedActionResults;
    exports.ɵo = InternalDispatcher;
    exports.ɵp = StateContextFactory;
    exports.ɵm = StateFactory;
    exports.ɵq = InternalStateOperations;
    exports.ɵb = NgxsFeatureModule;
    exports.ɵa = NgxsRootModule;
    exports.ɵd = ROOT_OPTIONS;
    exports.ɵc = ngxsConfigFactory;
    exports.ɵr = PluginManager;
    exports.ɵi = FEATURE_STATE_TOKEN;
    exports.ɵj = META_KEY;
    exports.ɵl = NgxsConfig;
    exports.ɵh = ROOT_STATE_TOKEN;
    exports.ɵk = SELECTOR_META_KEY;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4cy1zdG9yZS51bWQuanMubWFwIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvc3ltYm9scy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL2ludGVybmFscy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL3V0aWxzLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvb3BlcmF0b3JzL29mLWFjdGlvbi50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL29wZXJhdG9ycy96b25lLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvYWN0aW9ucy1zdHJlYW0udHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy91dGlscy9jb21wb3NlLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvaW50ZXJuYWwvc3RhdGUtc3RyZWFtLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvcGx1Z2luLW1hbmFnZXIudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9kaXNwYXRjaGVyLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvZnJlZXplLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy91dGlscy9tZW1vaXplLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvc2VsZWN0b3ItdXRpbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9zdG9yZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvc2VsZWN0LnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvYWN0aW9ucy9hY3Rpb25zLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvbW9kdWxlLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvZGVjb3JhdG9ycy9hY3Rpb24udHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9kZWNvcmF0b3JzL3N0YXRlLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvZGVjb3JhdG9ycy9zZWxlY3Rvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmV4cG9ydCBjb25zdCBST09UX1NUQVRFX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuPGFueT4oJ1JPT1RfU1RBVEVfVE9LRU4nKTtcclxuZXhwb3J0IGNvbnN0IEZFQVRVUkVfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignRkVBVFVSRV9TVEFURV9UT0tFTicpO1xyXG5leHBvcnQgY29uc3QgTUVUQV9LRVkgPSAnTkdYU19NRVRBJztcclxuZXhwb3J0IGNvbnN0IFNFTEVDVE9SX01FVEFfS0VZID0gJ05HWFNfU0VMRUNUT1JfTUVUQSc7XHJcblxyXG5leHBvcnQgY29uc3QgTkdYU19QTFVHSU5TID0gbmV3IEluamVjdGlvblRva2VuKCdOR1hTX1BMVUdJTlMnKTtcclxuZXhwb3J0IHR5cGUgTmd4c1BsdWdpbkNvbnN0cnVjdG9yID0gbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gTmd4c1BsdWdpbjtcclxuZXhwb3J0IHR5cGUgTmd4c1BsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pID0+IGFueTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgTkdYUyBjb25maWcgc2V0dGluZ3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmd4c0NvbmZpZyB7XHJcbiAgLyoqXHJcbiAgICogUnVuIGluIGRldmVsb3BtZW50IG1vZGUuIFRoaXMgd2lsbCBhZGQgYWRkaXRpb25hbCBkZWJ1Z2dpbmcgZmVhdHVyZXM6XHJcbiAgICogLSBPYmplY3QuZnJlZXplIG9uIHRoZSBzdGF0ZSBhbmQgYWN0aW9ucyB0byBndWFyYW50ZWUgaW1tdXRhYmlsaXR5XHJcbiAgICogKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAqL1xyXG4gIGRldmVsb3BtZW50TW9kZTogYm9vbGVhbjtcclxuICBjb21wYXRpYmlsaXR5OiB7XHJcbiAgICAvKipcclxuICAgICAqIFN1cHBvcnQgYSBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXHJcbiAgICAgKiBUaGlzIHdpbGwgY2lydW12ZW50IHNvbWUgb3B0aW1pc2F0aW9ucyB0aGF0IHZpb2xhdGUgYSBzdHJpY3QgQ1NQIHRocm91Z2ggdGhlIHVzZSBvZiBgbmV3IEZ1bmN0aW9uKC4uLilgLlxyXG4gICAgICogKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAgICovXHJcbiAgICBzdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3k6IGJvb2xlYW47XHJcbiAgfTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNvbXBhdGliaWxpdHkgPSB7XHJcbiAgICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogZmFsc2VcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3RhdGUgY29udGV4dCBwcm92aWRlZCB0byB0aGUgYWN0aW9ucyBpbiB0aGUgc3RhdGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ29udGV4dDxUPiB7XHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAqL1xyXG4gIGdldFN0YXRlKCk6IFQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBzdGF0ZSB0byBhIG5ldyB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRTdGF0ZSh2YWw6IFQpO1xyXG5cclxuICAvKipcclxuICAgKiBQYXRjaCB0aGUgZXhpc3Rpbmcgc3RhdGUgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICovXHJcbiAgcGF0Y2hTdGF0ZSh2YWw6IFBhcnRpYWw8VD4pO1xyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaCBhIG5ldyBhY3Rpb24gYW5kIHJldHVybiB0aGUgZGlzcGF0Y2hlZCBvYnNlcnZhYmxlLlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTmd4c05leHRQbHVnaW5GbiA9IChzdGF0ZTogYW55LCBtdXRhdGlvbjogYW55KSA9PiBhbnk7XHJcblxyXG4vKipcclxuICogUGx1Z2luIGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzUGx1Z2luIHtcclxuICAvKipcclxuICAgKiBIYW5kbGUgdGhlIHN0YXRlL2FjdGlvbiBiZWZvcmUgaXRzIHN1Ym1pdHRlZCB0byB0aGUgc3RhdGUgaGFuZGxlcnMuXHJcbiAgICovXHJcbiAgaGFuZGxlKHN0YXRlOiBhbnksIGFjdGlvbjogYW55LCBuZXh0OiBOZ3hzTmV4dFBsdWdpbkZuKTogYW55O1xyXG59XHJcblxyXG4vKipcclxuICogT3B0aW9ucyB0aGF0IGNhbiBiZSBwcm92aWRlZCB0byB0aGUgc3RvcmUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JlT3B0aW9uczxUPiB7XHJcbiAgLyoqXHJcbiAgICogTmFtZSBvZiB0aGUgc3RhdGUuIFJlcXVpcmVkLlxyXG4gICAqL1xyXG4gIG5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBzdGF0ZS4gSWYgbm90IHByb3ZpZGVkLCB1c2VzIGVtcHR5IG9iamVjdC5cclxuICAgKi9cclxuICBkZWZhdWx0cz86IFQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YiBzdGF0ZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZS5cclxuICAgKi9cclxuICBjaGlsZHJlbj86IGFueVtdO1xyXG59XHJcblxyXG4vKipcclxuICogQWN0aW9ucyB0aGF0IGNhbiBiZSBwcm92aWRlZCBpbiBhIGFjdGlvbiBkZWNvcmF0b3IuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbk9wdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIENhbmNlbCB0aGUgcHJldmlvdXMgdW5jb21wbGV0ZWQgb2JzZXJ2YWJsZShzKS5cclxuICAgKi9cclxuICBjYW5jZWxVbmNvbXBsZXRlZD86IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPbiBpbml0IGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzT25Jbml0IHtcclxuICBuZ3hzT25Jbml0KGN0eD86IFN0YXRlQ29udGV4dDxhbnk+KTogdm9pZCB8IGFueTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTmd4c0xpZmVDeWNsZSA9IFBhcnRpYWw8Tmd4c09uSW5pdD47XHJcbiIsImltcG9ydCB7IE1FVEFfS0VZLCBBY3Rpb25PcHRpb25zLCBTRUxFQ1RPUl9NRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdEtleU1hcDxUPiB7XHJcbiAgW2tleTogc3RyaW5nXTogVDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZUNsYXNzIHtcclxuICBbTUVUQV9LRVldPzogTWV0YURhdGFNb2RlbDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU3RhdGVLZXlHcmFwaCA9IE9iamVjdEtleU1hcDxzdHJpbmdbXT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkhhbmRsZXJNZXRhRGF0YSB7XHJcbiAgZm46IHN0cmluZztcclxuICBvcHRpb25zOiBBY3Rpb25PcHRpb25zO1xyXG4gIHR5cGU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZU9wZXJhdGlvbnM8VD4ge1xyXG4gIGdldFN0YXRlKCk6IFQ7XHJcbiAgc2V0U3RhdGUodmFsOiBUKTtcclxuICBkaXNwYXRjaChhY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8dm9pZD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWV0YURhdGFNb2RlbCB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBwYXRoOiBzdHJpbmc7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGU7XHJcbiAgY2hpbGRyZW46IFN0YXRlQ2xhc3NbXTtcclxuICBpbnN0YW5jZTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTZWxlY3RGcm9tU3RhdGUgPSAoc3RhdGU6IGFueSkgPT4gYW55O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIHNlbGVjdEZyb21BcHBTdGF0ZTogU2VsZWN0RnJvbVN0YXRlO1xyXG4gIG9yaWdpbmFsRm46IEZ1bmN0aW9uO1xyXG4gIGNvbnRhaW5lckNsYXNzOiBhbnk7XHJcbiAgc2VsZWN0b3JOYW1lOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwcGVkU3RvcmUge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBhY3Rpb25zOiBPYmplY3RLZXlNYXA8QWN0aW9uSGFuZGxlck1ldGFEYXRhW10+O1xyXG4gIGRlZmF1bHRzOiBhbnk7XHJcbiAgaW5zdGFuY2U6IGFueTtcclxuICBkZXB0aDogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgY2xhc3MgYW5kIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTdG9yZU1ldGFkYXRhKHRhcmdldCk6IE1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KE1FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBNZXRhRGF0YU1vZGVsID0ge1xyXG4gICAgICBuYW1lOiBudWxsLFxyXG4gICAgICBhY3Rpb25zOiB7fSxcclxuICAgICAgZGVmYXVsdHM6IHt9LFxyXG4gICAgICBwYXRoOiBudWxsLFxyXG4gICAgICBzZWxlY3RGcm9tQXBwU3RhdGU6IG51bGwsXHJcbiAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgaW5zdGFuY2U6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIGNsYXNzIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTogTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtNRVRBX0tFWV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBzZWxlY3RvciBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShTRUxFQ1RPUl9NRVRBX0tFWSkpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsID0ge1xyXG4gICAgICBzZWxlY3RGcm9tQXBwU3RhdGU6IG51bGwsXHJcbiAgICAgIG9yaWdpbmFsRm46IG51bGwsXHJcbiAgICAgIGNvbnRhaW5lckNsYXNzOiBudWxsLFxyXG4gICAgICBzZWxlY3Rvck5hbWU6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgU0VMRUNUT1JfTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBzZWxlY3RvciBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldCk6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtTRUxFQ1RPUl9NRVRBX0tFWV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogTm90ZTogVGhpcyBpcyBub3QgYXMgZmFzdCBhcyB0aGUgYGZhc3RQcm9wR2V0dGVyYCBidXQgaXMgc3RyaWN0IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGNvbXBsaWFudC5cclxuICogU2VlIHBlcmYgaGl0OiBodHRwczovL2pzcGVyZi5jb20vZmFzdC12YWx1ZS1nZXR0ZXItZ2l2ZW4tcGF0aC8xXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcclxuICBjb25zdCBjb3B5T2ZQYXRocyA9IFsuLi5wYXRoc107XHJcbiAgcmV0dXJuIG9iaiA9PiBjb3B5T2ZQYXRocy5yZWR1Y2UoKGFjYzogYW55LCBwYXJ0OiBzdHJpbmcpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuOlxyXG4gKiAtIHBsdWNrIChPYnNlcnZhYmxlIG9wZXJhdG9yKVxyXG4gKiAtIG1lbW9pemVcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gZmFzdFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcclxuICBjb25zdCBzZWdtZW50cyA9IHBhdGhzO1xyXG4gIGxldCBzZWcgPSAnc3RvcmUuJyArIHNlZ21lbnRzWzBdO1xyXG4gIGxldCBpID0gMDtcclxuICBjb25zdCBsID0gc2VnbWVudHMubGVuZ3RoO1xyXG5cclxuICBsZXQgZXhwciA9IHNlZztcclxuICB3aGlsZSAoKytpIDwgbCkge1xyXG4gICAgZXhwciA9IGV4cHIgKyAnICYmICcgKyAoc2VnID0gc2VnICsgJy4nICsgc2VnbWVudHNbaV0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oJ3N0b3JlJywgJ3JldHVybiAnICsgZXhwciArICc7Jyk7XHJcblxyXG4gIHJldHVybiA8KHg6IGFueSkgPT4gYW55PmZuO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSwgY29uZmlnOiBOZ3hzQ29uZmlnKSB7XHJcbiAgaWYgKGNvbmZpZyAmJiBjb25maWcuY29tcGF0aWJpbGl0eSAmJiBjb25maWcuY29tcGF0aWJpbGl0eS5zdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3kpIHtcclxuICAgIHJldHVybiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhc3RQcm9wR2V0dGVyKHBhdGhzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBzdGF0ZXMsIGl0IHdpbGwgcmV0dXJuIGEgb2JqZWN0IGdyYXBoLiBFeGFtcGxlOlxyXG4gKiAgICBjb25zdCBzdGF0ZXMgPSBbXHJcbiAqICAgICAgQ2FydCxcclxuICogICAgICBDYXJ0U2F2ZWQsXHJcbiAqICAgICAgQ2FydFNhdmVkSXRlbXNcclxuICogICAgXVxyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdyYXBoKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc1tdKTogU3RhdGVLZXlHcmFwaCB7XHJcbiAgY29uc3QgZmluZE5hbWUgPSAoc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgY29uc3QgbWV0YSA9IHN0YXRlQ2xhc3Nlcy5maW5kKGcgPT4gZyA9PT0gc3RhdGVDbGFzcyk7XHJcbiAgICBpZiAoIW1ldGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBzdGF0ZSBub3QgZm91bmQ6ICR7c3RhdGVDbGFzc31gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW1ldGFbTUVUQV9LRVldKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGVzIG11c3QgYmUgZGVjb3JhdGVkIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1ldGFbTUVUQV9LRVldLm5hbWU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHN0YXRlQ2xhc3Nlcy5yZWR1Y2U8U3RhdGVLZXlHcmFwaD4oKHJlc3VsdDogU3RhdGVLZXlHcmFwaCwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgaWYgKCFzdGF0ZUNsYXNzW01FVEFfS0VZXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgbmFtZSwgY2hpbGRyZW4gfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldO1xyXG4gICAgcmVzdWx0W25hbWVdID0gKGNoaWxkcmVuIHx8IFtdKS5tYXAoZmluZE5hbWUpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9LCB7fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIHN0YXRlcyBhcnJheSwgcmV0dXJucyBvYmplY3QgZ3JhcGhcclxuICogcmV0dXJuaW5nIHRoZSBuYW1lIGFuZCBzdGF0ZSBtZXRhZGF0YS4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiB7IG1ldGFkYXRhIH1cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBuYW1lVG9TdGF0ZShzdGF0ZXM6IFN0YXRlQ2xhc3NbXSk6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiB7XHJcbiAgcmV0dXJuIHN0YXRlcy5yZWR1Y2U8T2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+PigocmVzdWx0OiBPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4sIHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3MpID0+IHtcclxuICAgIGlmICghc3RhdGVDbGFzc1tNRVRBX0tFWV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICByZXN1bHRbbWV0YS5uYW1lXSA9IHN0YXRlQ2xhc3M7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgb2JqZWN0IHJlbGF0aW9uc2hpcCBncmFwaCB3aWxsIHJldHVybiB0aGUgZnVsbCBwYXRoXHJcbiAqIGZvciB0aGUgY2hpbGQgaXRlbXMuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHIgPSB7XHJcbiAqICAgIGNhcnQ6ICdjYXJ0JyxcclxuICogICAgc2F2ZWQ6ICdjYXJ0LnNhdmVkJyxcclxuICogICAgaXRlbXM6ICdjYXJ0LnNhdmVkLml0ZW1zJ1xyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGdWxsUGFyZW50UGF0aChvYmo6IFN0YXRlS2V5R3JhcGgsIG5ld09iajogT2JqZWN0S2V5TWFwPHN0cmluZz4gPSB7fSk6IE9iamVjdEtleU1hcDxzdHJpbmc+IHtcclxuICBjb25zdCB2aXNpdCA9IChjaGlsZDogU3RhdGVLZXlHcmFwaCwga2V5VG9GaW5kOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGQpIHtcclxuICAgICAgaWYgKGNoaWxkLmhhc093blByb3BlcnR5KGtleSkgJiYgY2hpbGRba2V5XS5pbmRleE9mKGtleVRvRmluZCkgPj0gMCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KGNoaWxkLCBrZXkpO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcblxyXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KG9iaiwga2V5KTtcclxuICAgICAgbmV3T2JqW2tleV0gPSBwYXJlbnQgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3T2JqO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgZ3JhcGgsIGl0IHdpbGwgcmV0dXJuIHRoZSBpdGVtcyB0b3BvbG9naWNhbGx5IHNvcnRlZCBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCByZXN1bHRzID0gW1xyXG4gKiAgICAnaXRlbXMnLFxyXG4gKiAgICAnc2F2ZWQnLFxyXG4gKiAgICAnY2FydCdcclxuICogIF07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnQoZ3JhcGg6IFN0YXRlS2V5R3JhcGgpOiBzdHJpbmdbXSB7XHJcbiAgY29uc3Qgc29ydGVkOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGNvbnN0IHZpc2l0ZWQ6IE9iamVjdEtleU1hcDxib29sZWFuPiA9IHt9O1xyXG5cclxuICBjb25zdCB2aXNpdCA9IChuYW1lOiBzdHJpbmcsIGFuY2VzdG9yczogc3RyaW5nW10gPSBbXSkgPT4ge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFuY2VzdG9ycykpIHtcclxuICAgICAgYW5jZXN0b3JzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYW5jZXN0b3JzLnB1c2gobmFtZSk7XHJcbiAgICB2aXNpdGVkW25hbWVdID0gdHJ1ZTtcclxuXHJcbiAgICBncmFwaFtuYW1lXS5mb3JFYWNoKChkZXA6IHN0cmluZykgPT4ge1xyXG4gICAgICBpZiAoYW5jZXN0b3JzLmluZGV4T2YoZGVwKSA+PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaXJjdWxhciBkZXBlbmRlbmN5ICcke2RlcH0nIGlzIHJlcXVpcmVkIGJ5ICcke25hbWV9JzogJHthbmNlc3RvcnMuam9pbignIC0+ICcpfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmlzaXRlZFtkZXBdKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2aXNpdChkZXAsIGFuY2VzdG9ycy5zbGljZSgwKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoc29ydGVkLmluZGV4T2YobmFtZSkgPCAwKSB7XHJcbiAgICAgIHNvcnRlZC5wdXNoKG5hbWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9iamVjdC5rZXlzKGdyYXBoKS5mb3JFYWNoKGsgPT4gdmlzaXQoaykpO1xyXG5cclxuICByZXR1cm4gc29ydGVkLnJldmVyc2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG9iamVjdCBvciBub3QuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcclxuICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4iLCIvKipcclxuICogUmV0dXJucyB0aGUgdHlwZSBmcm9tIGFuIGFjdGlvbiBpbnN0YW5jZS5cclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uOiBhbnkpOiBzdHJpbmcge1xyXG4gIGlmIChhY3Rpb24uY29uc3RydWN0b3IgJiYgYWN0aW9uLmNvbnN0cnVjdG9yLnR5cGUpIHtcclxuICAgIHJldHVybiBhY3Rpb24uY29uc3RydWN0b3IudHlwZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhY3Rpb24udHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1hdGNoZXMgYSBhY3Rpb25cclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFjdGlvbk1hdGNoZXIoYWN0aW9uMTogYW55KSB7XHJcbiAgY29uc3QgdHlwZTEgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbjEpO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oYWN0aW9uMjogYW55KSB7XHJcbiAgICByZXR1cm4gdHlwZTEgPT09IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uMik7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgc2V0VmFsdWUoeyBmb286IHsgYmFyOiB7IGVhdDogZmFsc2UgfSB9IH0sXHJcbiAqICAgICAgJ2Zvby5iYXIuZWF0JywgdHJ1ZSkgLy89PiB7IGZvbzogeyBiYXI6IHsgZWF0OiB0cnVlIH0gfSB9XHJcbiAqXHJcbiAqIFdoaWxlIGl0IHRyYXZlcnNlcyBpdCBhbHNvIGNyZWF0ZXMgbmV3IG9iamVjdHMgZnJvbSB0b3AgZG93bi5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldFZhbHVlID0gKG9iajogYW55LCBwcm9wOiBzdHJpbmcsIHZhbDogYW55KSA9PiB7XHJcbiAgb2JqID0geyAuLi5vYmogfTtcclxuXHJcbiAgY29uc3Qgc3BsaXQgPSBwcm9wLnNwbGl0KCcuJyk7XHJcbiAgY29uc3QgbGFzdEluZGV4ID0gc3BsaXQubGVuZ3RoIC0gMTtcclxuXHJcbiAgc3BsaXQucmVkdWNlKChhY2MsIHBhcnQsIGluZGV4KSA9PiB7XHJcbiAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xyXG4gICAgICBhY2NbcGFydF0gPSB2YWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhY2NbcGFydF0gPSBBcnJheS5pc0FycmF5KGFjY1twYXJ0XSkgPyBbLi4uYWNjW3BhcnRdXSA6IHsgLi4uYWNjW3BhcnRdIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFjYyAmJiBhY2NbcGFydF07XHJcbiAgfSwgb2JqKTtcclxuXHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFZhbHVlID0gKG9iajogYW55LCBwcm9wOiBzdHJpbmcpID0+XHJcbiAgcHJvcC5zcGxpdCgnLicpLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxuIiwiaW1wb3J0IHsgT3BlcmF0b3JGdW5jdGlvbiwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgQWN0aW9uQ29udGV4dCwgQWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uPFQ+KGFsbG93ZWRUeXBlKTogT3BlcmF0b3JGdW5jdGlvbjxhbnksIFQ+O1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb248VD4oLi4uYWxsb3dlZFR5cGVzKTogT3BlcmF0b3JGdW5jdGlvbjxhbnksIFQ+O1xyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIGdyYWIgYWN0aW9ucyB0aGF0IGhhdmUganVzdCBiZWVuIGRpc3BhdGNoZWQgYXMgd2VsbCBhcyBhY3Rpb25zIHRoYXQgaGF2ZSBjb21wbGV0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvZkFjdGlvbiguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIE9OTFkgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gZGlzcGF0Y2hlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uRGlzcGF0Y2hlZCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSeEpTIG9wZXJhdG9yIGZvciBzZWxlY3Rpbmcgb3V0IHNwZWNpZmljIGFjdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBPTkxZIGdyYWIgYWN0aW9ucyB0aGF0IGhhdmUganVzdCBiZWVuIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvZkFjdGlvblN1Y2Nlc3NmdWwoLi4uYWxsb3dlZFR5cGVzOiBhbnlbXSkge1xyXG4gIHJldHVybiBvZkFjdGlvbk9wZXJhdG9yKGFsbG93ZWRUeXBlcywgQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgYmVlbiBjYW5jZWxlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uQ2FuY2VsZWQoLi4uYWxsb3dlZFR5cGVzOiBhbnlbXSkge1xyXG4gIHJldHVybiBvZkFjdGlvbk9wZXJhdG9yKGFsbG93ZWRUeXBlcywgQWN0aW9uU3RhdHVzLkNhbmNlbGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIE9OTFkgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IHRocm93biBhbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uRXJyb3JlZCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuRXJyb3JlZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzOiBhbnlbXSwgc3RhdHVzPzogQWN0aW9uU3RhdHVzKSB7XHJcbiAgY29uc3QgYWxsb3dlZE1hcCA9IGNyZWF0ZUFsbG93ZWRNYXAoYWxsb3dlZFR5cGVzKTtcclxuICByZXR1cm4gZnVuY3Rpb24obzogT2JzZXJ2YWJsZTxhbnk+KSB7XHJcbiAgICByZXR1cm4gby5waXBlKFxyXG4gICAgICBmaWx0ZXJTdGF0dXMoYWxsb3dlZE1hcCwgc3RhdHVzKSxcclxuICAgICAgbWFwQWN0aW9uKClcclxuICAgICk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyU3RhdHVzKGFsbG93ZWRUeXBlczogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0sIHN0YXR1cz86IEFjdGlvblN0YXR1cykge1xyXG4gIHJldHVybiBmaWx0ZXIoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgYWN0aW9uVHlwZSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoY3R4LmFjdGlvbik7XHJcbiAgICBjb25zdCB0eXBlID0gYWxsb3dlZFR5cGVzW2FjdGlvblR5cGVdO1xyXG4gICAgcmV0dXJuIHN0YXR1cyA/IHR5cGUgJiYgY3R4LnN0YXR1cyA9PT0gc3RhdHVzIDogdHlwZTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFwQWN0aW9uKCkge1xyXG4gIHJldHVybiBtYXAoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4gY3R4LmFjdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFsbG93ZWRNYXAodHlwZXM6IGFueVtdKTogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0ge1xyXG4gIHJldHVybiB0eXBlcy5yZWR1Y2UoKGFjYzogYW55LCBrbGFzczogYW55KSA9PiB7XHJcbiAgICBhY2NbZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShrbGFzcyldID0gdHJ1ZTtcclxuICAgIHJldHVybiBhY2M7XHJcbiAgfSwge30pO1xyXG59XHJcbiIsImltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuLyoqXHJcbiAqIE9wZXJhdG9yIHRvIHJ1biB0aGUgYHN1YnNjcmliZWAgaW4gYSBBbmd1bGFyIHpvbmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW50ZXJab25lPFQ+KHpvbmU6IE5nWm9uZSkge1xyXG4gIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHNpbms6IE9ic2VydmVyPFQ+KSA9PiB7XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKHtcclxuICAgICAgICBuZXh0KHgpIHtcclxuICAgICAgICAgIHpvbmUucnVuKCgpID0+IHNpbmsubmV4dCh4KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcihlKSB7XHJcbiAgICAgICAgICB6b25lLnJ1bigoKSA9PiBzaW5rLmVycm9yKGUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBsZXRlKCkge1xyXG4gICAgICAgICAgem9uZS5ydW4oKCkgPT4gc2luay5jb21wbGV0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHsgZW50ZXJab25lIH0gZnJvbSAnLi9vcGVyYXRvcnMvem9uZSc7XHJcblxyXG4vKipcclxuICogU3RhdHVzIG9mIGEgZGlzcGF0Y2hlZCBhY3Rpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBlbnVtIEFjdGlvblN0YXR1cyB7XHJcbiAgRGlzcGF0Y2hlZCA9ICdESVNQQVRDSEVEJyxcclxuICBTdWNjZXNzZnVsID0gJ1NVQ0NFU1NGVUwnLFxyXG4gIENhbmNlbGVkID0gJ0NBTkNFTEVEJyxcclxuICBFcnJvcmVkID0gJ0VSUk9SRUQnXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ29udGV4dCB7XHJcbiAgc3RhdHVzOiBBY3Rpb25TdGF0dXM7XHJcbiAgYWN0aW9uOiBhbnk7XHJcbiAgZXJyb3I/OiBFcnJvcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSBTdWJqZWN0IHRoYXQgZW5zdXJlcyB0aGF0IHN1YnNjcmliZXJzIGFyZSBub3RpZmllZCBvZiB2YWx1ZXMgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcnJpdmVkLlxyXG4gKiBBIHN0YW5kYXJkIFN1YmplY3QgZG9lcyBub3QgaGF2ZSB0aGlzIGd1YXJhbnRlZS5cclxuICogRm9yIGV4YW1wbGUsIGdpdmVuIHRoZSBmb2xsb3dpbmcgY29kZTpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiAgIGNvbnN0IHN1YmplY3QgPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XHJcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4ge1xyXG4gICAgICAgaWYgKHZhbHVlID09PSAnc3RhcnQnKSBzdWJqZWN0Lm5leHQoJ2VuZCcpO1xyXG4gICAgIH0pO1xyXG4gICAgIHN1YmplY3Quc3Vic2NyaWJlKHZhbHVlID0+IHsgfSk7XHJcbiAgICAgc3ViamVjdC5uZXh0KCdzdGFydCcpO1xyXG4gKiBgYGBcclxuICogV2hlbiBgc3ViamVjdGAgaXMgYSBzdGFuZGFyZCBgU3ViamVjdDxUPmAgdGhlIHNlY29uZCBzdWJzY3JpYmVyIHdvdWxkIHJlY2lldmUgYGVuZGAgYW5kIHRoZW4gYHN0YXJ0YC5cclxuICogV2hlbiBgc3ViamVjdGAgaXMgYSBgT3JkZXJlZFN1YmplY3Q8VD5gIHRoZSBzZWNvbmQgc3Vic2NyaWJlciB3b3VsZCByZWNpZXZlIGBzdGFydGAgYW5kIHRoZW4gYGVuZGAuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgT3JkZXJlZFN1YmplY3Q8VD4gZXh0ZW5kcyBTdWJqZWN0PFQ+IHtcclxuICBwcml2YXRlIF9pdGVtUXVldWU6IFRbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2J1c3lQdXNoaW5nTmV4dCA9IGZhbHNlO1xyXG5cclxuICBuZXh0KHZhbHVlPzogVCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2J1c3lQdXNoaW5nTmV4dCkge1xyXG4gICAgICB0aGlzLl9pdGVtUXVldWUudW5zaGlmdCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2J1c3lQdXNoaW5nTmV4dCA9IHRydWU7XHJcbiAgICBzdXBlci5uZXh0KHZhbHVlKTtcclxuICAgIHdoaWxlICh0aGlzLl9pdGVtUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSB0aGlzLl9pdGVtUXVldWUucG9wKCk7XHJcbiAgICAgIHN1cGVyLm5leHQobmV4dFZhbHVlKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2J1c3lQdXNoaW5nTmV4dCA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIEFjdGlvbiBzdHJlYW0gdGhhdCBpcyBlbWl0dGVkIGFueXRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbEFjdGlvbnMgZXh0ZW5kcyBPcmRlcmVkU3ViamVjdDxBY3Rpb25Db250ZXh0PiB7fVxyXG5cclxuLyoqXHJcbiAqIEFjdGlvbiBzdHJlYW0gdGhhdCBpcyBlbWl0dGVkIGFueXRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQuXHJcbiAqXHJcbiAqIFlvdSBjYW4gbGlzdGVuIHRvIHRoaXMgaW4gc2VydmljZXMgdG8gcmVhY3Qgd2l0aG91dCBzdG9yZXMuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBBY3Rpb25zIGV4dGVuZHMgT2JzZXJ2YWJsZTxhbnk+IHtcclxuICBjb25zdHJ1Y3RvcihhY3Rpb25zJDogSW50ZXJuYWxBY3Rpb25zLCBuZ1pvbmU6IE5nWm9uZSkge1xyXG4gICAgc3VwZXIob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICBhY3Rpb25zJFxyXG4gICAgICAgIC5waXBlKGVudGVyWm9uZShuZ1pvbmUpKVxyXG4gICAgICAgIC5zdWJzY3JpYmUocmVzID0+IG9ic2VydmVyLm5leHQocmVzKSwgZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksICgpID0+IG9ic2VydmVyLmNvbXBsZXRlKCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb21wb3NlcyBhIGFycmF5IG9mIGZ1bmN0aW9ucyBmcm9tIGxlZnQgdG8gcmlnaHQuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgICAgY29tcG9zZShbZm4sIGZpbmFsXSkoc3RhdGUsIGFjdGlvbik7XHJcbiAqXHJcbiAqIHRoZW4gdGhlIGZ1bmNzIGhhdmUgYSBzaWduYXR1cmUgbGlrZTpcclxuICpcclxuICogICAgICBmdW5jdGlvbiBmbiAoc3RhdGUsIGFjdGlvbiwgbmV4dCkge1xyXG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnaGVyZScsIHN0YXRlLCBhY3Rpb24sIG5leHQpO1xyXG4gKiAgICAgICAgICByZXR1cm4gbmV4dChzdGF0ZSwgYWN0aW9uKTtcclxuICogICAgICB9XHJcbiAqXHJcbiAqICAgICAgZnVuY3Rpb24gZmluYWwgKHN0YXRlLCBhY3Rpb24pIHtcclxuICogICAgICAgICAgY29uc29sZS5sb2coJ2hlcmUnLCBzdGF0ZSwgYWN0aW9uKTtcclxuICogICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gKiAgICAgIH1cclxuICpcclxuICogdGhlIGxhc3QgZnVuY3Rpb24gc2hvdWxkIG5vdCBjYWxsIGBuZXh0YC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbXBvc2UgPSBmdW5jcyA9PiAoLi4uYXJncykgPT4ge1xyXG4gIGNvbnN0IGN1cnIgPSBmdW5jcy5zaGlmdCgpO1xyXG4gIHJldHVybiBjdXJyKC4uLmFyZ3MsICguLi5uZXh0QXJncykgPT4gY29tcG9zZShmdW5jcykoLi4ubmV4dEFyZ3MpKTtcclxufTtcclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbi8qKlxyXG4gKiBCZWhhdmlvclN1YmplY3Qgb2YgdGhlIGVudGlyZSBzdGF0ZS5cclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVTdHJlYW0gZXh0ZW5kcyBCZWhhdmlvclN1YmplY3Q8YW55PiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcih7fSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBTa2lwU2VsZiwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5neHNQbHVnaW5GbiwgTkdYU19QTFVHSU5TLCBOZ3hzUGx1Z2luIH0gZnJvbSAnLi9zeW1ib2xzJztcclxuXHJcbi8qKlxyXG4gKiBQbHVnaW4gbWFuYWdlciBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBQbHVnaW5NYW5hZ2VyIHtcclxuICBwbHVnaW5zOiBOZ3hzUGx1Z2luRm5bXSA9IFtdO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBAU2tpcFNlbGYoKVxyXG4gICAgcHJpdmF0ZSBfcGFyZW50TWFuYWdlcjogUGx1Z2luTWFuYWdlcixcclxuICAgIEBJbmplY3QoTkdYU19QTFVHSU5TKVxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIHByaXZhdGUgX3BsdWdpbnM6IE5neHNQbHVnaW5bXVxyXG4gICkge1xyXG4gICAgdGhpcy5yZWdpc3RlcigpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWdpc3RlcigpIHtcclxuICAgIGlmICghdGhpcy5fcGx1Z2lucykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5fcGx1Z2lucy5tYXAocGx1Z2luID0+IHtcclxuICAgICAgaWYgKHBsdWdpbi5oYW5kbGUpIHtcclxuICAgICAgICByZXR1cm4gcGx1Z2luLmhhbmRsZS5iaW5kKHBsdWdpbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHBsdWdpbjtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX3BhcmVudE1hbmFnZXIpIHtcclxuICAgICAgdGhpcy5fcGFyZW50TWFuYWdlci5wbHVnaW5zLnB1c2goLi4udGhpcy5wbHVnaW5zKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgRXJyb3JIYW5kbGVyLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIGZvcmtKb2luLCBlbXB0eSwgU3ViamVjdCwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBzaGFyZVJlcGxheSwgZmlsdGVyLCBleGhhdXN0TWFwLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gJy4uL3V0aWxzL2NvbXBvc2UnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbEFjdGlvbnMsIEFjdGlvblN0YXR1cywgQWN0aW9uQ29udGV4dCB9IGZyb20gJy4uL2FjdGlvbnMtc3RyZWFtJztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuLi9wbHVnaW4tbWFuYWdlcic7XHJcbmltcG9ydCB7IGVudGVyWm9uZSB9IGZyb20gJy4uL29wZXJhdG9ycy96b25lJztcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBBY3Rpb24gcmVzdWx0IHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhbiBhY3Rpb24gaXMgY29tcGxldGVkLlxyXG4gKiBUaGlzIGlzIHVzZWQgYXMgYSBtZXRob2Qgb2YgcmV0dXJuaW5nIHRoZSBhY3Rpb24gcmVzdWx0IHRvIHRoZSBkaXNwYXRjaGVyXHJcbiAqIGZvciB0aGUgb2JzZXJ2YWJsZSByZXR1cm5lZCBieSB0aGUgZGlzcGF0Y2goLi4uKSBjYWxsLlxyXG4gKiBUaGUgZGlzcGF0Y2hlciB0aGVuIGFzeW5jaHJvbm91c2x5IHB1c2hlcyB0aGUgcmVzdWx0IGZyb20gdGhpcyBzdHJlYW0gb250byB0aGUgbWFpbiBhY3Rpb24gc3RyZWFtIGFzIGEgcmVzdWx0LlxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyBleHRlbmRzIFN1YmplY3Q8QWN0aW9uQ29udGV4dD4ge31cclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEludGVybmFsRGlzcGF0Y2hlciB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9lcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcixcclxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcclxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXHJcbiAgICBwcml2YXRlIF9wbHVnaW5NYW5hZ2VyOiBQbHVnaW5NYW5hZ2VyLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVTdHJlYW06IFN0YXRlU3RyZWFtLFxyXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmVcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgZXZlbnQocykuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goZXZlbnQ6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIGNvbnN0IHJlc3VsdDogT2JzZXJ2YWJsZTxhbnk+ID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKGV2ZW50Lm1hcChhID0+IHRoaXMuZGlzcGF0Y2hTaW5nbGUoYSkpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaFNpbmdsZShldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJlc3VsdC5zdWJzY3JpYmUoe1xyXG4gICAgICBlcnJvcjogZXJyb3IgPT4gdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLl9lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IpKVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdC5waXBlKGVudGVyWm9uZSh0aGlzLl9uZ1pvbmUpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGlzcGF0Y2hTaW5nbGUoYWN0aW9uOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5fc3RhdGVTdHJlYW0uZ2V0VmFsdWUoKTtcclxuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5NYW5hZ2VyLnBsdWdpbnM7XHJcblxyXG4gICAgcmV0dXJuIChjb21wb3NlKFtcclxuICAgICAgLi4ucGx1Z2lucyxcclxuICAgICAgKG5leHRTdGF0ZSwgbmV4dEFjdGlvbikgPT4ge1xyXG4gICAgICAgIGlmIChuZXh0U3RhdGUgIT09IHByZXZTdGF0ZSkge1xyXG4gICAgICAgICAgdGhpcy5fc3RhdGVTdHJlYW0ubmV4dChuZXh0U3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY3Rpb25SZXN1bHQkID0gdGhpcy5nZXRBY3Rpb25SZXN1bHRTdHJlYW0obmV4dEFjdGlvbik7XHJcbiAgICAgICAgYWN0aW9uUmVzdWx0JC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvbnMubmV4dChjdHgpKTtcclxuICAgICAgICB0aGlzLl9hY3Rpb25zLm5leHQoeyBhY3Rpb246IG5leHRBY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGlzcGF0Y2hPYnNlcnZhYmxlKGFjdGlvblJlc3VsdCQpO1xyXG4gICAgICB9XHJcbiAgICBdKShwcmV2U3RhdGUsIGFjdGlvbikgYXMgT2JzZXJ2YWJsZTxhbnk+KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRBY3Rpb25SZXN1bHRTdHJlYW0oYWN0aW9uOiBhbnkpOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+IHtcclxuICAgIHJldHVybiB0aGlzLl9hY3Rpb25SZXN1bHRzLnBpcGUoXHJcbiAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguYWN0aW9uID09PSBhY3Rpb24gJiYgY3R4LnN0YXR1cyAhPT0gQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQpLFxyXG4gICAgICB0YWtlKDEpLFxyXG4gICAgICBzaGFyZVJlcGxheSgpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVEaXNwYXRjaE9ic2VydmFibGUoYWN0aW9uUmVzdWx0JDogT2JzZXJ2YWJsZTxBY3Rpb25Db250ZXh0Pik6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gYWN0aW9uUmVzdWx0JFxyXG4gICAgICAucGlwZShcclxuICAgICAgICBleGhhdXN0TWFwKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IHtcclxuICAgICAgICAgIHN3aXRjaCAoY3R4LnN0YXR1cykge1xyXG4gICAgICAgICAgICBjYXNlIEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsOlxyXG4gICAgICAgICAgICAgIHJldHVybiBvZih0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgY2FzZSBBY3Rpb25TdGF0dXMuRXJyb3JlZDpcclxuICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihjdHguZXJyb3IpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBlbXB0eSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIClcclxuICAgICAgLnBpcGUoc2hhcmVSZXBsYXkoKSk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBPYmplY3QgZnJlZXplIGNvZGVcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzZGYvZGVlcC1mcmVlemVcclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWVwRnJlZXplID0gbyA9PiB7XHJcbiAgT2JqZWN0LmZyZWV6ZShvKTtcclxuXHJcbiAgY29uc3Qgb0lzRnVuY3Rpb24gPSB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJztcclxuICBjb25zdCBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIGhhc093blByb3AuY2FsbChvLCBwcm9wKSAmJlxyXG4gICAgICAob0lzRnVuY3Rpb24gPyBwcm9wICE9PSAnY2FsbGVyJyAmJiBwcm9wICE9PSAnY2FsbGVlJyAmJiBwcm9wICE9PSAnYXJndW1lbnRzJyA6IHRydWUpICYmXHJcbiAgICAgIG9bcHJvcF0gIT09IG51bGwgJiZcclxuICAgICAgKHR5cGVvZiBvW3Byb3BdID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb1twcm9wXSA9PT0gJ2Z1bmN0aW9uJykgJiZcclxuICAgICAgIU9iamVjdC5pc0Zyb3plbihvW3Byb3BdKVxyXG4gICAgKSB7XHJcbiAgICAgIGRlZXBGcmVlemUob1twcm9wXSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBvO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBpc0Rldk1vZGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFRlc3RCZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xyXG5cclxuaW1wb3J0IHsgU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVyIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFN0YXRlU3RyZWFtIH0gZnJvbSAnLi9zdGF0ZS1zdHJlYW0nO1xyXG5pbXBvcnQgeyBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IGRlZXBGcmVlemUgfSBmcm9tICcuLi91dGlscy9mcmVlemUnO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIENvbnRleHQgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9kaXNwYXRjaGVyOiBJbnRlcm5hbERpc3BhdGNoZXIsXHJcbiAgICBwcml2YXRlIF9jb25maWc6IE5neHNDb25maWcsXHJcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF90ZXN0QmVkOiBUZXN0QmVkXHJcbiAgKSB7XHJcbiAgICB0aGlzLnZlcmlmeURldk1vZGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgc3RhdGUgb3BlcmF0b3JzLlxyXG4gICAqL1xyXG4gIGdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKTogU3RhdGVPcGVyYXRpb25zPGFueT4ge1xyXG4gICAgY29uc3Qgcm9vdFN0YXRlT3BlcmF0aW9ucyA9IHtcclxuICAgICAgZ2V0U3RhdGU6ICgpID0+IHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCksXHJcbiAgICAgIHNldFN0YXRlOiBuZXdTdGF0ZSA9PiB0aGlzLl9zdGF0ZVN0cmVhbS5uZXh0KG5ld1N0YXRlKSxcclxuICAgICAgZGlzcGF0Y2g6IGFjdGlvbnMgPT4gdGhpcy5fZGlzcGF0Y2hlci5kaXNwYXRjaChhY3Rpb25zKVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy5fY29uZmlnLmRldmVsb3BtZW50TW9kZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lbnN1cmVTdGF0ZUFuZEFjdGlvbnNBcmVJbW11dGFibGUocm9vdFN0YXRlT3BlcmF0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJvb3RTdGF0ZU9wZXJhdGlvbnM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHZlcmlmeURldk1vZGUoKSB7XHJcbiAgICBjb25zdCBpc1Rlc3RNb2RlID0gdGhpcy5fdGVzdEJlZCAhPT0gbnVsbDtcclxuICAgIGlmIChpc1Rlc3RNb2RlKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgaXNOZ3hzRGV2TW9kZSA9IHRoaXMuX2NvbmZpZy5kZXZlbG9wbWVudE1vZGU7XHJcbiAgICBjb25zdCBpc05nRGV2TW9kZSA9IGlzRGV2TW9kZSgpO1xyXG4gICAgY29uc3QgaW5jb3JyZWN0UHJvZHVjdGlvbiA9ICFpc05nRGV2TW9kZSAmJiBpc05neHNEZXZNb2RlO1xyXG4gICAgY29uc3QgaW5jb3JyZWN0RGV2ZWxvcG1lbnQgPSBpc05nRGV2TW9kZSAmJiAhaXNOZ3hzRGV2TW9kZTtcclxuICAgIGNvbnN0IGV4YW1wbGUgPSAnTmd4c01vZHVsZS5mb3JSb290KHN0YXRlcywgeyBkZXZlbG9wbWVudE1vZGU6ICFlbnZpcm9ubWVudC5wcm9kdWN0aW9uIH0pJztcclxuXHJcbiAgICBpZiAoaW5jb3JyZWN0UHJvZHVjdGlvbikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgJ0FuZ3VsYXIgaXMgcnVubmluZyBpbiBwcm9kdWN0aW9uIG1vZGUgYnV0IE5HWFMgaXMgc3RpbGwgcnVubmluZyBpbiB0aGUgZGV2ZWxvcG1lbnQgbW9kZSFcXG4nLFxyXG4gICAgICAgICdQbGVhc2Ugc2V0IGRldmVsb3BtZW50TW9kZSB0byBmYWxzZSBvbiB0aGUgTmd4c01vZHVsZSBvcHRpb25zIHdoZW4gaW4gcHJvZHVjdGlvbiBtb2RlLlxcbicsXHJcbiAgICAgICAgZXhhbXBsZVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmIChpbmNvcnJlY3REZXZlbG9wbWVudCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgJ1JFQ09NTUVOREFUSU9OOiBTZXQgZGV2ZWxvcG1lbnRNb2RlIHRvIHRydWUgb24gdGhlIE5neHNNb2R1bGUgd2hlbiBBbmd1bGFyIGlzIHJ1bm5pbmcgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG4nLFxyXG4gICAgICAgIGV4YW1wbGVcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZW5zdXJlU3RhdGVBbmRBY3Rpb25zQXJlSW1tdXRhYmxlKHJvb3Q6IFN0YXRlT3BlcmF0aW9uczxhbnk+KTogU3RhdGVPcGVyYXRpb25zPGFueT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0U3RhdGU6ICgpID0+IHJvb3QuZ2V0U3RhdGUoKSxcclxuICAgICAgc2V0U3RhdGU6IHZhbHVlID0+IHtcclxuICAgICAgICBjb25zdCBmcm96ZW5WYWx1ZSA9IGRlZXBGcmVlemUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByb290LnNldFN0YXRlKGZyb3plblZhbHVlKTtcclxuICAgICAgfSxcclxuICAgICAgZGlzcGF0Y2g6IGFjdGlvbnMgPT4ge1xyXG4gICAgICAgIHJldHVybiByb290LmRpc3BhdGNoKGFjdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dCB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBNYXBwZWRTdG9yZSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IHNldFZhbHVlLCBnZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1vcGVyYXRpb25zJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBDb250ZXh0IGZhY3RvcnkgY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVDb250ZXh0RmFjdG9yeSB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIHN0YXRlIGNvbnRleHRcclxuICAgKi9cclxuICBjcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGE6IE1hcHBlZFN0b3JlKTogU3RhdGVDb250ZXh0PGFueT4ge1xyXG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldFN0YXRlKCk6IGFueSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSByb290LmdldFN0YXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBhdGNoU3RhdGUodmFsOiBhbnkpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbCk7XHJcbiAgICAgICAgY29uc3QgaXNQcmltaXRpdmUgPSB0eXBlb2YgdmFsICE9PSAnb2JqZWN0JztcclxuXHJcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0Y2hpbmcgYXJyYXlzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRjaGluZyBwcmltaXRpdmVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcclxuICAgICAgICBjb25zdCBsb2NhbCA9IGdldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCk7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSB7IC4uLmxvY2FsIH07XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2YWwpIHtcclxuICAgICAgICAgIGNsb25lW2tdID0gdmFsW2tdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBzZXRWYWx1ZShzdGF0ZSwgbWV0YWRhdGEuZGVwdGgsIGNsb25lKTtcclxuICAgICAgICByb290LnNldFN0YXRlKG5ld1N0YXRlKTtcclxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldFN0YXRlKHZhbDogYW55KTogYW55IHtcclxuICAgICAgICBsZXQgc3RhdGUgPSByb290LmdldFN0YXRlKCk7XHJcbiAgICAgICAgc3RhdGUgPSBzZXRWYWx1ZShzdGF0ZSwgbWV0YWRhdGEuZGVwdGgsIHZhbCk7XHJcbiAgICAgICAgcm9vdC5zZXRTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICB9LFxyXG4gICAgICBkaXNwYXRjaChhY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHJvb3QuZGlzcGF0Y2goYWN0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdG9yLCBJbmplY3RhYmxlLCBTa2lwU2VsZiwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIGZvcmtKb2luLCBmcm9tLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHNoYXJlUmVwbGF5LCB0YWtlVW50aWwsIG1hcCwgY2F0Y2hFcnJvciwgZmlsdGVyLCBtZXJnZU1hcCwgZGVmYXVsdElmRW1wdHkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0xpZmVDeWNsZSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQge1xyXG4gIHRvcG9sb2dpY2FsU29ydCxcclxuICBidWlsZEdyYXBoLFxyXG4gIGZpbmRGdWxsUGFyZW50UGF0aCxcclxuICBuYW1lVG9TdGF0ZSxcclxuICBwcm9wR2V0dGVyLFxyXG4gIGlzT2JqZWN0LFxyXG4gIFN0YXRlQ2xhc3MsXHJcbiAgTWFwcGVkU3RvcmVcclxufSBmcm9tICcuL2ludGVybmFscyc7XHJcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIHNldFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBvZkFjdGlvbkRpc3BhdGNoZWQgfSBmcm9tICcuLi9vcGVyYXRvcnMvb2YtYWN0aW9uJztcclxuaW1wb3J0IHsgSW50ZXJuYWxBY3Rpb25zLCBBY3Rpb25TdGF0dXMsIEFjdGlvbkNvbnRleHQgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XHJcbmltcG9ydCB7IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgU3RhdGVDb250ZXh0RmFjdG9yeSB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcblxyXG4vKipcclxuICogU3RhdGUgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZUZhY3Rvcnkge1xyXG4gIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzIDogdGhpcy5fc3RhdGVzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcbiAgcHJpdmF0ZSBfY29ubmVjdGVkID0gZmFsc2U7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxyXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRGYWN0b3J5OiBTdGF0ZUZhY3RvcnksXHJcbiAgICBwcml2YXRlIF9hY3Rpb25zOiBJbnRlcm5hbEFjdGlvbnMsXHJcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVDb250ZXh0RmFjdG9yeTogU3RhdGVDb250ZXh0RmFjdG9yeVxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIHRoZSBnbG9iYWwgZGVmcy5cclxuICAgKi9cclxuICBhZGQob25lT3JNYW55U3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzIHwgU3RhdGVDbGFzc1tdKTogTWFwcGVkU3RvcmVbXSB7XHJcbiAgICBsZXQgc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW107XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob25lT3JNYW55U3RhdGVDbGFzc2VzKSkge1xyXG4gICAgICBzdGF0ZUNsYXNzZXMgPSBbb25lT3JNYW55U3RhdGVDbGFzc2VzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXRlQ2xhc3NlcyA9IG9uZU9yTWFueVN0YXRlQ2xhc3NlcztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGF0ZUdyYXBoID0gYnVpbGRHcmFwaChzdGF0ZUNsYXNzZXMpO1xyXG4gICAgY29uc3Qgc29ydGVkU3RhdGVzID0gdG9wb2xvZ2ljYWxTb3J0KHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgZGVwdGhzID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgbmFtZUdyYXBoID0gbmFtZVRvU3RhdGUoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRTdGF0ZXMpIHtcclxuICAgICAgY29uc3Qgc3RhdGVDbGFzcyA9IG5hbWVHcmFwaFtuYW1lXTtcclxuXHJcbiAgICAgIGlmICghc3RhdGVDbGFzc1tNRVRBX0tFWV0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkZXB0aCA9IGRlcHRoc1tuYW1lXTtcclxuICAgICAgY29uc3QgeyBhY3Rpb25zIH0gPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuICAgICAgbGV0IHsgZGVmYXVsdHMgfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldO1xyXG5cclxuICAgICAgc3RhdGVDbGFzc1tNRVRBX0tFWV0ucGF0aCA9IGRlcHRoO1xyXG4gICAgICBzdGF0ZUNsYXNzW01FVEFfS0VZXS5zZWxlY3RGcm9tQXBwU3RhdGUgPSBwcm9wR2V0dGVyKGRlcHRoLnNwbGl0KCcuJyksIHRoaXMuX2NvbmZpZyk7XHJcblxyXG4gICAgICAvLyBlbnN1cmUgb3VyIHN0b3JlIGhhc24ndCBhbHJlYWR5IGJlZW4gYWRkZWRcclxuICAgICAgLy8gYnV0IGRvbnQgdGhyb3cgc2luY2UgaXQgY291bGQgYmUgbGF6eVxyXG4gICAgICAvLyBsb2FkZWQgZnJvbSBkaWZmZXJlbnQgcGF0aHNcclxuICAgICAgY29uc3QgaGFzID0gdGhpcy5zdGF0ZXMuZmluZChzID0+IHMubmFtZSA9PT0gbmFtZSk7XHJcbiAgICAgIGlmICghaGFzKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBpbnN0YW5jZSBvZiBkZWZhdWx0c1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xyXG4gICAgICAgICAgZGVmYXVsdHMgPSBbLi4uZGVmYXVsdHNdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVmYXVsdHMpKSB7XHJcbiAgICAgICAgICBkZWZhdWx0cyA9IHsgLi4uZGVmYXVsdHMgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGRlZmF1bHRzID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX2luamVjdG9yLmdldChzdGF0ZUNsYXNzKTtcclxuXHJcbiAgICAgICAgbWFwcGVkU3RvcmVzLnB1c2goe1xyXG4gICAgICAgICAgYWN0aW9ucyxcclxuICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgZGVmYXVsdHMsXHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgZGVwdGhcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhdGVzLnB1c2goLi4ubWFwcGVkU3RvcmVzKTtcclxuXHJcbiAgICByZXR1cm4gbWFwcGVkU3RvcmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2V0IG9mIHN0YXRlcyB0byB0aGUgc3RvcmUgYW5kIHJldHVybiB0aGUgZGVmYXVsc3RzXHJcbiAgICovXHJcbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBhbnlbXSk6IHsgZGVmYXVsdHM6IGFueTsgc3RhdGVzOiBNYXBwZWRTdG9yZVtdIH0ge1xyXG4gICAgaWYgKHN0YXRlQ2xhc3Nlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZXMgPSB0aGlzLmFkZChzdGF0ZUNsYXNzZXMpO1xyXG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN0YXRlcy5yZWR1Y2UoXHJcbiAgICAgICAgKHJlc3VsdDogYW55LCBtZXRhOiBNYXBwZWRTdG9yZSkgPT4gc2V0VmFsdWUocmVzdWx0LCBtZXRhLmRlcHRoLCBtZXRhLmRlZmF1bHRzKSxcclxuICAgICAgICB7fVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIHRoZSBhY3Rpb25zIHRvIHRoZSBoYW5kbGVyc1xyXG4gICAqL1xyXG4gIGNvbm5lY3RBY3Rpb25IYW5kbGVycygpIHtcclxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHJldHVybjtcclxuICAgIHRoaXMuX2FjdGlvbnNcclxuICAgICAgLnBpcGUoXHJcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcclxuICAgICAgICBtZXJnZU1hcCgoeyBhY3Rpb24gfSkgPT5cclxuICAgICAgICAgIHRoaXMuaW52b2tlQWN0aW9ucyh0aGlzLl9hY3Rpb25zLCBhY3Rpb24pLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoKSA9PiA8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCB9KSxcclxuICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkNhbmNlbGVkIH0pLFxyXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+IG9mKDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5FcnJvcmVkLCBlcnJvciB9KSlcclxuICAgICAgICAgIClcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xyXG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZSB0aGUgaW5pdCBmdW5jdGlvbiBvbiB0aGUgc3RhdGVzLlxyXG4gICAqL1xyXG4gIGludm9rZUluaXQoc3RhdGVNZXRhZGF0YXM6IE1hcHBlZFN0b3JlW10pIHtcclxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2Ygc3RhdGVNZXRhZGF0YXMpIHtcclxuICAgICAgY29uc3QgaW5zdGFuY2U6IE5neHNMaWZlQ3ljbGUgPSBtZXRhZGF0YS5pbnN0YW5jZTtcclxuXHJcbiAgICAgIGlmIChpbnN0YW5jZS5uZ3hzT25Jbml0KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gICAgICAgIGluc3RhbmNlLm5neHNPbkluaXQoc3RhdGVDb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlIGFjdGlvbnMgb24gdGhlIHN0YXRlcy5cclxuICAgKi9cclxuICBpbnZva2VBY3Rpb25zKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIGFjdGlvbikge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2YgdGhpcy5zdGF0ZXMpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uKTtcclxuICAgICAgY29uc3QgYWN0aW9uTWV0YXMgPSBtZXRhZGF0YS5hY3Rpb25zW3R5cGVdO1xyXG5cclxuICAgICAgaWYgKGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhIG9mIGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGEuaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBmcm9tKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXHJcbiAgICAgICAgICAgICAgICBhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWRcclxuICAgICAgICAgICAgICAgICAgPyB0YWtlVW50aWwoYWN0aW9ucyQucGlwZShvZkFjdGlvbkRpc3BhdGNoZWQoYWN0aW9uKSkpXHJcbiAgICAgICAgICAgICAgICAgIDogbWFwKHIgPT4gcilcclxuICAgICAgICAgICAgICApOyAvLyBtYXAgYWN0cyBsaWtlIGEgbm9vcFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IG9mKHt9KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRocm93RXJyb3IoZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgcmVzdWx0cy5wdXNoKG9mKHt9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcmtKb2luKHJlc3VsdHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBzdGF0ZSBjb250ZXh0XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGE6IE1hcHBlZFN0b3JlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gIH1cclxufVxyXG4iLCJmdW5jdGlvbiBkZWZhdWx0RXF1YWxpdHlDaGVjayhhOiBhbnksIGI6IGFueSkge1xyXG4gIHJldHVybiBhID09PSBiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbChcclxuICBlcXVhbGl0eUNoZWNrOiAoYTogYW55LCBiOiBhbnkpID0+IGJvb2xlYW4sXHJcbiAgcHJldjogSUFyZ3VtZW50cyB8IG51bGwsXHJcbiAgbmV4dDogSUFyZ3VtZW50cyB8IG51bGxcclxuKSB7XHJcbiAgaWYgKHByZXYgPT09IG51bGwgfHwgbmV4dCA9PT0gbnVsbCB8fCBwcmV2Lmxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIERvIHRoaXMgaW4gYSBmb3IgbG9vcCAoYW5kIG5vdCBhIGBmb3JFYWNoYCBvciBhbiBgZXZlcnlgKSBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGVxdWFsaXR5IGFzIGZhc3QgYXMgcG9zc2libGUuXHJcbiAgY29uc3QgbGVuZ3RoID0gcHJldi5sZW5ndGg7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogTWVtb2l6ZSBhIGZ1bmN0aW9uIG9uIGl0cyBsYXN0IGlucHV0cyBvbmx5LlxyXG4gKiBPcmluZ2luYWxseSBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vcmVkdXhqcy9yZXNlbGVjdC9ibG9iL21hc3Rlci9zcmMvaW5kZXguanNcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemU8UiwgVCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUj4oZnVuYzogVCwgZXF1YWxpdHlDaGVjayA9IGRlZmF1bHRFcXVhbGl0eUNoZWNrKTogVCB7XHJcbiAgbGV0IGxhc3RBcmdzOiBJQXJndW1lbnRzIHwgbnVsbCA9IG51bGw7XHJcbiAgbGV0IGxhc3RSZXN1bHQ6IGFueSA9IG51bGw7XHJcbiAgLy8gd2UgcmVmZXJlbmNlIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyB0aGVtIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXHJcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XHJcbiAgICBpZiAoIWFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKGVxdWFsaXR5Q2hlY2ssIGxhc3RBcmdzLCBhcmd1bWVudHMpKSB7XHJcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXHJcbiAgICAgIGxhc3RSZXN1bHQgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICB9XHJcbiAgKDxhbnk+bWVtb2l6ZWQpLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBUaGUgaGlkZGVuIChmb3Igbm93KSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBtZW1vaXphdGlvblxyXG4gICAgbGFzdEFyZ3MgPSBudWxsO1xyXG4gICAgbGFzdFJlc3VsdCA9IG51bGw7XHJcbiAgfTtcclxuICByZXR1cm4gbWVtb2l6ZWQgYXMgVDtcclxufVxyXG4iLCJpbXBvcnQgeyBTZWxlY3RGcm9tU3RhdGUsIGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEsIGdldFNlbGVjdG9yTWV0YWRhdGEsIGdldFN0b3JlTWV0YWRhdGEgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi4vdXRpbHMvbWVtb2l6ZSc7XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgc2VsZWN0b3JcclxuICogQHBhcmFtIHNlbGVjdG9ycyBUaGUgc2VsZWN0b3JzIHRvIHVzZSB0byBjcmVhdGUgdGhlIGFyZ3VtZW50cyBvZiB0aGlzIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSBvcmlnaW5hbEZuIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBiZWluZyBtYWRlIGludG8gYSBzZWxlY3RvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yKFxyXG4gIHNlbGVjdG9yczogYW55W10sXHJcbiAgb3JpZ2luYWxGbjogYW55LFxyXG4gIGNyZWF0aW9uTWV0YWRhdGE/OiB7IGNvbnRhaW5lckNsYXNzOiBhbnk7IHNlbGVjdG9yTmFtZTogc3RyaW5nIH1cclxuKSB7XHJcbiAgY29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gd3JhcHBlZFNlbGVjdG9yRm4oLi4uYXJncykge1xyXG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvcmlnaW5hbEZuKC4uLmFyZ3MpO1xyXG4gICAgaWYgKHJldHVyblZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgY29uc3QgaW5uZXJNZW1vaXplZEZuID0gbWVtb2l6ZS5hcHBseShudWxsLCBbcmV0dXJuVmFsdWVdKTtcclxuICAgICAgcmV0dXJuIGlubmVyTWVtb2l6ZWRGbjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICB9O1xyXG4gIGNvbnN0IG1lbW9pemVkRm4gPSBtZW1vaXplKHdyYXBwZWRGbik7XHJcbiAgY29uc3QgY29udGFpbmVyQ2xhc3MgPSBjcmVhdGlvbk1ldGFkYXRhICYmIGNyZWF0aW9uTWV0YWRhdGEuY29udGFpbmVyQ2xhc3M7XHJcblxyXG4gIGNvbnN0IGZuID0gc3RhdGUgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdG9yc1RvQXBwbHkgPSBbXTtcclxuXHJcbiAgICBpZiAoY29udGFpbmVyQ2xhc3MpIHtcclxuICAgICAgLy8gSWYgd2UgYXJlIG9uIGEgc3RhdGUgY2xhc3MsIGFkZCBpdCBhcyB0aGUgZmlyc3Qgc2VsZWN0b3IgcGFyYW1ldGVyXHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0U3RvcmVNZXRhZGF0YShjb250YWluZXJDbGFzcyk7XHJcbiAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgIHNlbGVjdG9yc1RvQXBwbHkucHVzaChjb250YWluZXJDbGFzcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzZWxlY3RvcnMpIHtcclxuICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKC4uLnNlbGVjdG9ycyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlcm1pbmUgYXJndW1lbnRzIGZyb20gdGhlIGFwcCBzdGF0ZSB1c2luZyB0aGUgc2VsZWN0b3JzXHJcbiAgICBpZiAoc2VsZWN0b3JzVG9BcHBseSkge1xyXG4gICAgICByZXN1bHRzLnB1c2goLi4uc2VsZWN0b3JzVG9BcHBseS5tYXAoYSA9PiBnZXRTZWxlY3RvckZuKGEpKHN0YXRlKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRoZSBsYW1iZGEgdHJpZXMgdG8gYWNjZXNzIGEgc29tZXRoaW5nIG9uIHRoZVxyXG4gICAgLy8gc3RhdGUgdGhhdCBkb2Vzbid0IGV4aXN0LCBpdCB3aWxsIHRocm93IGEgVHlwZUVycm9yLlxyXG4gICAgLy8gc2luY2UgdGhpcyBpcyBxdWl0ZSB1c3VhbCBiZWhhdmlvdXIsIHdlIHNpbXBseSByZXR1cm4gdW5kZWZpbmVkIGlmIHNvLlxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIG1lbW9pemVkRm4oLi4ucmVzdWx0cyk7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGV4O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNlbGVjdG9yTWV0YURhdGEgPSBlbnN1cmVTZWxlY3Rvck1ldGFkYXRhKG1lbW9pemVkRm4pO1xyXG4gIHNlbGVjdG9yTWV0YURhdGEub3JpZ2luYWxGbiA9IG9yaWdpbmFsRm47XHJcbiAgc2VsZWN0b3JNZXRhRGF0YS5zZWxlY3RGcm9tQXBwU3RhdGUgPSBmbjtcclxuICBpZiAoY3JlYXRpb25NZXRhZGF0YSkge1xyXG4gICAgc2VsZWN0b3JNZXRhRGF0YS5jb250YWluZXJDbGFzcyA9IGNyZWF0aW9uTWV0YWRhdGEuY29udGFpbmVyQ2xhc3M7XHJcbiAgICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdG9yTmFtZSA9IGNyZWF0aW9uTWV0YWRhdGEuc2VsZWN0b3JOYW1lO1xyXG4gIH1cclxuICByZXR1cm4gbWVtb2l6ZWRGbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gZ2V0cyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gdG8gYmUgdXNlZCB0byBnZXQgdGhlIHNlbGVjdGVkIHNsaWNlIGZyb20gdGhlIGFwcCBzdGF0ZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0b3JGbihzZWxlY3RvcjogYW55KTogU2VsZWN0RnJvbVN0YXRlIHtcclxuICBjb25zdCBtZXRhZGF0YSA9IGdldFNlbGVjdG9yTWV0YWRhdGEoc2VsZWN0b3IpIHx8IGdldFN0b3JlTWV0YWRhdGEoc2VsZWN0b3IpO1xyXG4gIHJldHVybiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuc2VsZWN0RnJvbUFwcFN0YXRlKSB8fCBzZWxlY3RvcjtcclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBjYXRjaEVycm9yLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgZ2V0U2VsZWN0b3JGbiB9IGZyb20gJy4vdXRpbHMvc2VsZWN0b3ItdXRpbHMnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XHJcbmltcG9ydCB7IFN0YXRlU3RyZWFtIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1zdHJlYW0nO1xyXG5pbXBvcnQgeyBlbnRlclpvbmUgfSBmcm9tICcuL29wZXJhdG9ycy96b25lJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFN0b3JlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVTdHJlYW06IFN0YXRlU3RyZWFtLFxyXG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zXHJcbiAgKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaGVzIGV2ZW50KHMpLlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoKGV2ZW50OiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpLmRpc3BhdGNoKGV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdHMgYSBzbGljZSBvZiBkYXRhIGZyb20gdGhlIHN0b3JlLlxyXG4gICAqL1xyXG4gIHNlbGVjdDxUPihzZWxlY3RvcjogKHN0YXRlOiBhbnksIC4uLnN0YXRlczogYW55W10pID0+IFQpOiBPYnNlcnZhYmxlPFQ+O1xyXG4gIHNlbGVjdChzZWxlY3Rvcjogc3RyaW5nIHwgYW55KTogT2JzZXJ2YWJsZTxhbnk+O1xyXG4gIHNlbGVjdChzZWxlY3RvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSBnZXRTZWxlY3RvckZuKHNlbGVjdG9yKTtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZVN0cmVhbS5waXBlKFxyXG4gICAgICBtYXAoc2VsZWN0b3JGbiksXHJcbiAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHtcclxuICAgICAgICAvLyBpZiBlcnJvciBpcyBUeXBlRXJyb3Igd2Ugc3dhbGxvdyBpdCB0byBwcmV2ZW50IHVzdWFsIGVycm9ycyB3aXRoIHByb3BlcnR5IGFjY2Vzc1xyXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcclxuICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmV0aHJvdyBvdGhlciBlcnJvcnNcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH0pLFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICBlbnRlclpvbmUodGhpcy5fbmdab25lKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBvbmUgc2xpY2Ugb2YgZGF0YSBmcm9tIHRoZSBzdG9yZS5cclxuICAgKi9cclxuICBzZWxlY3RPbmNlPFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IE9ic2VydmFibGU8VD47XHJcbiAgc2VsZWN0T25jZShzZWxlY3Rvcjogc3RyaW5nIHwgYW55KTogT2JzZXJ2YWJsZTxhbnk+O1xyXG4gIHNlbGVjdE9uY2Uoc2VsZWN0b3I6IGFueSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Qoc2VsZWN0b3IpLnBpcGUodGFrZSgxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWxlY3QgYSBzbmFwc2hvdCBmcm9tIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICBzZWxlY3RTbmFwc2hvdDxUPihzZWxlY3RvcjogKHN0YXRlOiBhbnksIC4uLnN0YXRlczogYW55W10pID0+IFQpOiBUO1xyXG4gIHNlbGVjdFNuYXBzaG90KHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBhbnk7XHJcbiAgc2VsZWN0U25hcHNob3Qoc2VsZWN0b3I6IGFueSk6IGFueSB7XHJcbiAgICBjb25zdCBzZWxlY3RvckZuID0gZ2V0U2VsZWN0b3JGbihzZWxlY3Rvcik7XHJcbiAgICByZXR1cm4gc2VsZWN0b3JGbih0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbG93IHRoZSB1c2VyIHRvIHN1YnNjcmliZSB0byB0aGUgcm9vdCBvZiB0aGUgc3RhdGVcclxuICAgKi9cclxuICBzdWJzY3JpYmUoZm4/OiBhbnkpOiBTdWJzY3JpcHRpb24ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlU3RyZWFtLnBpcGUoZW50ZXJab25lKHRoaXMuX25nWm9uZSkpLnN1YnNjcmliZShmbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHJhdyB2YWx1ZSBvZiB0aGUgc3RhdGUuXHJcbiAgICovXHJcbiAgc25hcHNob3QoKTogYW55IHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuZ2V0U3RhdGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBzdGF0ZSB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bFxyXG4gICAqIGZvciBwbHVnaW4ncyB3aG8gbmVlZCB0byBtb2RpZnkgdGhlIHN0YXRlIGRpcmVjdGx5IG9yIHVuaXQgdGVzdGluZy5cclxuICAgKi9cclxuICByZXNldChzdGF0ZTogYW55KSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpLnNldFN0YXRlKHN0YXRlKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICcuLi9zdG9yZSc7XHJcbmltcG9ydCB7IHByb3BHZXR0ZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5cclxuLyoqXHJcbiAqIEFsbG93cyB0aGUgc2VsZWN0IGRlY29yYXRvciB0byBnZXQgYWNjZXNzIHRvIHRoZSBESSBzdG9yZS5cclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU2VsZWN0RmFjdG9yeSB7XHJcbiAgc3RhdGljIHN0b3JlOiBTdG9yZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICBzdGF0aWMgY29uZmlnOiBOZ3hzQ29uZmlnIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gIGNvbnN0cnVjdG9yKHN0b3JlOiBTdG9yZSwgY29uZmlnOiBOZ3hzQ29uZmlnKSB7XHJcbiAgICBTZWxlY3RGYWN0b3J5LnN0b3JlID0gc3RvcmU7XHJcbiAgICBTZWxlY3RGYWN0b3J5LmNvbmZpZyA9IGNvbmZpZztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgZm9yIHNlbGVjdGluZyBhIHNsaWNlIG9mIHN0YXRlIGZyb20gdGhlIHN0b3JlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFNlbGVjdChzZWxlY3Rvck9yRmVhdHVyZT8sIC4uLnBhdGhzOiBzdHJpbmdbXSkge1xyXG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQ6IGFueSwgbmFtZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzZWxlY3RvckZuTmFtZSA9ICdfXycgKyBuYW1lICsgJ19fc2VsZWN0b3InO1xyXG5cclxuICAgIGlmICghc2VsZWN0b3JPckZlYXR1cmUpIHtcclxuICAgICAgLy8gaWYgZm9vJCA9PiBtYWtlIGl0IGp1c3QgZm9vXHJcbiAgICAgIHNlbGVjdG9yT3JGZWF0dXJlID0gbmFtZS5sYXN0SW5kZXhPZignJCcpID09PSBuYW1lLmxlbmd0aCAtIDEgPyBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIDEpIDogbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjcmVhdGVTZWxlY3QgPSBmbiA9PiB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gU2VsZWN0RmFjdG9yeS5zdG9yZTtcclxuXHJcbiAgICAgIGlmICghc3RvcmUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbGVjdEZhY3Rvcnkgbm90IGNvbm5lY3RlZCB0byBzdG9yZSEnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0b3JlLnNlbGVjdChmbik7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNyZWF0ZVNlbGVjdG9yID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb25maWcgPSBTZWxlY3RGYWN0b3J5LmNvbmZpZztcclxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yRmVhdHVyZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb25zdCBwcm9wc0FycmF5ID0gcGF0aHMubGVuZ3RoID8gW3NlbGVjdG9yT3JGZWF0dXJlLCAuLi5wYXRoc10gOiBzZWxlY3Rvck9yRmVhdHVyZS5zcGxpdCgnLicpO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJvcEdldHRlcihwcm9wc0FycmF5LCBjb25maWcpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yT3JGZWF0dXJlW01FVEFfS0VZXSAmJiBzZWxlY3Rvck9yRmVhdHVyZVtNRVRBX0tFWV0ucGF0aCkge1xyXG4gICAgICAgIHJldHVybiBwcm9wR2V0dGVyKHNlbGVjdG9yT3JGZWF0dXJlW01FVEFfS0VZXS5wYXRoLnNwbGl0KCcuJyksIGNvbmZpZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yT3JGZWF0dXJlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0YXJnZXRbc2VsZWN0b3JGbk5hbWVdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgQFNlbGVjdCBkZWNvcmF0b3IgYW5kIGEgJyArIHNlbGVjdG9yRm5OYW1lICsgJyBwcm9wZXJ0eS4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGVsZXRlIHRhcmdldFtuYW1lXSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBzZWxlY3RvckZuTmFtZSwge1xyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0b3JGbk5hbWVdIHx8ICh0aGlzW3NlbGVjdG9yRm5OYW1lXSA9IGNyZWF0ZVNlbGVjdC5hcHBseSh0aGlzLCBbY3JlYXRlU2VsZWN0b3IoKV0pKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiLyoqXHJcbiAqIEluaXQgYWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW5pdFN0YXRlIHtcclxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcbiAgICAvLyBOT1RFOiBOb3QgbmVjZXNzYXJ5IHRvIGRlY2xhcmUgdGhlIHR5cGUgaW4gdGhpcyB3YXkgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25neHMvc3RvcmUvcHVsbC82NDQjaXNzdWVjb21tZW50LTQzNjAwMzEzOFxyXG4gICAgcmV0dXJuICdAQElOSVQnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBhY3Rpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBVcGRhdGVTdGF0ZSB7XHJcbiAgc3RhdGljIGdldCB0eXBlKCkge1xyXG4gICAgLy8gTk9URTogTm90IG5lY2Vzc2FyeSB0byBkZWNsYXJlIHRoZSB0eXBlIGluIHRoaXMgd2F5IGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ3hzL3N0b3JlL3B1bGwvNjQ0I2lzc3VlY29tbWVudC00MzYwMDMxMzhcclxuICAgIHJldHVybiAnQEBVUERBVEVfU1RBVEUnO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBOZ01vZHVsZSwgTW9kdWxlV2l0aFByb3ZpZGVycywgT3B0aW9uYWwsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IFJPT1RfU1RBVEVfVE9LRU4sIEZFQVRVUkVfU1RBVEVfVE9LRU4sIE5neHNDb25maWcgfSBmcm9tICcuL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBTdGF0ZUZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWZhY3RvcnknO1xyXG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xyXG5pbXBvcnQgeyBBY3Rpb25zLCBJbnRlcm5hbEFjdGlvbnMgfSBmcm9tICcuL2FjdGlvbnMtc3RyZWFtJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVyLCBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMnO1xyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4vc3RvcmUnO1xyXG5pbXBvcnQgeyBTZWxlY3RGYWN0b3J5IH0gZnJvbSAnLi9kZWNvcmF0b3JzL3NlbGVjdCc7XHJcbmltcG9ydCB7IFN0YXRlU3RyZWFtIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1zdHJlYW0nO1xyXG5pbXBvcnQgeyBQbHVnaW5NYW5hZ2VyIH0gZnJvbSAnLi9wbHVnaW4tbWFuYWdlcic7XHJcbmltcG9ydCB7IEluaXRTdGF0ZSwgVXBkYXRlU3RhdGUgfSBmcm9tICcuL2FjdGlvbnMvYWN0aW9ucyc7XHJcblxyXG4vKipcclxuICogUm9vdCBtb2R1bGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQE5nTW9kdWxlKClcclxuZXhwb3J0IGNsYXNzIE5neHNSb290TW9kdWxlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcclxuICAgIGludGVybmFsU3RhdGVPcGVyYXRpb25zOiBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgIHN0b3JlOiBTdG9yZSxcclxuICAgIHNlbGVjdDogU2VsZWN0RmFjdG9yeSxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBASW5qZWN0KFJPT1RfU1RBVEVfVE9LRU4pXHJcbiAgICBzdGF0ZXM6IGFueVtdXHJcbiAgKSB7XHJcbiAgICAvLyBhZGQgc3RvcmVzIHRvIHRoZSBzdGF0ZSBncmFwaCBhbmQgcmV0dXJuIHRoZWlyIGRlZmF1bHRzXHJcbiAgICBjb25zdCByZXN1bHRzID0gZmFjdG9yeS5hZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZXMpO1xyXG5cclxuICAgIGNvbnN0IHN0YXRlT3BlcmF0aW9ucyA9IGludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKTtcclxuICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgIC8vIGdldCBvdXIgY3VycmVudCBzdHJlYW1cclxuICAgICAgY29uc3QgY3VyID0gc3RhdGVPcGVyYXRpb25zLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICAvLyBzZXQgdGhlIHN0YXRlIHRvIHRoZSBjdXJyZW50ICsgbmV3XHJcbiAgICAgIHN0YXRlT3BlcmF0aW9ucy5zZXRTdGF0ZSh7IC4uLmN1ciwgLi4ucmVzdWx0cy5kZWZhdWx0cyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25uZWN0IG91ciBhY3Rpb25zIHN0cmVhbVxyXG4gICAgZmFjdG9yeS5jb25uZWN0QWN0aW9uSGFuZGxlcnMoKTtcclxuXHJcbiAgICAvLyBkaXNwYXRjaCB0aGUgaW5pdCBhY3Rpb24gYW5kIGludm9rZSBpbml0IGZ1bmN0aW9uIGFmdGVyXHJcbiAgICBzdGF0ZU9wZXJhdGlvbnMuZGlzcGF0Y2gobmV3IEluaXRTdGF0ZSgpKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAgIGZhY3RvcnkuaW52b2tlSW5pdChyZXN1bHRzLnN0YXRlcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZlYXR1cmUgbW9kdWxlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBOZ01vZHVsZSh7fSlcclxuZXhwb3J0IGNsYXNzIE5neHNGZWF0dXJlTW9kdWxlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHN0b3JlOiBTdG9yZSxcclxuICAgIGludGVybmFsU3RhdGVPcGVyYXRpb25zOiBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgIGZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBASW5qZWN0KEZFQVRVUkVfU1RBVEVfVE9LRU4pXHJcbiAgICBzdGF0ZXM6IGFueVtdW11cclxuICApIHtcclxuICAgIC8vIFNpbmNlIEZFQVRVUkVfU1RBVEVfVE9LRU4gaXMgYSBtdWx0aSB0b2tlbiwgd2UgbmVlZCB0b1xyXG4gICAgLy8gZmxhdHRlbiBpdCBbW0ZlYXR1cmUxU3RhdGUsIEZlYXR1cmUyU3RhdGVdLCBbRmVhdHVyZTNTdGF0ZV1dXHJcbiAgICBjb25zdCBmbGF0dGVuZWRTdGF0ZXMgPSAoW10gYXMgYW55W10pLmNvbmNhdCguLi5zdGF0ZXMpO1xyXG5cclxuICAgIC8vIGFkZCBzdG9yZXMgdG8gdGhlIHN0YXRlIGdyYXBoIGFuZCByZXR1cm4gdGhlaXIgZGVmYXVsdHNcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBmYWN0b3J5LmFkZEFuZFJldHVybkRlZmF1bHRzKGZsYXR0ZW5lZFN0YXRlcyk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGVPcGVyYXRpb25zID0gaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xyXG4gICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgLy8gZ2V0IG91ciBjdXJyZW50IHN0cmVhbVxyXG4gICAgICBjb25zdCBjdXIgPSBzdGF0ZU9wZXJhdGlvbnMuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIC8vIHNldCB0aGUgc3RhdGUgdG8gdGhlIGN1cnJlbnQgKyBuZXdcclxuICAgICAgc3RhdGVPcGVyYXRpb25zLnNldFN0YXRlKHsgLi4uY3VyLCAuLi5yZXN1bHRzLmRlZmF1bHRzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlT3BlcmF0aW9ucy5kaXNwYXRjaChuZXcgVXBkYXRlU3RhdGUoKSkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgICBmYWN0b3J5Lmludm9rZUluaXQocmVzdWx0cy5zdGF0ZXMpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIE1vZHVsZU9wdGlvbnMgPSBQYXJ0aWFsPE5neHNDb25maWc+O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5neHNDb25maWdGYWN0b3J5KG9wdGlvbnM6IE1vZHVsZU9wdGlvbnMpOiBOZ3hzQ29uZmlnIHtcclxuICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKG5ldyBOZ3hzQ29uZmlnKCksIG9wdGlvbnMpO1xyXG4gIHJldHVybiBjb25maWc7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBST09UX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48TW9kdWxlT3B0aW9ucz4oJ1JPT1RfT1BUSU9OUycpO1xyXG5cclxuLyoqXHJcbiAqIE5neHMgTW9kdWxlXHJcbiAqL1xyXG5ATmdNb2R1bGUoe30pXHJcbmV4cG9ydCBjbGFzcyBOZ3hzTW9kdWxlIHtcclxuICAvKipcclxuICAgKiBSb290IG1vZHVsZSBmYWN0b3J5XHJcbiAgICovXHJcbiAgc3RhdGljIGZvclJvb3Qoc3RhdGVzOiBhbnlbXSA9IFtdLCBvcHRpb25zOiBNb2R1bGVPcHRpb25zID0ge30pOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5nTW9kdWxlOiBOZ3hzUm9vdE1vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgU3RhdGVGYWN0b3J5LFxyXG4gICAgICAgIFN0YXRlQ29udGV4dEZhY3RvcnksXHJcbiAgICAgICAgQWN0aW9ucyxcclxuICAgICAgICBJbnRlcm5hbEFjdGlvbnMsXHJcbiAgICAgICAgSW50ZXJuYWxEaXNwYXRjaGVyLFxyXG4gICAgICAgIEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXHJcbiAgICAgICAgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMsXHJcbiAgICAgICAgU3RvcmUsXHJcbiAgICAgICAgU3RhdGVTdHJlYW0sXHJcbiAgICAgICAgU2VsZWN0RmFjdG9yeSxcclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLFxyXG4gICAgICAgIC4uLnN0YXRlcyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwcm92aWRlOiBST09UX1NUQVRFX1RPS0VOLFxyXG4gICAgICAgICAgdXNlVmFsdWU6IHN0YXRlc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogUk9PVF9PUFRJT05TLFxyXG4gICAgICAgICAgdXNlVmFsdWU6IG9wdGlvbnNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IE5neHNDb25maWcsXHJcbiAgICAgICAgICB1c2VGYWN0b3J5OiBuZ3hzQ29uZmlnRmFjdG9yeSxcclxuICAgICAgICAgIGRlcHM6IFtST09UX09QVElPTlNdXHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmVhdHVyZSBtb2R1bGUgZmFjdG9yeVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmb3JGZWF0dXJlKHN0YXRlczogYW55W10pOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5nTW9kdWxlOiBOZ3hzRmVhdHVyZU1vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgU3RhdGVGYWN0b3J5LFxyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgLi4uc3RhdGVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IEZFQVRVUkVfU1RBVEVfVE9LRU4sXHJcbiAgICAgICAgICBtdWx0aTogdHJ1ZSxcclxuICAgICAgICAgIHVzZVZhbHVlOiBzdGF0ZXNcclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IGVuc3VyZVN0b3JlTWV0YWRhdGEgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBBY3Rpb25PcHRpb25zIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcblxyXG4vKipcclxuICogRGVjb3JhdGVzIGEgbWV0aG9kIHdpdGggYSBhY3Rpb24gaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQWN0aW9uKGFjdGlvbnM6IGFueSB8IGFueVtdLCBvcHRpb25zPzogQWN0aW9uT3B0aW9ucykge1xyXG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQ6IGFueSwgbmFtZTogc3RyaW5nLCBkZXNjcmlwdG9yOiBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjxhbnk+KSB7XHJcbiAgICBjb25zdCBtZXRhID0gZW5zdXJlU3RvcmVNZXRhZGF0YSh0YXJnZXQuY29uc3RydWN0b3IpO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShhY3Rpb25zKSkge1xyXG4gICAgICBhY3Rpb25zID0gW2FjdGlvbnNdO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGFjdGlvbnMpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IGFjdGlvbi50eXBlO1xyXG5cclxuICAgICAgaWYgKCFhY3Rpb24udHlwZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0aW9uICR7YWN0aW9uLm5hbWV9IGlzIG1pc3NpbmcgYSBzdGF0aWMgXCJ0eXBlXCIgcHJvcGVydHlgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFtZXRhLmFjdGlvbnNbdHlwZV0pIHtcclxuICAgICAgICBtZXRhLmFjdGlvbnNbdHlwZV0gPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbWV0YS5hY3Rpb25zW3R5cGVdLnB1c2goe1xyXG4gICAgICAgIGZuOiBuYW1lLFxyXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXHJcbiAgICAgICAgdHlwZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGVuc3VyZVN0b3JlTWV0YWRhdGEgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBTdG9yZU9wdGlvbnMsIE1FVEFfS0VZIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcblxyXG5jb25zdCBzdGF0ZU5hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ15bYS16QS1aMC05X10rJCcpO1xyXG5cclxuLyoqXHJcbiAqIEVycm9yIG1lc3NhZ2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0YXRlTmFtZUVycm9yTWVzc2FnZSA9IG5hbWUgPT5cclxuICBgJHtuYW1lfSBpcyBub3QgYSB2YWxpZCBzdGF0ZSBuYW1lLiBJdCBuZWVkcyB0byBiZSBhIHZhbGlkIG9iamVjdCBwcm9wZXJ0eSBuYW1lLmA7XHJcblxyXG4vKipcclxuICogRGVjb3JhdGVzIGEgY2xhc3Mgd2l0aCBuZ3hzIHN0YXRlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFN0YXRlPFQ+KG9wdGlvbnM6IFN0b3JlT3B0aW9uczxUPikge1xyXG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQ6IGFueSkge1xyXG4gICAgY29uc3QgbWV0YSA9IGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcclxuXHJcbiAgICAvLyBIYW5kbGUgaW5oZXJpdGFuY2VcclxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KS5oYXNPd25Qcm9wZXJ0eShNRVRBX0tFWSkpIHtcclxuICAgICAgY29uc3QgcGFyZW50TWV0YSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpW01FVEFfS0VZXTtcclxuXHJcbiAgICAgIG1ldGEuYWN0aW9ucyA9IHtcclxuICAgICAgICAuLi5tZXRhLmFjdGlvbnMsXHJcbiAgICAgICAgLi4ucGFyZW50TWV0YS5hY3Rpb25zXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbWV0YS5jaGlsZHJlbiA9IG9wdGlvbnMuY2hpbGRyZW47XHJcbiAgICBtZXRhLmRlZmF1bHRzID0gb3B0aW9ucy5kZWZhdWx0cztcclxuICAgIG1ldGEubmFtZSA9IG9wdGlvbnMubmFtZTtcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlcyBtdXN0IHJlZ2lzdGVyIGEgJ25hbWUnIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzdGF0ZU5hbWVSZWdleC50ZXN0KG9wdGlvbnMubmFtZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0YXRlTmFtZUVycm9yTWVzc2FnZShvcHRpb25zLm5hbWUpKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAnLi4vdXRpbHMvc2VsZWN0b3ItdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciBmb3IgbWVtb2l6aW5nIGEgc3RhdGUgc2VsZWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0b3Ioc2VsZWN0b3JzPzogYW55W10pIHtcclxuICByZXR1cm4gKHRhcmdldDogYW55LCBrZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSA9PiB7XHJcbiAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBvcmlnaW5hbEZuID0gZGVzY3JpcHRvci52YWx1ZTtcclxuXHJcbiAgICAgIGNvbnN0IG1lbW9pemVkRm4gPSBjcmVhdGVTZWxlY3RvcihcclxuICAgICAgICBzZWxlY3RvcnMsXHJcbiAgICAgICAgb3JpZ2luYWxGbixcclxuICAgICAgICB7IGNvbnRhaW5lckNsYXNzOiB0YXJnZXQsIHNlbGVjdG9yTmFtZToga2V5IH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgIHJldHVybiBtZW1vaXplZEZuO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0b3JzIG9ubHkgd29yayBvbiBtZXRob2RzJyk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsiSW5qZWN0aW9uVG9rZW4iLCJmaWx0ZXIiLCJtYXAiLCJPYnNlcnZhYmxlIiwidHNsaWJfMS5fX2V4dGVuZHMiLCJTdWJqZWN0IiwiSW5qZWN0YWJsZSIsIk5nWm9uZSIsIkJlaGF2aW9yU3ViamVjdCIsIk9wdGlvbmFsIiwiU2tpcFNlbGYiLCJJbmplY3QiLCJmb3JrSm9pbiIsInNoYXJlUmVwbGF5IiwidGFrZSIsImV4aGF1c3RNYXAiLCJvZiIsInRocm93RXJyb3IiLCJlbXB0eSIsIkVycm9ySGFuZGxlciIsImlzRGV2TW9kZSIsIlRlc3RCZWQiLCJ0c2xpYl8xLl9fdmFsdWVzIiwibWVyZ2VNYXAiLCJkZWZhdWx0SWZFbXB0eSIsImNhdGNoRXJyb3IiLCJmcm9tIiwidGFrZVVudGlsIiwiSW5qZWN0b3IiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsIk5nTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7SUFBQTs7Ozs7Ozs7Ozs7Ozs7SUFjQTtJQUVBLElBQUksYUFBYSxHQUFHLFVBQVMsQ0FBQyxFQUFFLENBQUM7UUFDN0IsYUFBYSxHQUFHLE1BQU0sQ0FBQyxjQUFjO2FBQ2hDLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBRSxZQUFZLEtBQUssSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzVFLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQUUsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztvQkFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUMvRSxPQUFPLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDL0IsQ0FB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