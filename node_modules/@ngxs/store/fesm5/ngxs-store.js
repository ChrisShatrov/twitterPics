import { InjectionToken, Injectable, NgZone, Optional, SkipSelf, Inject, ErrorHandler, isDevMode, Injector, NgModule } from '@angular/core';
import { __extends, __assign, __spread, __values } from 'tslib';
import { map, filter, shareReplay, exhaustMap, take, takeUntil, catchError, mergeMap, defaultIfEmpty, distinctUntilChanged } from 'rxjs/operators';
import { Observable, Subject, BehaviorSubject, of, forkJoin, empty, throwError, from } from 'rxjs';
import { TestBed } from '@angular/core/testing';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
var FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
var META_KEY = 'NGXS_META';
/** @type {?} */
var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/** @type {?} */
var NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/**
 * The NGXS config settings.
 */
var  /**
 * The NGXS config settings.
 */
NgxsConfig = /** @class */ (function () {
    function NgxsConfig() {
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
    }
    return NgxsConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getStoreMetadata(target) {
    return target[META_KEY];
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    var copyOfPaths = __spread(paths);
    return function (obj) { return copyOfPaths.reduce(function (acc, part) { return acc && acc[part]; }, obj); };
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    var segments = paths;
    /** @type {?} */
    var seg = 'store.' + segments[0];
    /** @type {?} */
    var i = 0;
    /** @type {?} */
    var l = segments.length;
    /** @type {?} */
    var expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    var fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
function buildGraph(stateClasses) {
    /** @type {?} */
    var findName = function (stateClass) {
        /** @type {?} */
        var meta = stateClasses.find(function (g) { return g === stateClass; });
        if (!meta) {
            throw new Error("Child state not found: " + stateClass);
        }
        if (!meta[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        return meta[META_KEY].name;
    };
    return stateClasses.reduce(function (result, stateClass) {
        if (!stateClass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        var _a = stateClass[META_KEY], name = _a.name, children = _a.children;
        result[name] = (children || []).map(findName);
        return result;
    }, {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
function nameToState(states) {
    return states.reduce(function (result, stateClass) {
        if (!stateClass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        /** @type {?} */
        var meta = stateClass[META_KEY];
        result[meta.name] = stateClass;
        return result;
    }, {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
function findFullParentPath(obj, newObj) {
    if (newObj === void 0) { newObj = {}; }
    /** @type {?} */
    var visit = function (child, keyToFind) {
        for (var key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                var parent_1 = visit(child, key);
                return parent_1 !== null ? parent_1 + "." + key : key;
            }
        }
        return null;
    };
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            var parent_2 = visit(obj, key);
            newObj[key] = parent_2 ? parent_2 + "." + key : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
function topologicalSort(graph) {
    /** @type {?} */
    var sorted = [];
    /** @type {?} */
    var visited = {};
    /** @type {?} */
    var visit = function (name, ancestors) {
        if (ancestors === void 0) { ancestors = []; }
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach(function (dep) {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        });
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    };
    Object.keys(graph).forEach(function (k) { return visit(k); });
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns the type from an action instance.
 * @ignore
 * @param {?} action
 * @return {?}
 */
function getActionTypeFromInstance(action) {
    if (action.constructor && action.constructor.type) {
        return action.constructor.type;
    }
    return action.type;
}
/**
 * Matches a action
 * @ignore
 * @param {?} action1
 * @return {?}
 */
function actionMatcher(action1) {
    /** @type {?} */
    var type1 = getActionTypeFromInstance(action1);
    return function (action2) {
        return type1 === getActionTypeFromInstance(action2);
    };
}
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 *
 * @ignore
 * @type {?}
 */
var setValue = function (obj, prop, val) {
    obj = __assign({}, obj);
    /** @type {?} */
    var split = prop.split('.');
    /** @type {?} */
    var lastIndex = split.length - 1;
    split.reduce(function (acc, part, index) {
        if (index === lastIndex) {
            acc[part] = val;
        }
        else {
            acc[part] = Array.isArray(acc[part]) ? __spread(acc[part]) : __assign({}, acc[part]);
        }
        return acc && acc[part];
    }, obj);
    return obj;
};
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @type {?}
 */
var getValue = function (obj, prop) {
    return prop.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj);
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will grab actions that have just been dispatched as well as actions that have completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofAction() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been dispatched
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionDispatched() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes, "DISPATCHED" /* Dispatched */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been successfully completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionSuccessful() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes, "SUCCESSFUL" /* Successful */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been canceled
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionCanceled() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes, "CANCELED" /* Canceled */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just thrown an error
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionErrored() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes, "ERRORED" /* Errored */);
}
/**
 * @param {?} allowedTypes
 * @param {?=} status
 * @return {?}
 */
function ofActionOperator(allowedTypes, status) {
    /** @type {?} */
    var allowedMap = createAllowedMap(allowedTypes);
    return function (o) {
        return o.pipe(filterStatus(allowedMap, status), mapAction());
    };
}
/**
 * @param {?} allowedTypes
 * @param {?=} status
 * @return {?}
 */
function filterStatus(allowedTypes, status) {
    return filter(function (ctx) {
        /** @type {?} */
        var actionType = getActionTypeFromInstance(ctx.action);
        /** @type {?} */
        var type = allowedTypes[actionType];
        return status ? type && ctx.status === status : type;
    });
}
/**
 * @return {?}
 */
function mapAction() {
    return map(function (ctx) { return ctx.action; });
}
/**
 * @param {?} types
 * @return {?}
 */
function createAllowedMap(types) {
    return types.reduce(function (acc, klass) {
        acc[getActionTypeFromInstance(klass)] = true;
        return acc;
    }, {});
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Operator to run the `subscribe` in a Angular zone.
 * @template T
 * @param {?} zone
 * @return {?}
 */
function enterZone(zone) {
    return function (source) {
        return new Observable(function (sink) {
            return source.subscribe({
                next: /**
                 * @param {?} x
                 * @return {?}
                 */
                function (x) {
                    zone.run(function () { return sink.next(x); });
                },
                error: /**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    zone.run(function () { return sink.error(e); });
                },
                complete: /**
                 * @return {?}
                 */
                function () {
                    zone.run(function () { return sink.complete(); });
                }
            });
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
var  /**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
OrderedSubject = /** @class */ (function (_super) {
    __extends(OrderedSubject, _super);
    function OrderedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._itemQueue = [];
        _this._busyPushingNext = false;
        return _this;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    OrderedSubject.prototype.next = /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._busyPushingNext) {
            this._itemQueue.unshift(value);
            return;
        }
        this._busyPushingNext = true;
        _super.prototype.next.call(this, value);
        while (this._itemQueue.length > 0) {
            /** @type {?} */
            var nextValue = this._itemQueue.pop();
            _super.prototype.next.call(this, nextValue);
        }
        this._busyPushingNext = false;
    };
    return OrderedSubject;
}(Subject));
/**
 * Internal Action stream that is emitted anytime an action is dispatched.
 */
var InternalActions = /** @class */ (function (_super) {
    __extends(InternalActions, _super);
    function InternalActions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InternalActions.decorators = [
        { type: Injectable }
    ];
    return InternalActions;
}(OrderedSubject));
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
var Actions = /** @class */ (function (_super) {
    __extends(Actions, _super);
    function Actions(actions$, ngZone) {
        return _super.call(this, function (observer) {
            actions$
                .pipe(enterZone(ngZone))
                .subscribe(function (res) { return observer.next(res); }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
        }) || this;
    }
    Actions.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Actions.ctorParameters = function () { return [
        { type: InternalActions },
        { type: NgZone }
    ]; };
    return Actions;
}(Observable));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Composes a array of functions from left to right. Example:
 *
 *      compose([fn, final])(state, action);
 *
 * then the funcs have a signature like:
 *
 *      function fn (state, action, next) {
 *          console.log('here', state, action, next);
 *          return next(state, action);
 *      }
 *
 *      function final (state, action) {
 *          console.log('here', state, action);
 *          return state;
 *      }
 *
 * the last function should not call `next`.
 *
 * @ignore
 * @type {?}
 */
var compose = function (funcs) { return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    /** @type {?} */
    var curr = funcs.shift();
    return curr.apply(void 0, __spread(args, [function () {
            var nextArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nextArgs[_i] = arguments[_i];
            }
            return compose(funcs).apply(void 0, __spread(nextArgs));
        }]));
}; };

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * BehaviorSubject of the entire state.
 * @ignore
 */
var StateStream = /** @class */ (function (_super) {
    __extends(StateStream, _super);
    function StateStream() {
        return _super.call(this, {}) || this;
    }
    StateStream.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateStream.ctorParameters = function () { return []; };
    return StateStream;
}(BehaviorSubject));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Plugin manager class
 * @ignore
 */
var PluginManager = /** @class */ (function () {
    function PluginManager(_parentManager, _plugins) {
        this._parentManager = _parentManager;
        this._plugins = _plugins;
        this.plugins = [];
        this.register();
    }
    /**
     * @private
     * @return {?}
     */
    PluginManager.prototype.register = /**
     * @private
     * @return {?}
     */
    function () {
        var _a;
        if (!this._plugins) {
            return;
        }
        this.plugins = this._plugins.map(function (plugin) {
            if (plugin.handle) {
                return plugin.handle.bind(plugin);
            }
            else {
                return plugin;
            }
        });
        if (this._parentManager) {
            (_a = this._parentManager.plugins).push.apply(_a, __spread(this.plugins));
        }
    };
    PluginManager.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    PluginManager.ctorParameters = function () { return [
        { type: PluginManager, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: Array, decorators: [{ type: Inject, args: [NGXS_PLUGINS,] }, { type: Optional }] }
    ]; };
    return PluginManager;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal Action result stream that is emitted when an action is completed.
 * This is used as a method of returning the action result to the dispatcher
 * for the observable returned by the dispatch(...) call.
 * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
 */
var InternalDispatchedActionResults = /** @class */ (function (_super) {
    __extends(InternalDispatchedActionResults, _super);
    function InternalDispatchedActionResults() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InternalDispatchedActionResults.decorators = [
        { type: Injectable }
    ];
    return InternalDispatchedActionResults;
}(Subject));
var InternalDispatcher = /** @class */ (function () {
    function InternalDispatcher(_errorHandler, _actions, _actionResults, _pluginManager, _stateStream, _ngZone) {
        this._errorHandler = _errorHandler;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._pluginManager = _pluginManager;
        this._stateStream = _stateStream;
        this._ngZone = _ngZone;
    }
    /**
     * Dispatches event(s).
     */
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    InternalDispatcher.prototype.dispatch = /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var result = this._ngZone.runOutsideAngular(function () {
            if (Array.isArray(event)) {
                return forkJoin(event.map(function (a) { return _this.dispatchSingle(a); }));
            }
            else {
                return _this.dispatchSingle(event);
            }
        });
        result.subscribe({
            error: function (error) { return _this._ngZone.run(function () { return _this._errorHandler.handleError(error); }); }
        });
        return result.pipe(enterZone(this._ngZone));
    };
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    InternalDispatcher.prototype.dispatchSingle = /**
     * @private
     * @param {?} action
     * @return {?}
     */
    function (action) {
        var _this = this;
        /** @type {?} */
        var prevState = this._stateStream.getValue();
        /** @type {?} */
        var plugins = this._pluginManager.plugins;
        return ((/** @type {?} */ (compose(__spread(plugins, [
            function (nextState, nextAction) {
                if (nextState !== prevState) {
                    _this._stateStream.next(nextState);
                }
                /** @type {?} */
                var actionResult$ = _this.getActionResultStream(nextAction);
                actionResult$.subscribe(function (ctx) { return _this._actions.next(ctx); });
                _this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                return _this.createDispatchObservable(actionResult$);
            }
        ]))(prevState, action)))).pipe(shareReplay());
    };
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    InternalDispatcher.prototype.getActionResultStream = /**
     * @private
     * @param {?} action
     * @return {?}
     */
    function (action) {
        return this._actionResults.pipe(filter(function (ctx) { return ctx.action === action && ctx.status !== "DISPATCHED" /* Dispatched */; }), take(1), shareReplay());
    };
    /**
     * @private
     * @param {?} actionResult$
     * @return {?}
     */
    InternalDispatcher.prototype.createDispatchObservable = /**
     * @private
     * @param {?} actionResult$
     * @return {?}
     */
    function (actionResult$) {
        var _this = this;
        return actionResult$
            .pipe(exhaustMap(function (ctx) {
            switch (ctx.status) {
                case "SUCCESSFUL" /* Successful */:
                    return of(_this._stateStream.getValue());
                case "ERRORED" /* Errored */:
                    return throwError(ctx.error);
                default:
                    return empty();
            }
        }))
            .pipe(shareReplay());
    };
    InternalDispatcher.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    InternalDispatcher.ctorParameters = function () { return [
        { type: ErrorHandler },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: PluginManager },
        { type: StateStream },
        { type: NgZone }
    ]; };
    return InternalDispatcher;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Object freeze code
 * https://github.com/jsdf/deep-freeze
 * @type {?}
 */
var deepFreeze = function (o) {
    Object.freeze(o);
    /** @type {?} */
    var oIsFunction = typeof o === 'function';
    /** @type {?} */
    var hasOwnProp = Object.prototype.hasOwnProperty;
    Object.getOwnPropertyNames(o).forEach(function (prop) {
        if (hasOwnProp.call(o, prop) &&
            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
            o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    });
    return o;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
var InternalStateOperations = /** @class */ (function () {
    function InternalStateOperations(_stateStream, _dispatcher, _config, _testBed) {
        this._stateStream = _stateStream;
        this._dispatcher = _dispatcher;
        this._config = _config;
        this._testBed = _testBed;
        this.verifyDevMode();
    }
    /**
     * Returns the root state operators.
     */
    /**
     * Returns the root state operators.
     * @return {?}
     */
    InternalStateOperations.prototype.getRootStateOperations = /**
     * Returns the root state operators.
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var rootStateOperations = {
            getState: function () { return _this._stateStream.getValue(); },
            setState: function (newState) { return _this._stateStream.next(newState); },
            dispatch: function (actions) { return _this._dispatcher.dispatch(actions); }
        };
        if (this._config.developmentMode) {
            return this.ensureStateAndActionsAreImmutable(rootStateOperations);
        }
        return rootStateOperations;
    };
    /**
     * @private
     * @return {?}
     */
    InternalStateOperations.prototype.verifyDevMode = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isTestMode = this._testBed !== null;
        if (isTestMode)
            return;
        /** @type {?} */
        var isNgxsDevMode = this._config.developmentMode;
        /** @type {?} */
        var isNgDevMode = isDevMode();
        /** @type {?} */
        var incorrectProduction = !isNgDevMode && isNgxsDevMode;
        /** @type {?} */
        var incorrectDevelopment = isNgDevMode && !isNgxsDevMode;
        /** @type {?} */
        var example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
        if (incorrectProduction) {
            console.warn('Angular is running in production mode but NGXS is still running in the development mode!\n', 'Please set developmentMode to false on the NgxsModule options when in production mode.\n', example);
        }
        else if (incorrectDevelopment) {
            console.warn('RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n', example);
        }
    };
    /**
     * @private
     * @param {?} root
     * @return {?}
     */
    InternalStateOperations.prototype.ensureStateAndActionsAreImmutable = /**
     * @private
     * @param {?} root
     * @return {?}
     */
    function (root) {
        return {
            getState: function () { return root.getState(); },
            setState: function (value) {
                /** @type {?} */
                var frozenValue = deepFreeze(value);
                return root.setState(frozenValue);
            },
            dispatch: function (actions) {
                return root.dispatch(actions);
            }
        };
    };
    InternalStateOperations.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    InternalStateOperations.ctorParameters = function () { return [
        { type: StateStream },
        { type: InternalDispatcher },
        { type: NgxsConfig },
        { type: TestBed, decorators: [{ type: Optional }] }
    ]; };
    return InternalStateOperations;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
var StateContextFactory = /** @class */ (function () {
    function StateContextFactory(_internalStateOperations) {
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Create the state context
     */
    /**
     * Create the state context
     * @param {?} metadata
     * @return {?}
     */
    StateContextFactory.prototype.createStateContext = /**
     * Create the state context
     * @param {?} metadata
     * @return {?}
     */
    function (metadata) {
        /** @type {?} */
        var root = this._internalStateOperations.getRootStateOperations();
        return {
            getState: /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var state = root.getState();
                return getValue(state, metadata.depth);
            },
            patchState: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                /** @type {?} */
                var isArray = Array.isArray(val);
                /** @type {?} */
                var isPrimitive = typeof val !== 'object';
                if (isArray) {
                    throw new Error('Patching arrays is not supported.');
                }
                else if (isPrimitive) {
                    throw new Error('Patching primitives is not supported.');
                }
                /** @type {?} */
                var state = root.getState();
                /** @type {?} */
                var local = getValue(state, metadata.depth);
                /** @type {?} */
                var clone = __assign({}, local);
                for (var k in val) {
                    clone[k] = val[k];
                }
                /** @type {?} */
                var newState = setValue(state, metadata.depth, clone);
                root.setState(newState);
                return newState;
            },
            setState: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                /** @type {?} */
                var state = root.getState();
                state = setValue(state, metadata.depth, val);
                root.setState(state);
                return state;
            },
            dispatch: /**
             * @param {?} actions
             * @return {?}
             */
            function (actions) {
                return root.dispatch(actions);
            }
        };
    };
    StateContextFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateContextFactory.ctorParameters = function () { return [
        { type: InternalStateOperations }
    ]; };
    return StateContextFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State factory class
 * @ignore
 */
var StateFactory = /** @class */ (function () {
    function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._states = [];
        this._connected = false;
    }
    Object.defineProperty(StateFactory.prototype, "states", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.states : this._states;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a new state to the global defs.
     */
    /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    StateFactory.prototype.add = /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    function (oneOrManyStateClasses) {
        var e_1, _a, _b;
        /** @type {?} */
        var stateClasses;
        if (!Array.isArray(oneOrManyStateClasses)) {
            stateClasses = [oneOrManyStateClasses];
        }
        else {
            stateClasses = oneOrManyStateClasses;
        }
        /** @type {?} */
        var stateGraph = buildGraph(stateClasses);
        /** @type {?} */
        var sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        var depths = findFullParentPath(stateGraph);
        /** @type {?} */
        var nameGraph = nameToState(stateClasses);
        /** @type {?} */
        var mappedStores = [];
        var _loop_1 = function (name_1) {
            /** @type {?} */
            var stateClass = nameGraph[name_1];
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            /** @type {?} */
            var depth = depths[name_1];
            var actions = stateClass[META_KEY].actions;
            var defaults = stateClass[META_KEY].defaults;
            stateClass[META_KEY].path = depth;
            stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this_1._config);
            // ensure our store hasn't already been added
            // but dont throw since it could be lazy
            // loaded from different paths
            /** @type {?} */
            var has = this_1.states.find(function (s) { return s.name === name_1; });
            if (!has) {
                // create new instance of defaults
                if (Array.isArray(defaults)) {
                    defaults = __spread(defaults);
                }
                else if (isObject(defaults)) {
                    defaults = __assign({}, defaults);
                }
                else if (defaults === undefined) {
                    defaults = {};
                }
                /** @type {?} */
                var instance = this_1._injector.get(stateClass);
                mappedStores.push({
                    actions: actions,
                    instance: instance,
                    defaults: defaults,
                    name: name_1,
                    depth: depth
                });
            }
        };
        var this_1 = this;
        try {
            for (var sortedStates_1 = __values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                var name_1 = sortedStates_1_1.value;
                _loop_1(name_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        (_b = this.states).push.apply(_b, __spread(mappedStores));
        return mappedStores;
    };
    /**
     * Add a set of states to the store and return the defaulsts
     */
    /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addAndReturnDefaults = /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        if (stateClasses) {
            /** @type {?} */
            var states = this.add(stateClasses);
            /** @type {?} */
            var defaults = states.reduce(function (result, meta) { return setValue(result, meta.depth, meta.defaults); }, {});
            return { defaults: defaults, states: states };
        }
    };
    /**
     * Bind the actions to the handlers
     */
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    StateFactory.prototype.connectActionHandlers = /**
     * Bind the actions to the handlers
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._connected)
            return;
        this._actions
            .pipe(filter(function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; }), mergeMap(function (_a) {
            var action = _a.action;
            return _this.invokeActions(_this._actions, action).pipe(map(function () { return (/** @type {?} */ ({ action: action, status: "SUCCESSFUL" /* Successful */ })); }), defaultIfEmpty((/** @type {?} */ ({ action: action, status: "CANCELED" /* Canceled */ }))), catchError(function (error) { return of((/** @type {?} */ ({ action: action, status: "ERRORED" /* Errored */, error: error }))); }));
        }))
            .subscribe(function (ctx) { return _this._actionResults.next(ctx); });
        this._connected = true;
    };
    /**
     * Invoke the init function on the states.
     */
    /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    StateFactory.prototype.invokeInit = /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    function (stateMetadatas) {
        var e_2, _a;
        try {
            for (var stateMetadatas_1 = __values(stateMetadatas), stateMetadatas_1_1 = stateMetadatas_1.next(); !stateMetadatas_1_1.done; stateMetadatas_1_1 = stateMetadatas_1.next()) {
                var metadata = stateMetadatas_1_1.value;
                /** @type {?} */
                var instance = metadata.instance;
                if (instance.ngxsOnInit) {
                    /** @type {?} */
                    var stateContext = this.createStateContext(metadata);
                    instance.ngxsOnInit(stateContext);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (stateMetadatas_1_1 && !stateMetadatas_1_1.done && (_a = stateMetadatas_1.return)) _a.call(stateMetadatas_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Invoke actions on the states.
     */
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    StateFactory.prototype.invokeActions = /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    function (actions$, action) {
        var e_3, _a, e_4, _b;
        /** @type {?} */
        var results = [];
        try {
            for (var _c = __values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                var metadata = _d.value;
                /** @type {?} */
                var type = getActionTypeFromInstance(action);
                /** @type {?} */
                var actionMetas = metadata.actions[type];
                if (actionMetas) {
                    try {
                        for (var actionMetas_1 = __values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                            var actionMeta = actionMetas_1_1.value;
                            /** @type {?} */
                            var stateContext = this.createStateContext(metadata);
                            try {
                                /** @type {?} */
                                var result = metadata.instance[actionMeta.fn](stateContext, action);
                                if (result instanceof Promise) {
                                    result = from(result);
                                }
                                if (result instanceof Observable) {
                                    result = result.pipe(actionMeta.options.cancelUncompleted
                                        ? takeUntil(actions$.pipe(ofActionDispatched(action)))
                                        : map(function (r) { return r; })); // map acts like a noop
                                }
                                else {
                                    result = of({}).pipe(shareReplay());
                                }
                                results.push(result);
                            }
                            catch (e) {
                                results.push(throwError(e));
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return)) _b.call(actionMetas_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    };
    /**
     * Create the state context
     */
    /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    StateFactory.prototype.createStateContext = /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    function (metadata) {
        return this._stateContextFactory.createStateContext(metadata);
    };
    StateFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateFactory.ctorParameters = function () { return [
        { type: Injector },
        { type: NgxsConfig },
        { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: StateContextFactory }
    ]; };
    return StateFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function defaultEqualityCheck(a, b) {
    return a === b;
}
/**
 * @param {?} equalityCheck
 * @param {?} prev
 * @param {?} next
 * @return {?}
 */
function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
        return false;
    }
    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
    /** @type {?} */
    var length = prev.length;
    for (var i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Memoize a function on its last inputs only.
 * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
 *
 * @ignore
 * @template R, T
 * @param {?} func
 * @param {?=} equalityCheck
 * @return {?}
 */
function memoize(func, equalityCheck) {
    if (equalityCheck === void 0) { equalityCheck = defaultEqualityCheck; }
    /** @type {?} */
    var lastArgs = null;
    /** @type {?} */
    var lastResult = null;
    // we reference arguments instead of spreading them for performance reasons
    /**
     * @return {?}
     */
    function memoized() {
        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
            // apply arguments instead of spreading for performance.
            lastResult = func.apply(null, arguments);
        }
        lastArgs = arguments;
        return lastResult;
    }
    ((/** @type {?} */ (memoized))).reset = function () {
        // The hidden (for now) ability to reset the memoization
        lastArgs = null;
        lastResult = null;
    };
    return (/** @type {?} */ (memoized));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Function for creating a selector
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    var wrappedFn = function wrappedSelectorFn() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        /** @type {?} */
        var returnValue = originalFn.apply(void 0, __spread(args));
        if (returnValue instanceof Function) {
            /** @type {?} */
            var innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    /** @type {?} */
    var memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    var containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    var fn = function (state) {
        /** @type {?} */
        var results = [];
        /** @type {?} */
        var selectorsToApply = [];
        if (containerClass) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            var metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push.apply(selectorsToApply, __spread(selectors));
        }
        // Determine arguments from the app state using the selectors
        if (selectorsToApply) {
            results.push.apply(results, __spread(selectorsToApply.map(function (a) { return getSelectorFn(a)(state); })));
        }
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn.apply(void 0, __spread(results));
        }
        catch (ex) {
            if (ex instanceof TypeError) {
                return undefined;
            }
            throw ex;
        }
    };
    /** @type {?} */
    var selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    selectorMetaData.selectFromAppState = fn;
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
    }
    return memoizedFn;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
function getSelectorFn(selector) {
    /** @type {?} */
    var metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Store = /** @class */ (function () {
    function Store(_ngZone, _stateStream, _internalStateOperations) {
        this._ngZone = _ngZone;
        this._stateStream = _stateStream;
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Dispatches event(s).
     */
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    Store.prototype.dispatch = /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return this._internalStateOperations.getRootStateOperations().dispatch(event);
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.select = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        /** @type {?} */
        var selectorFn = getSelectorFn(selector);
        return this._stateStream.pipe(map(selectorFn), catchError(function (err) {
            // if error is TypeError we swallow it to prevent usual errors with property access
            if (err instanceof TypeError) {
                return of(undefined);
            }
            // rethrow other errors
            throw err;
        }), distinctUntilChanged(), enterZone(this._ngZone));
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.selectOnce = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        return this.select(selector).pipe(take(1));
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.selectSnapshot = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        /** @type {?} */
        var selectorFn = getSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    };
    /**
     * Allow the user to subscribe to the root of the state
     */
    /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    Store.prototype.subscribe = /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    function (fn) {
        return this._stateStream.pipe(enterZone(this._ngZone)).subscribe(fn);
    };
    /**
     * Return the raw value of the state.
     */
    /**
     * Return the raw value of the state.
     * @return {?}
     */
    Store.prototype.snapshot = /**
     * Return the raw value of the state.
     * @return {?}
     */
    function () {
        return this._internalStateOperations.getRootStateOperations().getState();
    };
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    Store.prototype.reset = /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    function (state) {
        return this._internalStateOperations.getRootStateOperations().setState(state);
    };
    Store.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Store.ctorParameters = function () { return [
        { type: NgZone },
        { type: StateStream },
        { type: InternalStateOperations }
    ]; };
    return Store;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Allows the select decorator to get access to the DI store.
 * @ignore
 */
var SelectFactory = /** @class */ (function () {
    function SelectFactory(store, config) {
        SelectFactory.store = store;
        SelectFactory.config = config;
    }
    SelectFactory.store = undefined;
    SelectFactory.config = undefined;
    SelectFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    SelectFactory.ctorParameters = function () { return [
        { type: Store },
        { type: NgxsConfig }
    ]; };
    return SelectFactory;
}());
/**
 * Decorator for selecting a slice of state from the store.
 * @param {?=} selectorOrFeature
 * @param {...?} paths
 * @return {?}
 */
function Select(selectorOrFeature) {
    var paths = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        paths[_i - 1] = arguments[_i];
    }
    return function (target, name) {
        /** @type {?} */
        var selectorFnName = '__' + name + '__selector';
        if (!selectorOrFeature) {
            // if foo$ => make it just foo
            selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;
        }
        /** @type {?} */
        var createSelect = function (fn) {
            /** @type {?} */
            var store = SelectFactory.store;
            if (!store) {
                throw new Error('SelectFactory not connected to store!');
            }
            return store.select(fn);
        };
        /** @type {?} */
        var createSelector = function () {
            /** @type {?} */
            var config = SelectFactory.config;
            if (typeof selectorOrFeature === 'string') {
                /** @type {?} */
                var propsArray = paths.length ? __spread([selectorOrFeature], paths) : selectorOrFeature.split('.');
                return propGetter(propsArray, config);
            }
            else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                return propGetter(selectorOrFeature[META_KEY].path.split('.'), config);
            }
            else {
                return selectorOrFeature;
            }
        };
        if (target[selectorFnName]) {
            throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
        }
        if (delete target[name]) {
            Object.defineProperty(target, selectorFnName, {
                writable: true,
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(target, name, {
                get: function () {
                    return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));
                },
                enumerable: true,
                configurable: true
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Init action
 */
var  /**
 * Init action
 */
InitState = /** @class */ (function () {
    function InitState() {
    }
    Object.defineProperty(InitState, "type", {
        get: /**
         * @return {?}
         */
        function () {
            // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
            return '@@INIT';
        },
        enumerable: true,
        configurable: true
    });
    return InitState;
}());
/**
 * Update action
 */
var  /**
 * Update action
 */
UpdateState = /** @class */ (function () {
    function UpdateState() {
    }
    Object.defineProperty(UpdateState, "type", {
        get: /**
         * @return {?}
         */
        function () {
            // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
            return '@@UPDATE_STATE';
        },
        enumerable: true,
        configurable: true
    });
    return UpdateState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Root module
 * @ignore
 */
var NgxsRootModule = /** @class */ (function () {
    function NgxsRootModule(factory, internalStateOperations, store, select, states) {
        // add stores to the state graph and return their defaults
        /** @type {?} */
        var results = factory.addAndReturnDefaults(states);
        /** @type {?} */
        var stateOperations = internalStateOperations.getRootStateOperations();
        if (results) {
            // get our current stream
            /** @type {?} */
            var cur = stateOperations.getState();
            // set the state to the current + new
            stateOperations.setState(__assign({}, cur, results.defaults));
        }
        // connect our actions stream
        factory.connectActionHandlers();
        // dispatch the init action and invoke init function after
        stateOperations.dispatch(new InitState()).subscribe(function () {
            if (results) {
                factory.invokeInit(results.states);
            }
        });
    }
    NgxsRootModule.decorators = [
        { type: NgModule }
    ];
    /** @nocollapse */
    NgxsRootModule.ctorParameters = function () { return [
        { type: StateFactory },
        { type: InternalStateOperations },
        { type: Store },
        { type: SelectFactory },
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [ROOT_STATE_TOKEN,] }] }
    ]; };
    return NgxsRootModule;
}());
/**
 * Feature module
 * @ignore
 */
var NgxsFeatureModule = /** @class */ (function () {
    function NgxsFeatureModule(store, internalStateOperations, factory, states) {
        // Since FEATURE_STATE_TOKEN is a multi token, we need to
        // flatten it [[Feature1State, Feature2State], [Feature3State]]
        /** @type {?} */
        var flattenedStates = ((/** @type {?} */ ([]))).concat.apply(((/** @type {?} */ ([]))), __spread(states));
        // add stores to the state graph and return their defaults
        /** @type {?} */
        var results = factory.addAndReturnDefaults(flattenedStates);
        /** @type {?} */
        var stateOperations = internalStateOperations.getRootStateOperations();
        if (results) {
            // get our current stream
            /** @type {?} */
            var cur = stateOperations.getState();
            // set the state to the current + new
            stateOperations.setState(__assign({}, cur, results.defaults));
        }
        stateOperations.dispatch(new UpdateState()).subscribe(function () {
            if (results) {
                factory.invokeInit(results.states);
            }
        });
    }
    NgxsFeatureModule.decorators = [
        { type: NgModule, args: [{},] }
    ];
    /** @nocollapse */
    NgxsFeatureModule.ctorParameters = function () { return [
        { type: Store },
        { type: InternalStateOperations },
        { type: StateFactory },
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [FEATURE_STATE_TOKEN,] }] }
    ]; };
    return NgxsFeatureModule;
}());
/**
 * @param {?} options
 * @return {?}
 */
function ngxsConfigFactory(options) {
    /** @type {?} */
    var config = Object.assign(new NgxsConfig(), options);
    return config;
}
/** @type {?} */
var ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');
/**
 * Ngxs Module
 */
var NgxsModule = /** @class */ (function () {
    function NgxsModule() {
    }
    /**
     * Root module factory
     */
    /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    NgxsModule.forRoot = /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    function (states, options) {
        if (states === void 0) { states = []; }
        if (options === void 0) { options = {}; }
        return {
            ngModule: NgxsRootModule,
            providers: __spread([
                StateFactory,
                StateContextFactory,
                Actions,
                InternalActions,
                InternalDispatcher,
                InternalDispatchedActionResults,
                InternalStateOperations,
                Store,
                StateStream,
                SelectFactory,
                PluginManager
            ], states, [
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                },
                {
                    provide: ROOT_OPTIONS,
                    useValue: options
                },
                {
                    provide: NgxsConfig,
                    useFactory: ngxsConfigFactory,
                    deps: [ROOT_OPTIONS]
                }
            ])
        };
    };
    /**
     * Feature module factory
     */
    /**
     * Feature module factory
     * @param {?} states
     * @return {?}
     */
    NgxsModule.forFeature = /**
     * Feature module factory
     * @param {?} states
     * @return {?}
     */
    function (states) {
        return {
            ngModule: NgxsFeatureModule,
            providers: __spread([
                StateFactory,
                PluginManager
            ], states, [
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: states
                }
            ])
        };
    };
    NgxsModule.decorators = [
        { type: NgModule, args: [{},] }
    ];
    return NgxsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates a method with a action information.
 * @param {?} actions
 * @param {?=} options
 * @return {?}
 */
function Action(actions, options) {
    return function (target, name, descriptor) {
        var e_1, _a;
        /** @type {?} */
        var meta = ensureStoreMetadata(target.constructor);
        if (!Array.isArray(actions)) {
            actions = [actions];
        }
        try {
            for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                var action = actions_1_1.value;
                /** @type {?} */
                var type = action.type;
                if (!action.type) {
                    throw new Error("Action " + action.name + " is missing a static \"type\" property");
                }
                if (!meta.actions[type]) {
                    meta.actions[type] = [];
                }
                meta.actions[type].push({
                    fn: name,
                    options: options || {},
                    type: type
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');
/**
 * Error message
 * @ignore
 * @type {?}
 */
var stateNameErrorMessage = function (name) {
    return name + " is not a valid state name. It needs to be a valid object property name.";
};
/**
 * Decorates a class with ngxs state information.
 * @template T
 * @param {?} options
 * @return {?}
 */
function State(options) {
    return function (target) {
        /** @type {?} */
        var meta = ensureStoreMetadata(target);
        // Handle inheritance
        if (Object.getPrototypeOf(target).hasOwnProperty(META_KEY)) {
            /** @type {?} */
            var parentMeta = Object.getPrototypeOf(target)[META_KEY];
            meta.actions = __assign({}, meta.actions, parentMeta.actions);
        }
        meta.children = options.children;
        meta.defaults = options.defaults;
        meta.name = options.name;
        if (!options.name) {
            throw new Error("States must register a 'name' property");
        }
        if (!stateNameRegex.test(options.name)) {
            throw new Error(stateNameErrorMessage(options.name));
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorator for memoizing a state selector.
 * @param {?=} selectors
 * @return {?}
 */
function Selector(selectors) {
    return function (target, key, descriptor) {
        if (descriptor.value !== null) {
            /** @type {?} */
            var originalFn = descriptor.value;
            /** @type {?} */
            var memoizedFn_1 = createSelector(selectors, originalFn, { containerClass: target, selectorName: key });
            return {
                configurable: true,
                get: /**
                 * @return {?}
                 */
                function () {
                    return memoizedFn_1;
                }
            };
        }
        else {
            throw new Error('Selectors only work on methods');
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxsModule, Action, Store, State, Select, Actions, getSelectorMetadata, getStoreMetadata, ensureStoreMetadata, ensureSelectorMetadata, ofAction, ofActionDispatched, ofActionSuccessful, ofActionCanceled, ofActionErrored, Selector, getActionTypeFromInstance, actionMatcher, createSelector, NGXS_PLUGINS, StateStream, setValue, getValue, InitState, UpdateState, InternalActions as g, OrderedSubject as f, SelectFactory as e, InternalDispatchedActionResults as n, InternalDispatcher as o, StateContextFactory as p, StateFactory as m, InternalStateOperations as q, NgxsFeatureModule as b, NgxsRootModule as a, ROOT_OPTIONS as d, ngxsConfigFactory as c, PluginManager as r, FEATURE_STATE_TOKEN as i, META_KEY as j, NgxsConfig as l, ROOT_STATE_TOKEN as h, SELECTOR_META_KEY as k };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4cy1zdG9yZS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5neHMvc3RvcmUvc3JjL3N5bWJvbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9pbnRlcm5hbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy91dGlscy91dGlscy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL29wZXJhdG9ycy9vZi1hY3Rpb24udHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9vcGVyYXRvcnMvem9uZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2FjdGlvbnMtc3RyZWFtLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvY29tcG9zZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLXN0cmVhbS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3BsdWdpbi1tYW5hZ2VyLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvaW50ZXJuYWwvZGlzcGF0Y2hlci50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL2ZyZWV6ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnkudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvbWVtb2l6ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL3NlbGVjdG9yLXV0aWxzLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvc3RvcmUudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9kZWNvcmF0b3JzL3NlbGVjdC50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2FjdGlvbnMvYWN0aW9ucy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL21vZHVsZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvYWN0aW9uLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvZGVjb3JhdG9ycy9zdGF0ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvc2VsZWN0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignUk9PVF9TVEFURV9UT0tFTicpO1xyXG5leHBvcnQgY29uc3QgRkVBVFVSRV9TVEFURV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdGRUFUVVJFX1NUQVRFX1RPS0VOJyk7XHJcbmV4cG9ydCBjb25zdCBNRVRBX0tFWSA9ICdOR1hTX01FVEEnO1xyXG5leHBvcnQgY29uc3QgU0VMRUNUT1JfTUVUQV9LRVkgPSAnTkdYU19TRUxFQ1RPUl9NRVRBJztcclxuXHJcbmV4cG9ydCBjb25zdCBOR1hTX1BMVUdJTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05HWFNfUExVR0lOUycpO1xyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luQ29uc3RydWN0b3IgPSBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBOZ3hzUGx1Z2luO1xyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luRm4gPSAoc3RhdGU6IGFueSwgbXV0YXRpb246IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5GbikgPT4gYW55O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBOR1hTIGNvbmZpZyBzZXR0aW5ncy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ3hzQ29uZmlnIHtcclxuICAvKipcclxuICAgKiBSdW4gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gVGhpcyB3aWxsIGFkZCBhZGRpdGlvbmFsIGRlYnVnZ2luZyBmZWF0dXJlczpcclxuICAgKiAtIE9iamVjdC5mcmVlemUgb24gdGhlIHN0YXRlIGFuZCBhY3Rpb25zIHRvIGd1YXJhbnRlZSBpbW11dGFiaWxpdHlcclxuICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICovXHJcbiAgZGV2ZWxvcG1lbnRNb2RlOiBib29sZWFuO1xyXG4gIGNvbXBhdGliaWxpdHk6IHtcclxuICAgIC8qKlxyXG4gICAgICogU3VwcG9ydCBhIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cclxuICAgICAqIFRoaXMgd2lsbCBjaXJ1bXZlbnQgc29tZSBvcHRpbWlzYXRpb25zIHRoYXQgdmlvbGF0ZSBhIHN0cmljdCBDU1AgdGhyb3VnaCB0aGUgdXNlIG9mIGBuZXcgRnVuY3Rpb24oLi4uKWAuXHJcbiAgICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICAgKi9cclxuICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogYm9vbGVhbjtcclxuICB9O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY29tcGF0aWJpbGl0eSA9IHtcclxuICAgICAgc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5OiBmYWxzZVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBjb250ZXh0IHByb3ZpZGVkIHRvIHRoZSBhY3Rpb25zIGluIHRoZSBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDb250ZXh0PFQ+IHtcclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICovXHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldFN0YXRlKHZhbDogVCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGNoIHRoZSBleGlzdGluZyBzdGF0ZSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgKi9cclxuICBwYXRjaFN0YXRlKHZhbDogUGFydGlhbDxUPik7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoIGEgbmV3IGFjdGlvbiBhbmQgcmV0dXJuIHRoZSBkaXNwYXRjaGVkIG9ic2VydmFibGUuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTmV4dFBsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnkpID0+IGFueTtcclxuXHJcbi8qKlxyXG4gKiBQbHVnaW4gaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB0aGUgc3RhdGUvYWN0aW9uIGJlZm9yZSBpdHMgc3VibWl0dGVkIHRvIHRoZSBzdGF0ZSBoYW5kbGVycy5cclxuICAgKi9cclxuICBoYW5kbGUoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pOiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBzdG9yZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmVPcHRpb25zPFQ+IHtcclxuICAvKipcclxuICAgKiBOYW1lIG9mIHRoZSBzdGF0ZS4gUmVxdWlyZWQuXHJcbiAgICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgdGhlIHN0YXRlLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgZW1wdHkgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGRlZmF1bHRzPzogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogU3ViIHN0YXRlcyBmb3IgdGhlIGdpdmVuIHN0YXRlLlxyXG4gICAqL1xyXG4gIGNoaWxkcmVuPzogYW55W107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY3Rpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIGEgYWN0aW9uIGRlY29yYXRvci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uT3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogQ2FuY2VsIHRoZSBwcmV2aW91cyB1bmNvbXBsZXRlZCBvYnNlcnZhYmxlKHMpLlxyXG4gICAqL1xyXG4gIGNhbmNlbFVuY29tcGxldGVkPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9uIGluaXQgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNPbkluaXQge1xyXG4gIG5neHNPbkluaXQoY3R4PzogU3RhdGVDb250ZXh0PGFueT4pOiB2b2lkIHwgYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTGlmZUN5Y2xlID0gUGFydGlhbDxOZ3hzT25Jbml0PjtcclxuIiwiaW1wb3J0IHsgTUVUQV9LRVksIEFjdGlvbk9wdGlvbnMsIFNFTEVDVE9SX01FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0S2V5TWFwPFQ+IHtcclxuICBba2V5OiBzdHJpbmddOiBUO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3Mge1xyXG4gIFtNRVRBX0tFWV0/OiBNZXRhRGF0YU1vZGVsO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTdGF0ZUtleUdyYXBoID0gT2JqZWN0S2V5TWFwPHN0cmluZ1tdPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uSGFuZGxlck1ldGFEYXRhIHtcclxuICBmbjogc3RyaW5nO1xyXG4gIG9wdGlvbnM6IEFjdGlvbk9wdGlvbnM7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlT3BlcmF0aW9uczxUPiB7XHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuICBzZXRTdGF0ZSh2YWw6IFQpO1xyXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXRhRGF0YU1vZGVsIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgYWN0aW9uczogT2JqZWN0S2V5TWFwPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIHBhdGg6IHN0cmluZztcclxuICBzZWxlY3RGcm9tQXBwU3RhdGU6IFNlbGVjdEZyb21TdGF0ZTtcclxuICBjaGlsZHJlbjogU3RhdGVDbGFzc1tdO1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNlbGVjdEZyb21TdGF0ZSA9IChzdGF0ZTogYW55KSA9PiBhbnk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGU7XHJcbiAgb3JpZ2luYWxGbjogRnVuY3Rpb247XHJcbiAgY29udGFpbmVyQ2xhc3M6IGFueTtcclxuICBzZWxlY3Rvck5hbWU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXBwZWRTdG9yZSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBpbnN0YW5jZTogYW55O1xyXG4gIGRlcHRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBjbGFzcyBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0KTogTWV0YURhdGFNb2RlbCB7XHJcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoTUVUQV9LRVkpKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IE1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIGFjdGlvbnM6IHt9LFxyXG4gICAgICBkZWZhdWx0czoge30sXHJcbiAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICBpbnN0YW5jZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBNRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuICByZXR1cm4gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgY2xhc3MgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpOiBNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGFuZCByZXR1cm5zIGl0LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQpOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KFNFTEVDVE9SX01FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcclxuICAgICAgY29udGFpbmVyQ2xhc3M6IG51bGwsXHJcbiAgICAgIHNlbGVjdG9yTmFtZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBTRUxFQ1RPUl9NRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W1NFTEVDVE9SX01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhcyBmYXN0IGFzIHRoZSBgZmFzdFByb3BHZXR0ZXJgIGJ1dCBpcyBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgY29tcGxpYW50LlxyXG4gKiBTZWUgcGVyZiBoaXQ6IGh0dHBzOi8vanNwZXJmLmNvbS9mYXN0LXZhbHVlLWdldHRlci1naXZlbi1wYXRoLzFcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGxpYW50UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IGNvcHlPZlBhdGhzID0gWy4uLnBhdGhzXTtcclxuICByZXR1cm4gb2JqID0+IGNvcHlPZlBhdGhzLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW46XHJcbiAqIC0gcGx1Y2sgKE9ic2VydmFibGUgb3BlcmF0b3IpXHJcbiAqIC0gbWVtb2l6ZVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBmYXN0UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aHM7XHJcbiAgbGV0IHNlZyA9ICdzdG9yZS4nICsgc2VnbWVudHNbMF07XHJcbiAgbGV0IGkgPSAwO1xyXG4gIGNvbnN0IGwgPSBzZWdtZW50cy5sZW5ndGg7XHJcblxyXG4gIGxldCBleHByID0gc2VnO1xyXG4gIHdoaWxlICgrK2kgPCBsKSB7XHJcbiAgICBleHByID0gZXhwciArICcgJiYgJyArIChzZWcgPSBzZWcgKyAnLicgKyBzZWdtZW50c1tpXSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignc3RvcmUnLCAncmV0dXJuICcgKyBleHByICsgJzsnKTtcclxuXHJcbiAgcmV0dXJuIDwoeDogYW55KSA9PiBhbnk+Zm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5ICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5LnN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeSkge1xyXG4gICAgcmV0dXJuIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFzdFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0YXRlcywgaXQgd2lsbCByZXR1cm4gYSBvYmplY3QgZ3JhcGguIEV4YW1wbGU6XHJcbiAqICAgIGNvbnN0IHN0YXRlcyA9IFtcclxuICogICAgICBDYXJ0LFxyXG4gKiAgICAgIENhcnRTYXZlZCxcclxuICogICAgICBDYXJ0U2F2ZWRJdGVtc1xyXG4gKiAgICBdXHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiBTdGF0ZUtleUdyYXBoIHtcclxuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc2VzLmZpbmQoZyA9PiBnID09PSBzdGF0ZUNsYXNzKTtcclxuICAgIGlmICghbWV0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vdCBmb3VuZDogJHtzdGF0ZUNsYXNzfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbWV0YVtNRVRBX0tFWV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWV0YVtNRVRBX0tFWV0ubmFtZTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc3RhdGVDbGFzc2VzLnJlZHVjZTxTdGF0ZUtleUdyYXBoPigocmVzdWx0OiBTdGF0ZUtleUdyYXBoLCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBpZiAoIXN0YXRlQ2xhc3NbTUVUQV9LRVldKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGVzIG11c3QgYmUgZGVjb3JhdGVkIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBuYW1lLCBjaGlsZHJlbiB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICByZXN1bHRbbmFtZV0gPSAoY2hpbGRyZW4gfHwgW10pLm1hcChmaW5kTmFtZSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgc3RhdGVzIGFycmF5LCByZXR1cm5zIG9iamVjdCBncmFwaFxyXG4gKiByZXR1cm5pbmcgdGhlIG5hbWUgYW5kIHN0YXRlIG1ldGFkYXRhLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IHsgbWV0YWRhdGEgfVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVUb1N0YXRlKHN0YXRlczogU3RhdGVDbGFzc1tdKTogT2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+IHtcclxuICByZXR1cm4gc3RhdGVzLnJlZHVjZTxPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4+KChyZXN1bHQ6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgaWYgKCFzdGF0ZUNsYXNzW01FVEFfS0VZXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuICAgIHJlc3VsdFttZXRhLm5hbWVdID0gc3RhdGVDbGFzcztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSwge30pO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgcmVsYXRpb25zaGlwIGdyYXBoIHdpbGwgcmV0dXJuIHRoZSBmdWxsIHBhdGhcclxuICogZm9yIHRoZSBjaGlsZCBpdGVtcy4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgciA9IHtcclxuICogICAgY2FydDogJ2NhcnQnLFxyXG4gKiAgICBzYXZlZDogJ2NhcnQuc2F2ZWQnLFxyXG4gKiAgICBpdGVtczogJ2NhcnQuc2F2ZWQuaXRlbXMnXHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZ1bGxQYXJlbnRQYXRoKG9iajogU3RhdGVLZXlHcmFwaCwgbmV3T2JqOiBPYmplY3RLZXlNYXA8c3RyaW5nPiA9IHt9KTogT2JqZWN0S2V5TWFwPHN0cmluZz4ge1xyXG4gIGNvbnN0IHZpc2l0ID0gKGNoaWxkOiBTdGF0ZUtleUdyYXBoLCBrZXlUb0ZpbmQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjaGlsZFtrZXldLmluZGV4T2Yoa2V5VG9GaW5kKSA+PSAwKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQoY2hpbGQsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQob2JqLCBrZXkpO1xyXG4gICAgICBuZXdPYmpba2V5XSA9IHBhcmVudCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdPYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG9iamVjdCBncmFwaCwgaXQgd2lsbCByZXR1cm4gdGhlIGl0ZW1zIHRvcG9sb2dpY2FsbHkgc29ydGVkIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHJlc3VsdHMgPSBbXHJcbiAqICAgICdpdGVtcycsXHJcbiAqICAgICdzYXZlZCcsXHJcbiAqICAgICdjYXJ0J1xyXG4gKiAgXTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvcG9sb2dpY2FsU29ydChncmFwaDogU3RhdGVLZXlHcmFwaCk6IHN0cmluZ1tdIHtcclxuICBjb25zdCBzb3J0ZWQ6IHN0cmluZ1tdID0gW107XHJcbiAgY29uc3QgdmlzaXRlZDogT2JqZWN0S2V5TWFwPGJvb2xlYW4+ID0ge307XHJcblxyXG4gIGNvbnN0IHZpc2l0ID0gKG5hbWU6IHN0cmluZywgYW5jZXN0b3JzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW5jZXN0b3JzKSkge1xyXG4gICAgICBhbmNlc3RvcnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhbmNlc3RvcnMucHVzaChuYW1lKTtcclxuICAgIHZpc2l0ZWRbbmFtZV0gPSB0cnVlO1xyXG5cclxuICAgIGdyYXBoW25hbWVdLmZvckVhY2goKGRlcDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGlmIChhbmNlc3RvcnMuaW5kZXhPZihkZXApID49IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENpcmN1bGFyIGRlcGVuZGVuY3kgJyR7ZGVwfScgaXMgcmVxdWlyZWQgYnkgJyR7bmFtZX0nOiAke2FuY2VzdG9ycy5qb2luKCcgLT4gJyl9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2aXNpdGVkW2RlcF0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZpc2l0KGRlcCwgYW5jZXN0b3JzLnNsaWNlKDApKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChzb3J0ZWQuaW5kZXhPZihuYW1lKSA8IDApIHtcclxuICAgICAgc29ydGVkLnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT2JqZWN0LmtleXMoZ3JhcGgpLmZvckVhY2goayA9PiB2aXNpdChrKSk7XHJcblxyXG4gIHJldHVybiBzb3J0ZWQucmV2ZXJzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgb2JqZWN0IG9yIG5vdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0eXBlIGZyb20gYW4gYWN0aW9uIGluc3RhbmNlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb246IGFueSk6IHN0cmluZyB7XHJcbiAgaWYgKGFjdGlvbi5jb25zdHJ1Y3RvciAmJiBhY3Rpb24uY29uc3RydWN0b3IudHlwZSkge1xyXG4gICAgcmV0dXJuIGFjdGlvbi5jb25zdHJ1Y3Rvci50eXBlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFjdGlvbi50eXBlO1xyXG59XHJcblxyXG4vKipcclxuICogTWF0Y2hlcyBhIGFjdGlvblxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uTWF0Y2hlcihhY3Rpb24xOiBhbnkpIHtcclxuICBjb25zdCB0eXBlMSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uMSk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbihhY3Rpb24yOiBhbnkpIHtcclxuICAgIHJldHVybiB0eXBlMSA9PT0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24yKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICBzZXRWYWx1ZSh7IGZvbzogeyBiYXI6IHsgZWF0OiBmYWxzZSB9IH0gfSxcclxuICogICAgICAnZm9vLmJhci5lYXQnLCB0cnVlKSAvLz0+IHsgZm9vOiB7IGJhcjogeyBlYXQ6IHRydWUgfSB9IH1cclxuICpcclxuICogV2hpbGUgaXQgdHJhdmVyc2VzIGl0IGFsc28gY3JlYXRlcyBuZXcgb2JqZWN0cyBmcm9tIHRvcCBkb3duLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2V0VmFsdWUgPSAob2JqOiBhbnksIHByb3A6IHN0cmluZywgdmFsOiBhbnkpID0+IHtcclxuICBvYmogPSB7IC4uLm9iaiB9O1xyXG5cclxuICBjb25zdCBzcGxpdCA9IHByb3Auc3BsaXQoJy4nKTtcclxuICBjb25zdCBsYXN0SW5kZXggPSBzcGxpdC5sZW5ndGggLSAxO1xyXG5cclxuICBzcGxpdC5yZWR1Y2UoKGFjYywgcGFydCwgaW5kZXgpID0+IHtcclxuICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XHJcbiAgICAgIGFjY1twYXJ0XSA9IHZhbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFjY1twYXJ0XSA9IEFycmF5LmlzQXJyYXkoYWNjW3BhcnRdKSA/IFsuLi5hY2NbcGFydF1dIDogeyAuLi5hY2NbcGFydF0gfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWNjICYmIGFjY1twYXJ0XTtcclxuICB9LCBvYmopO1xyXG5cclxuICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0VmFsdWUgPSAob2JqOiBhbnksIHByb3A6IHN0cmluZykgPT5cclxuICBwcm9wLnNwbGl0KCcuJykucmVkdWNlKChhY2M6IGFueSwgcGFydDogc3RyaW5nKSA9PiBhY2MgJiYgYWNjW3BhcnRdLCBvYmopO1xyXG4iLCJpbXBvcnQgeyBPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBBY3Rpb25Db250ZXh0LCBBY3Rpb25TdGF0dXMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb248VD4oYWxsb3dlZFR5cGUpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD47XHJcbmV4cG9ydCBmdW5jdGlvbiBvZkFjdGlvbjxUPiguLi5hbGxvd2VkVHlwZXMpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD47XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gZGlzcGF0Y2hlZCBhcyB3ZWxsIGFzIGFjdGlvbnMgdGhhdCBoYXZlIGNvbXBsZXRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgYmVlbiBkaXNwYXRjaGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25EaXNwYXRjaGVkKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMsIEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIE9OTFkgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uU3VjY2Vzc2Z1bCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSeEpTIG9wZXJhdG9yIGZvciBzZWxlY3Rpbmcgb3V0IHNwZWNpZmljIGFjdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBPTkxZIGdyYWIgYWN0aW9ucyB0aGF0IGhhdmUganVzdCBiZWVuIGNhbmNlbGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25DYW5jZWxlZCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgdGhyb3duIGFuIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25FcnJvcmVkKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMsIEFjdGlvblN0YXR1cy5FcnJvcmVkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXM6IGFueVtdLCBzdGF0dXM/OiBBY3Rpb25TdGF0dXMpIHtcclxuICBjb25zdCBhbGxvd2VkTWFwID0gY3JlYXRlQWxsb3dlZE1hcChhbGxvd2VkVHlwZXMpO1xyXG4gIHJldHVybiBmdW5jdGlvbihvOiBPYnNlcnZhYmxlPGFueT4pIHtcclxuICAgIHJldHVybiBvLnBpcGUoXHJcbiAgICAgIGZpbHRlclN0YXR1cyhhbGxvd2VkTWFwLCBzdGF0dXMpLFxyXG4gICAgICBtYXBBY3Rpb24oKVxyXG4gICAgKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJTdGF0dXMoYWxsb3dlZFR5cGVzOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSwgc3RhdHVzPzogQWN0aW9uU3RhdHVzKSB7XHJcbiAgcmV0dXJuIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCBhY3Rpb25UeXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShjdHguYWN0aW9uKTtcclxuICAgIGNvbnN0IHR5cGUgPSBhbGxvd2VkVHlwZXNbYWN0aW9uVHlwZV07XHJcbiAgICByZXR1cm4gc3RhdHVzID8gdHlwZSAmJiBjdHguc3RhdHVzID09PSBzdGF0dXMgOiB0eXBlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBBY3Rpb24oKSB7XHJcbiAgcmV0dXJuIG1hcCgoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguYWN0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQWxsb3dlZE1hcCh0eXBlczogYW55W10pOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSB7XHJcbiAgcmV0dXJuIHR5cGVzLnJlZHVjZSgoYWNjOiBhbnksIGtsYXNzOiBhbnkpID0+IHtcclxuICAgIGFjY1tnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGtsYXNzKV0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGFjYztcclxuICB9LCB7fSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogT3BlcmF0b3IgdG8gcnVuIHRoZSBgc3Vic2NyaWJlYCBpbiBhIEFuZ3VsYXIgem9uZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnRlclpvbmU8VD4oem9uZTogTmdab25lKSB7XHJcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc2luazogT2JzZXJ2ZXI8VD4pID0+IHtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoe1xyXG4gICAgICAgIG5leHQoeCkge1xyXG4gICAgICAgICAgem9uZS5ydW4oKCkgPT4gc2luay5uZXh0KHgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yKGUpIHtcclxuICAgICAgICAgIHpvbmUucnVuKCgpID0+IHNpbmsuZXJyb3IoZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGxldGUoKSB7XHJcbiAgICAgICAgICB6b25lLnJ1bigoKSA9PiBzaW5rLmNvbXBsZXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBlbnRlclpvbmUgfSBmcm9tICcuL29wZXJhdG9ycy96b25lJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0dXMgb2YgYSBkaXNwYXRjaGVkIGFjdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudW0gQWN0aW9uU3RhdHVzIHtcclxuICBEaXNwYXRjaGVkID0gJ0RJU1BBVENIRUQnLFxyXG4gIFN1Y2Nlc3NmdWwgPSAnU1VDQ0VTU0ZVTCcsXHJcbiAgQ2FuY2VsZWQgPSAnQ0FOQ0VMRUQnLFxyXG4gIEVycm9yZWQgPSAnRVJST1JFRCdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25Db250ZXh0IHtcclxuICBzdGF0dXM6IEFjdGlvblN0YXR1cztcclxuICBhY3Rpb246IGFueTtcclxuICBlcnJvcj86IEVycm9yO1xyXG59XHJcblxyXG4vKipcclxuICogQ3VzdG9tIFN1YmplY3QgdGhhdCBlbnN1cmVzIHRoYXQgc3Vic2NyaWJlcnMgYXJlIG5vdGlmaWVkIG9mIHZhbHVlcyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFycml2ZWQuXHJcbiAqIEEgc3RhbmRhcmQgU3ViamVjdCBkb2VzIG5vdCBoYXZlIHRoaXMgZ3VhcmFudGVlLlxyXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBjb2RlOlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqICAgY29uc3Qgc3ViamVjdCA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcclxuICAgICBzdWJqZWN0LnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICBpZiAodmFsdWUgPT09ICdzdGFydCcpIHN1YmplY3QubmV4dCgnZW5kJyk7XHJcbiAgICAgfSk7XHJcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4geyB9KTtcclxuICAgICBzdWJqZWN0Lm5leHQoJ3N0YXJ0Jyk7XHJcbiAqIGBgYFxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIHN0YW5kYXJkIGBTdWJqZWN0PFQ+YCB0aGUgc2Vjb25kIHN1YnNjcmliZXIgd291bGQgcmVjaWV2ZSBgZW5kYCBhbmQgdGhlbiBgc3RhcnRgLlxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIGBPcmRlcmVkU3ViamVjdDxUPmAgdGhlIHNlY29uZCBzdWJzY3JpYmVyIHdvdWxkIHJlY2lldmUgYHN0YXJ0YCBhbmQgdGhlbiBgZW5kYC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBPcmRlcmVkU3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xyXG4gIHByaXZhdGUgX2l0ZW1RdWV1ZTogVFtdID0gW107XHJcbiAgcHJpdmF0ZSBfYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcblxyXG4gIG5leHQodmFsdWU/OiBUKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fYnVzeVB1c2hpbmdOZXh0KSB7XHJcbiAgICAgIHRoaXMuX2l0ZW1RdWV1ZS51bnNoaWZ0KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYnVzeVB1c2hpbmdOZXh0ID0gdHJ1ZTtcclxuICAgIHN1cGVyLm5leHQodmFsdWUpO1xyXG4gICAgd2hpbGUgKHRoaXMuX2l0ZW1RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHRoaXMuX2l0ZW1RdWV1ZS5wb3AoKTtcclxuICAgICAgc3VwZXIubmV4dChuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEludGVybmFsQWN0aW9ucyBleHRlbmRzIE9yZGVyZWRTdWJqZWN0PEFjdGlvbkNvbnRleHQ+IHt9XHJcblxyXG4vKipcclxuICogQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cclxuICpcclxuICogWW91IGNhbiBsaXN0ZW4gdG8gdGhpcyBpbiBzZXJ2aWNlcyB0byByZWFjdCB3aXRob3V0IHN0b3Jlcy5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEFjdGlvbnMgZXh0ZW5kcyBPYnNlcnZhYmxlPGFueT4ge1xyXG4gIGNvbnN0cnVjdG9yKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIG5nWm9uZTogTmdab25lKSB7XHJcbiAgICBzdXBlcihvYnNlcnZlciA9PiB7XHJcbiAgICAgIGFjdGlvbnMkXHJcbiAgICAgICAgLnBpcGUoZW50ZXJab25lKG5nWm9uZSkpXHJcbiAgICAgICAgLnN1YnNjcmliZShyZXMgPT4gb2JzZXJ2ZXIubmV4dChyZXMpLCBlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSwgKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvbXBvc2VzIGEgYXJyYXkgb2YgZnVuY3Rpb25zIGZyb20gbGVmdCB0byByaWdodC4gRXhhbXBsZTpcclxuICpcclxuICogICAgICBjb21wb3NlKFtmbiwgZmluYWxdKShzdGF0ZSwgYWN0aW9uKTtcclxuICpcclxuICogdGhlbiB0aGUgZnVuY3MgaGF2ZSBhIHNpZ25hdHVyZSBsaWtlOlxyXG4gKlxyXG4gKiAgICAgIGZ1bmN0aW9uIGZuIChzdGF0ZSwgYWN0aW9uLCBuZXh0KSB7XHJcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKCdoZXJlJywgc3RhdGUsIGFjdGlvbiwgbmV4dCk7XHJcbiAqICAgICAgICAgIHJldHVybiBuZXh0KHN0YXRlLCBhY3Rpb24pO1xyXG4gKiAgICAgIH1cclxuICpcclxuICogICAgICBmdW5jdGlvbiBmaW5hbCAoc3RhdGUsIGFjdGlvbikge1xyXG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnaGVyZScsIHN0YXRlLCBhY3Rpb24pO1xyXG4gKiAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAqICAgICAgfVxyXG4gKlxyXG4gKiB0aGUgbGFzdCBmdW5jdGlvbiBzaG91bGQgbm90IGNhbGwgYG5leHRgLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29tcG9zZSA9IGZ1bmNzID0+ICguLi5hcmdzKSA9PiB7XHJcbiAgY29uc3QgY3VyciA9IGZ1bmNzLnNoaWZ0KCk7XHJcbiAgcmV0dXJuIGN1cnIoLi4uYXJncywgKC4uLm5leHRBcmdzKSA9PiBjb21wb3NlKGZ1bmNzKSguLi5uZXh0QXJncykpO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuLyoqXHJcbiAqIEJlaGF2aW9yU3ViamVjdCBvZiB0aGUgZW50aXJlIHN0YXRlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZVN0cmVhbSBleHRlbmRzIEJlaGF2aW9yU3ViamVjdDxhbnk+IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKHt9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmd4c1BsdWdpbkZuLCBOR1hTX1BMVUdJTlMsIE5neHNQbHVnaW4gfSBmcm9tICcuL3N5bWJvbHMnO1xyXG5cclxuLyoqXHJcbiAqIFBsdWdpbiBtYW5hZ2VyIGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFBsdWdpbk1hbmFnZXIge1xyXG4gIHBsdWdpbnM6IE5neHNQbHVnaW5GbltdID0gW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRNYW5hZ2VyOiBQbHVnaW5NYW5hZ2VyLFxyXG4gICAgQEluamVjdChOR1hTX1BMVUdJTlMpXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgcHJpdmF0ZSBfcGx1Z2luczogTmd4c1BsdWdpbltdXHJcbiAgKSB7XHJcbiAgICB0aGlzLnJlZ2lzdGVyKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlZ2lzdGVyKCkge1xyXG4gICAgaWYgKCF0aGlzLl9wbHVnaW5zKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zLm1hcChwbHVnaW4gPT4ge1xyXG4gICAgICBpZiAocGx1Z2luLmhhbmRsZSkge1xyXG4gICAgICAgIHJldHVybiBwbHVnaW4uaGFuZGxlLmJpbmQocGx1Z2luKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGx1Z2luO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fcGFyZW50TWFuYWdlcikge1xyXG4gICAgICB0aGlzLl9wYXJlbnRNYW5hZ2VyLnBsdWdpbnMucHVzaCguLi50aGlzLnBsdWdpbnMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBFcnJvckhhbmRsZXIsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgZm9ya0pvaW4sIGVtcHR5LCBTdWJqZWN0LCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHNoYXJlUmVwbGF5LCBmaWx0ZXIsIGV4aGF1c3RNYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBjb21wb3NlIH0gZnJvbSAnLi4vdXRpbHMvY29tcG9zZSc7XHJcbmltcG9ydCB7IEludGVybmFsQWN0aW9ucywgQWN0aW9uU3RhdHVzLCBBY3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBTdGF0ZVN0cmVhbSB9IGZyb20gJy4vc3RhdGUtc3RyZWFtJztcclxuaW1wb3J0IHsgUGx1Z2luTWFuYWdlciB9IGZyb20gJy4uL3BsdWdpbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgZW50ZXJab25lIH0gZnJvbSAnLi4vb3BlcmF0b3JzL3pvbmUnO1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIEFjdGlvbiByZXN1bHQgc3RyZWFtIHRoYXQgaXMgZW1pdHRlZCB3aGVuIGFuIGFjdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAqIFRoaXMgaXMgdXNlZCBhcyBhIG1ldGhvZCBvZiByZXR1cm5pbmcgdGhlIGFjdGlvbiByZXN1bHQgdG8gdGhlIGRpc3BhdGNoZXJcclxuICogZm9yIHRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGJ5IHRoZSBkaXNwYXRjaCguLi4pIGNhbGwuXHJcbiAqIFRoZSBkaXNwYXRjaGVyIHRoZW4gYXN5bmNocm9ub3VzbHkgcHVzaGVzIHRoZSByZXN1bHQgZnJvbSB0aGlzIHN0cmVhbSBvbnRvIHRoZSBtYWluIGFjdGlvbiBzdHJlYW0gYXMgYSByZXN1bHQuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIGV4dGVuZHMgU3ViamVjdDxBY3Rpb25Db250ZXh0PiB7fVxyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxEaXNwYXRjaGVyIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2Vycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgIHByaXZhdGUgX3BsdWdpbk1hbmFnZXI6IFBsdWdpbk1hbmFnZXIsXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZVxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyBldmVudChzKS5cclxuICAgKi9cclxuICBkaXNwYXRjaChldmVudDogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oZXZlbnQubWFwKGEgPT4gdGhpcy5kaXNwYXRjaFNpbmdsZShhKSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoU2luZ2xlKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmVzdWx0LnN1YnNjcmliZSh7XHJcbiAgICAgIGVycm9yOiBlcnJvciA9PiB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuX2Vycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvcikpXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0LnBpcGUoZW50ZXJab25lKHRoaXMuX25nWm9uZSkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkaXNwYXRjaFNpbmdsZShhY3Rpb246IGFueSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbk1hbmFnZXIucGx1Z2lucztcclxuXHJcbiAgICByZXR1cm4gKGNvbXBvc2UoW1xyXG4gICAgICAuLi5wbHVnaW5zLFxyXG4gICAgICAobmV4dFN0YXRlLCBuZXh0QWN0aW9uKSA9PiB7XHJcbiAgICAgICAgaWYgKG5leHRTdGF0ZSAhPT0gcHJldlN0YXRlKSB7XHJcbiAgICAgICAgICB0aGlzLl9zdGF0ZVN0cmVhbS5uZXh0KG5leHRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjdGlvblJlc3VsdCQgPSB0aGlzLmdldEFjdGlvblJlc3VsdFN0cmVhbShuZXh0QWN0aW9uKTtcclxuICAgICAgICBhY3Rpb25SZXN1bHQkLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9ucy5uZXh0KGN0eCkpO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMubmV4dCh7IGFjdGlvbjogbmV4dEFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEaXNwYXRjaE9ic2VydmFibGUoYWN0aW9uUmVzdWx0JCk7XHJcbiAgICAgIH1cclxuICAgIF0pKHByZXZTdGF0ZSwgYWN0aW9uKSBhcyBPYnNlcnZhYmxlPGFueT4pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEFjdGlvblJlc3VsdFN0cmVhbShhY3Rpb246IGFueSk6IE9ic2VydmFibGU8QWN0aW9uQ29udGV4dD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGlvblJlc3VsdHMucGlwZShcclxuICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5hY3Rpb24gPT09IGFjdGlvbiAmJiBjdHguc3RhdHVzICE9PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgIHRha2UoMSksXHJcbiAgICAgIHNoYXJlUmVwbGF5KClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZURpc3BhdGNoT2JzZXJ2YWJsZShhY3Rpb25SZXN1bHQkOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiBhY3Rpb25SZXN1bHQkXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGV4aGF1c3RNYXAoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4ge1xyXG4gICAgICAgICAgc3dpdGNoIChjdHguc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWw6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG9mKHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICBjYXNlIEFjdGlvblN0YXR1cy5FcnJvcmVkOlxyXG4gICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGN0eC5lcnJvcik7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKVxyXG4gICAgICAucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIE9iamVjdCBmcmVlemUgY29kZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNkZi9kZWVwLWZyZWV6ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRlZXBGcmVlemUgPSBvID0+IHtcclxuICBPYmplY3QuZnJlZXplKG8pO1xyXG5cclxuICBjb25zdCBvSXNGdW5jdGlvbiA9IHR5cGVvZiBvID09PSAnZnVuY3Rpb24nO1xyXG4gIGNvbnN0IGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuICAgIGlmIChcclxuICAgICAgaGFzT3duUHJvcC5jYWxsKG8sIHByb3ApICYmXHJcbiAgICAgIChvSXNGdW5jdGlvbiA/IHByb3AgIT09ICdjYWxsZXInICYmIHByb3AgIT09ICdjYWxsZWUnICYmIHByb3AgIT09ICdhcmd1bWVudHMnIDogdHJ1ZSkgJiZcclxuICAgICAgb1twcm9wXSAhPT0gbnVsbCAmJlxyXG4gICAgICAodHlwZW9mIG9bcHJvcF0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvW3Byb3BdID09PSAnZnVuY3Rpb24nKSAmJlxyXG4gICAgICAhT2JqZWN0LmlzRnJvemVuKG9bcHJvcF0pXHJcbiAgICApIHtcclxuICAgICAgZGVlcEZyZWV6ZShvW3Byb3BdKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG87XHJcbn07XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIGlzRGV2TW9kZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVGVzdEJlZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvdGVzdGluZyc7XHJcblxyXG5pbXBvcnQgeyBTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgZGVlcEZyZWV6ZSB9IGZyb20gJy4uL3V0aWxzL2ZyZWV6ZSc7XHJcblxyXG4vKipcclxuICogU3RhdGUgQ29udGV4dCBmYWN0b3J5IGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEludGVybmFsU3RhdGVPcGVyYXRpb25zIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX3N0YXRlU3RyZWFtOiBTdGF0ZVN0cmVhbSxcclxuICAgIHByaXZhdGUgX2Rpc3BhdGNoZXI6IEludGVybmFsRGlzcGF0Y2hlcixcclxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcclxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3Rlc3RCZWQ6IFRlc3RCZWRcclxuICApIHtcclxuICAgIHRoaXMudmVyaWZ5RGV2TW9kZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcm9vdCBzdGF0ZSBvcGVyYXRvcnMuXHJcbiAgICovXHJcbiAgZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpOiBTdGF0ZU9wZXJhdGlvbnM8YW55PiB7XHJcbiAgICBjb25zdCByb290U3RhdGVPcGVyYXRpb25zID0ge1xyXG4gICAgICBnZXRTdGF0ZTogKCkgPT4gdGhpcy5fc3RhdGVTdHJlYW0uZ2V0VmFsdWUoKSxcclxuICAgICAgc2V0U3RhdGU6IG5ld1N0YXRlID0+IHRoaXMuX3N0YXRlU3RyZWFtLm5leHQobmV3U3RhdGUpLFxyXG4gICAgICBkaXNwYXRjaDogYWN0aW9ucyA9PiB0aGlzLl9kaXNwYXRjaGVyLmRpc3BhdGNoKGFjdGlvbnMpXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLl9jb25maWcuZGV2ZWxvcG1lbnRNb2RlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVuc3VyZVN0YXRlQW5kQWN0aW9uc0FyZUltbXV0YWJsZShyb290U3RhdGVPcGVyYXRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm9vdFN0YXRlT3BlcmF0aW9ucztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdmVyaWZ5RGV2TW9kZSgpIHtcclxuICAgIGNvbnN0IGlzVGVzdE1vZGUgPSB0aGlzLl90ZXN0QmVkICE9PSBudWxsO1xyXG4gICAgaWYgKGlzVGVzdE1vZGUpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBpc05neHNEZXZNb2RlID0gdGhpcy5fY29uZmlnLmRldmVsb3BtZW50TW9kZTtcclxuICAgIGNvbnN0IGlzTmdEZXZNb2RlID0gaXNEZXZNb2RlKCk7XHJcbiAgICBjb25zdCBpbmNvcnJlY3RQcm9kdWN0aW9uID0gIWlzTmdEZXZNb2RlICYmIGlzTmd4c0Rldk1vZGU7XHJcbiAgICBjb25zdCBpbmNvcnJlY3REZXZlbG9wbWVudCA9IGlzTmdEZXZNb2RlICYmICFpc05neHNEZXZNb2RlO1xyXG4gICAgY29uc3QgZXhhbXBsZSA9ICdOZ3hzTW9kdWxlLmZvclJvb3Qoc3RhdGVzLCB7IGRldmVsb3BtZW50TW9kZTogIWVudmlyb25tZW50LnByb2R1Y3Rpb24gfSknO1xyXG5cclxuICAgIGlmIChpbmNvcnJlY3RQcm9kdWN0aW9uKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnQW5ndWxhciBpcyBydW5uaW5nIGluIHByb2R1Y3Rpb24gbW9kZSBidXQgTkdYUyBpcyBzdGlsbCBydW5uaW5nIGluIHRoZSBkZXZlbG9wbWVudCBtb2RlIVxcbicsXHJcbiAgICAgICAgJ1BsZWFzZSBzZXQgZGV2ZWxvcG1lbnRNb2RlIHRvIGZhbHNlIG9uIHRoZSBOZ3hzTW9kdWxlIG9wdGlvbnMgd2hlbiBpbiBwcm9kdWN0aW9uIG1vZGUuXFxuJyxcclxuICAgICAgICBleGFtcGxlXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2UgaWYgKGluY29ycmVjdERldmVsb3BtZW50KSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnUkVDT01NRU5EQVRJT046IFNldCBkZXZlbG9wbWVudE1vZGUgdG8gdHJ1ZSBvbiB0aGUgTmd4c01vZHVsZSB3aGVuIEFuZ3VsYXIgaXMgcnVubmluZyBpbiBkZXZlbG9wbWVudCBtb2RlLlxcbicsXHJcbiAgICAgICAgZXhhbXBsZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBlbnN1cmVTdGF0ZUFuZEFjdGlvbnNBcmVJbW11dGFibGUocm9vdDogU3RhdGVPcGVyYXRpb25zPGFueT4pOiBTdGF0ZU9wZXJhdGlvbnM8YW55PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnZXRTdGF0ZTogKCkgPT4gcm9vdC5nZXRTdGF0ZSgpLFxyXG4gICAgICBzZXRTdGF0ZTogdmFsdWUgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyb3plblZhbHVlID0gZGVlcEZyZWV6ZSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJvb3Quc2V0U3RhdGUoZnJvemVuVmFsdWUpO1xyXG4gICAgICB9LFxyXG4gICAgICBkaXNwYXRjaDogYWN0aW9ucyA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHJvb3QuZGlzcGF0Y2goYWN0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHsgU3RhdGVDb250ZXh0IH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IE1hcHBlZFN0b3JlIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgc2V0VmFsdWUsIGdldFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMnO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIENvbnRleHQgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZUNvbnRleHRGYWN0b3J5IHtcclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pbnRlcm5hbFN0YXRlT3BlcmF0aW9uczogSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgc3RhdGUgY29udGV4dFxyXG4gICAqL1xyXG4gIGNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YTogTWFwcGVkU3RvcmUpOiBTdGF0ZUNvbnRleHQ8YW55PiB7XHJcbiAgICBjb25zdCByb290ID0gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0U3RhdGUoKTogYW55IHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcclxuICAgICAgICByZXR1cm4gZ2V0VmFsdWUoc3RhdGUsIG1ldGFkYXRhLmRlcHRoKTtcclxuICAgICAgfSxcclxuICAgICAgcGF0Y2hTdGF0ZSh2YWw6IGFueSk6IGFueSB7XHJcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsKTtcclxuICAgICAgICBjb25zdCBpc1ByaW1pdGl2ZSA9IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnO1xyXG5cclxuICAgICAgICBpZiAoaXNBcnJheSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRjaGluZyBhcnJheXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGNoaW5nIHByaW1pdGl2ZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gcm9vdC5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsID0gZ2V0VmFsdWUoc3RhdGUsIG1ldGFkYXRhLmRlcHRoKTtcclxuICAgICAgICBjb25zdCBjbG9uZSA9IHsgLi4ubG9jYWwgfTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHZhbCkge1xyXG4gICAgICAgICAgY2xvbmVba10gPSB2YWxba107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHNldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCwgY2xvbmUpO1xyXG4gICAgICAgIHJvb3Quc2V0U3RhdGUobmV3U3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0U3RhdGUodmFsOiBhbnkpOiBhbnkge1xyXG4gICAgICAgIGxldCBzdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcclxuICAgICAgICBzdGF0ZSA9IHNldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCwgdmFsKTtcclxuICAgICAgICByb290LnNldFN0YXRlKHN0YXRlKTtcclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgIH0sXHJcbiAgICAgIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgICAgICByZXR1cm4gcm9vdC5kaXNwYXRjaChhY3Rpb25zKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0b3IsIEluamVjdGFibGUsIFNraXBTZWxmLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgZm9ya0pvaW4sIGZyb20sIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgc2hhcmVSZXBsYXksIHRha2VVbnRpbCwgbWFwLCBjYXRjaEVycm9yLCBmaWx0ZXIsIG1lcmdlTWFwLCBkZWZhdWx0SWZFbXB0eSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzTGlmZUN5Y2xlLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7XHJcbiAgdG9wb2xvZ2ljYWxTb3J0LFxyXG4gIGJ1aWxkR3JhcGgsXHJcbiAgZmluZEZ1bGxQYXJlbnRQYXRoLFxyXG4gIG5hbWVUb1N0YXRlLFxyXG4gIHByb3BHZXR0ZXIsXHJcbiAgaXNPYmplY3QsXHJcbiAgU3RhdGVDbGFzcyxcclxuICBNYXBwZWRTdG9yZVxyXG59IGZyb20gJy4vaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZSwgc2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbEFjdGlvbnMsIEFjdGlvblN0YXR1cywgQWN0aW9uQ29udGV4dCB9IGZyb20gJy4uL2FjdGlvbnMtc3RyZWFtJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyB9IGZyb20gJy4uL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtY29udGV4dC1mYWN0b3J5JztcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBmYWN0b3J5IGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFN0YXRlRmFjdG9yeSB7XHJcbiAgZ2V0IHN0YXRlcygpOiBNYXBwZWRTdG9yZVtdIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXMgOiB0aGlzLl9zdGF0ZXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zdGF0ZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcclxuICBwcml2YXRlIF9jb25uZWN0ZWQgPSBmYWxzZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXHJcbiAgICBwcml2YXRlIF9jb25maWc6IE5neHNDb25maWcsXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgQFNraXBTZWxmKClcclxuICAgIHByaXZhdGUgX3BhcmVudEZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcclxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcclxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXHJcbiAgICBwcml2YXRlIF9zdGF0ZUNvbnRleHRGYWN0b3J5OiBTdGF0ZUNvbnRleHRGYWN0b3J5XHJcbiAgKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBuZXcgc3RhdGUgdG8gdGhlIGdsb2JhbCBkZWZzLlxyXG4gICAqL1xyXG4gIGFkZChvbmVPck1hbnlTdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3MgfCBTdGF0ZUNsYXNzW10pOiBNYXBwZWRTdG9yZVtdIHtcclxuICAgIGxldCBzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NbXTtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShvbmVPck1hbnlTdGF0ZUNsYXNzZXMpKSB7XHJcbiAgICAgIHN0YXRlQ2xhc3NlcyA9IFtvbmVPck1hbnlTdGF0ZUNsYXNzZXNdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhdGVDbGFzc2VzID0gb25lT3JNYW55U3RhdGVDbGFzc2VzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXRlR3JhcGggPSBidWlsZEdyYXBoKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBjb25zdCBzb3J0ZWRTdGF0ZXMgPSB0b3BvbG9naWNhbFNvcnQoc3RhdGVHcmFwaCk7XHJcbiAgICBjb25zdCBkZXB0aHMgPSBmaW5kRnVsbFBhcmVudFBhdGgoc3RhdGVHcmFwaCk7XHJcbiAgICBjb25zdCBuYW1lR3JhcGggPSBuYW1lVG9TdGF0ZShzdGF0ZUNsYXNzZXMpO1xyXG4gICAgY29uc3QgbWFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZFN0YXRlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZUNsYXNzID0gbmFtZUdyYXBoW25hbWVdO1xyXG5cclxuICAgICAgaWYgKCFzdGF0ZUNsYXNzW01FVEFfS0VZXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGVzIG11c3QgYmUgZGVjb3JhdGVkIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRlcHRoID0gZGVwdGhzW25hbWVdO1xyXG4gICAgICBjb25zdCB7IGFjdGlvbnMgfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldO1xyXG4gICAgICBsZXQgeyBkZWZhdWx0cyB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcblxyXG4gICAgICBzdGF0ZUNsYXNzW01FVEFfS0VZXS5wYXRoID0gZGVwdGg7XHJcbiAgICAgIHN0YXRlQ2xhc3NbTUVUQV9LRVldLnNlbGVjdEZyb21BcHBTdGF0ZSA9IHByb3BHZXR0ZXIoZGVwdGguc3BsaXQoJy4nKSwgdGhpcy5fY29uZmlnKTtcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxyXG4gICAgICAvLyBidXQgZG9udCB0aHJvdyBzaW5jZSBpdCBjb3VsZCBiZSBsYXp5XHJcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xyXG4gICAgICBjb25zdCBoYXMgPSB0aGlzLnN0YXRlcy5maW5kKHMgPT4gcy5uYW1lID09PSBuYW1lKTtcclxuICAgICAgaWYgKCFoYXMpIHtcclxuICAgICAgICAvLyBjcmVhdGUgbmV3IGluc3RhbmNlIG9mIGRlZmF1bHRzXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XHJcbiAgICAgICAgICBkZWZhdWx0cyA9IFsuLi5kZWZhdWx0c107XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZhdWx0cykpIHtcclxuICAgICAgICAgIGRlZmF1bHRzID0geyAuLi5kZWZhdWx0cyB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgZGVmYXVsdHMgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpO1xyXG5cclxuICAgICAgICBtYXBwZWRTdG9yZXMucHVzaCh7XHJcbiAgICAgICAgICBhY3Rpb25zLFxyXG4gICAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgICBkZWZhdWx0cyxcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBkZXB0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGF0ZXMucHVzaCguLi5tYXBwZWRTdG9yZXMpO1xyXG5cclxuICAgIHJldHVybiBtYXBwZWRTdG9yZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBzZXQgb2Ygc3RhdGVzIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIHRoZSBkZWZhdWxzdHNcclxuICAgKi9cclxuICBhZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZUNsYXNzZXM6IGFueVtdKTogeyBkZWZhdWx0czogYW55OyBzdGF0ZXM6IE1hcHBlZFN0b3JlW10gfSB7XHJcbiAgICBpZiAoc3RhdGVDbGFzc2VzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlcyA9IHRoaXMuYWRkKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3RhdGVzLnJlZHVjZShcclxuICAgICAgICAocmVzdWx0OiBhbnksIG1ldGE6IE1hcHBlZFN0b3JlKSA9PiBzZXRWYWx1ZShyZXN1bHQsIG1ldGEuZGVwdGgsIG1ldGEuZGVmYXVsdHMpLFxyXG4gICAgICAgIHt9XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiB7IGRlZmF1bHRzLCBzdGF0ZXMgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgdGhlIGFjdGlvbnMgdG8gdGhlIGhhbmRsZXJzXHJcbiAgICovXHJcbiAgY29ubmVjdEFjdGlvbkhhbmRsZXJzKCkge1xyXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkgcmV0dXJuO1xyXG4gICAgdGhpcy5fYWN0aW9uc1xyXG4gICAgICAucGlwZShcclxuICAgICAgICBmaWx0ZXIoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4gY3R4LnN0YXR1cyA9PT0gQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQpLFxyXG4gICAgICAgIG1lcmdlTWFwKCh7IGFjdGlvbiB9KSA9PlxyXG4gICAgICAgICAgdGhpcy5pbnZva2VBY3Rpb25zKHRoaXMuX2FjdGlvbnMsIGFjdGlvbikucGlwZShcclxuICAgICAgICAgICAgbWFwKCgpID0+IDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsIH0pLFxyXG4gICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSg8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQgfSksXHJcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyb3IgPT4gb2YoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkVycm9yZWQsIGVycm9yIH0pKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgICAuc3Vic2NyaWJlKGN0eCA9PiB0aGlzLl9hY3Rpb25SZXN1bHRzLm5leHQoY3R4KSk7XHJcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlIHRoZSBpbml0IGZ1bmN0aW9uIG9uIHRoZSBzdGF0ZXMuXHJcbiAgICovXHJcbiAgaW52b2tlSW5pdChzdGF0ZU1ldGFkYXRhczogTWFwcGVkU3RvcmVbXSkge1xyXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiBzdGF0ZU1ldGFkYXRhcykge1xyXG4gICAgICBjb25zdCBpbnN0YW5jZTogTmd4c0xpZmVDeWNsZSA9IG1ldGFkYXRhLmluc3RhbmNlO1xyXG5cclxuICAgICAgaWYgKGluc3RhbmNlLm5neHNPbkluaXQpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgICAgICAgaW5zdGFuY2Uubmd4c09uSW5pdChzdGF0ZUNvbnRleHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2UgYWN0aW9ucyBvbiB0aGUgc3RhdGVzLlxyXG4gICAqL1xyXG4gIGludm9rZUFjdGlvbnMoYWN0aW9ucyQ6IEludGVybmFsQWN0aW9ucywgYWN0aW9uKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiB0aGlzLnN0YXRlcykge1xyXG4gICAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pO1xyXG4gICAgICBjb25zdCBhY3Rpb25NZXRhcyA9IG1ldGFkYXRhLmFjdGlvbnNbdHlwZV07XHJcblxyXG4gICAgICBpZiAoYWN0aW9uTWV0YXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk1ldGEgb2YgYWN0aW9uTWV0YXMpIHtcclxuICAgICAgICAgIGNvbnN0IHN0YXRlQ29udGV4dCA9IHRoaXMuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YS5pbnN0YW5jZVthY3Rpb25NZXRhLmZuXShzdGF0ZUNvbnRleHQsIGFjdGlvbik7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZyb20ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcclxuICAgICAgICAgICAgICAgIGFjdGlvbk1ldGEub3B0aW9ucy5jYW5jZWxVbmNvbXBsZXRlZFxyXG4gICAgICAgICAgICAgICAgICA/IHRha2VVbnRpbChhY3Rpb25zJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChhY3Rpb24pKSlcclxuICAgICAgICAgICAgICAgICAgOiBtYXAociA9PiByKVxyXG4gICAgICAgICAgICAgICk7IC8vIG1hcCBhY3RzIGxpa2UgYSBub29wXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gb2Yoe30pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhyb3dFcnJvcihlKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xyXG4gICAgICByZXN1bHRzLnB1c2gob2Yoe30pKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9ya0pvaW4ocmVzdWx0cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIHN0YXRlIGNvbnRleHRcclxuICAgKi9cclxuICBwcml2YXRlIGNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YTogTWFwcGVkU3RvcmUpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUNvbnRleHRGYWN0b3J5LmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgfVxyXG59XHJcbiIsImZ1bmN0aW9uIGRlZmF1bHRFcXVhbGl0eUNoZWNrKGE6IGFueSwgYjogYW55KSB7XHJcbiAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKFxyXG4gIGVxdWFsaXR5Q2hlY2s6IChhOiBhbnksIGI6IGFueSkgPT4gYm9vbGVhbixcclxuICBwcmV2OiBJQXJndW1lbnRzIHwgbnVsbCxcclxuICBuZXh0OiBJQXJndW1lbnRzIHwgbnVsbFxyXG4pIHtcclxuICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cclxuICBjb25zdCBsZW5ndGggPSBwcmV2Lmxlbmd0aDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZW1vaXplIGEgZnVuY3Rpb24gb24gaXRzIGxhc3QgaW5wdXRzIG9ubHkuXHJcbiAqIE9yaW5naW5hbGx5IGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3Jlc2VsZWN0L2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZTxSLCBUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSPihmdW5jOiBULCBlcXVhbGl0eUNoZWNrID0gZGVmYXVsdEVxdWFsaXR5Q2hlY2spOiBUIHtcclxuICBsZXQgbGFzdEFyZ3M6IElBcmd1bWVudHMgfCBudWxsID0gbnVsbDtcclxuICBsZXQgbGFzdFJlc3VsdDogYW55ID0gbnVsbDtcclxuICAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcclxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcclxuICAgIGlmICghYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwoZXF1YWxpdHlDaGVjaywgbGFzdEFyZ3MsIGFyZ3VtZW50cykpIHtcclxuICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGZvciBwZXJmb3JtYW5jZS5cclxuICAgICAgbGFzdFJlc3VsdCA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcclxuICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gIH1cclxuICAoPGFueT5tZW1vaXplZCkucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIFRoZSBoaWRkZW4gKGZvciBub3cpIGFiaWxpdHkgdG8gcmVzZXQgdGhlIG1lbW9pemF0aW9uXHJcbiAgICBsYXN0QXJncyA9IG51bGw7XHJcbiAgICBsYXN0UmVzdWx0ID0gbnVsbDtcclxuICB9O1xyXG4gIHJldHVybiBtZW1vaXplZCBhcyBUO1xyXG59XHJcbiIsImltcG9ydCB7IFNlbGVjdEZyb21TdGF0ZSwgZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSwgZ2V0U2VsZWN0b3JNZXRhZGF0YSwgZ2V0U3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlscy9tZW1vaXplJztcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBzZWxlY3RvclxyXG4gKiBAcGFyYW0gc2VsZWN0b3JzIFRoZSBzZWxlY3RvcnMgdG8gdXNlIHRvIGNyZWF0ZSB0aGUgYXJndW1lbnRzIG9mIHRoaXMgZnVuY3Rpb25cclxuICogQHBhcmFtIG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGJlaW5nIG1hZGUgaW50byBhIHNlbGVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoXHJcbiAgc2VsZWN0b3JzOiBhbnlbXSxcclxuICBvcmlnaW5hbEZuOiBhbnksXHJcbiAgY3JlYXRpb25NZXRhZGF0YT86IHsgY29udGFpbmVyQ2xhc3M6IGFueTsgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfVxyXG4pIHtcclxuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkU2VsZWN0b3JGbiguLi5hcmdzKSB7XHJcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9yaWdpbmFsRm4oLi4uYXJncyk7XHJcbiAgICBpZiAocmV0dXJuVmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICBjb25zdCBpbm5lck1lbW9pemVkRm4gPSBtZW1vaXplLmFwcGx5KG51bGwsIFtyZXR1cm5WYWx1ZV0pO1xyXG4gICAgICByZXR1cm4gaW5uZXJNZW1vaXplZEZuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gIH07XHJcbiAgY29uc3QgbWVtb2l6ZWRGbiA9IG1lbW9pemUod3JhcHBlZEZuKTtcclxuICBjb25zdCBjb250YWluZXJDbGFzcyA9IGNyZWF0aW9uTWV0YWRhdGEgJiYgY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuXHJcbiAgY29uc3QgZm4gPSBzdGF0ZSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0b3JzVG9BcHBseSA9IFtdO1xyXG5cclxuICAgIGlmIChjb250YWluZXJDbGFzcykge1xyXG4gICAgICAvLyBJZiB3ZSBhcmUgb24gYSBzdGF0ZSBjbGFzcywgYWRkIGl0IGFzIHRoZSBmaXJzdCBzZWxlY3RvciBwYXJhbWV0ZXJcclxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBnZXRTdG9yZU1ldGFkYXRhKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgaWYgKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlbGVjdG9ycykge1xyXG4gICAgICBzZWxlY3RvcnNUb0FwcGx5LnB1c2goLi4uc2VsZWN0b3JzKTtcclxuICAgIH1cclxuICAgIC8vIERldGVybWluZSBhcmd1bWVudHMgZnJvbSB0aGUgYXBwIHN0YXRlIHVzaW5nIHRoZSBzZWxlY3RvcnNcclxuICAgIGlmIChzZWxlY3RvcnNUb0FwcGx5KSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaCguLi5zZWxlY3RvcnNUb0FwcGx5Lm1hcChhID0+IGdldFNlbGVjdG9yRm4oYSkoc3RhdGUpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlIGxhbWJkYSB0cmllcyB0byBhY2Nlc3MgYSBzb21ldGhpbmcgb24gdGhlXHJcbiAgICAvLyBzdGF0ZSB0aGF0IGRvZXNuJ3QgZXhpc3QsIGl0IHdpbGwgdGhyb3cgYSBUeXBlRXJyb3IuXHJcbiAgICAvLyBzaW5jZSB0aGlzIGlzIHF1aXRlIHVzdWFsIGJlaGF2aW91ciwgd2Ugc2ltcGx5IHJldHVybiB1bmRlZmluZWQgaWYgc28uXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gbWVtb2l6ZWRGbiguLi5yZXN1bHRzKTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXg7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc2VsZWN0b3JNZXRhRGF0YSA9IGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEobWVtb2l6ZWRGbik7XHJcbiAgc2VsZWN0b3JNZXRhRGF0YS5vcmlnaW5hbEZuID0gb3JpZ2luYWxGbjtcclxuICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdEZyb21BcHBTdGF0ZSA9IGZuO1xyXG4gIGlmIChjcmVhdGlvbk1ldGFkYXRhKSB7XHJcbiAgICBzZWxlY3Rvck1ldGFEYXRhLmNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuICAgIHNlbGVjdG9yTWV0YURhdGEuc2VsZWN0b3JOYW1lID0gY3JlYXRpb25NZXRhZGF0YS5zZWxlY3Rvck5hbWU7XHJcbiAgfVxyXG4gIHJldHVybiBtZW1vaXplZEZuO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIGdldCB0aGUgc2VsZWN0ZWQgc2xpY2UgZnJvbSB0aGUgYXBwIHN0YXRlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvckZuKHNlbGVjdG9yOiBhbnkpOiBTZWxlY3RGcm9tU3RhdGUge1xyXG4gIGNvbnN0IG1ldGFkYXRhID0gZ2V0U2VsZWN0b3JNZXRhZGF0YShzZWxlY3RvcikgfHwgZ2V0U3RvcmVNZXRhZGF0YShzZWxlY3Rvcik7XHJcbiAgcmV0dXJuIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5zZWxlY3RGcm9tQXBwU3RhdGUpIHx8IHNlbGVjdG9yO1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBnZXRTZWxlY3RvckZuIH0gZnJvbSAnLi91dGlscy9zZWxlY3Rvci11dGlscyc7XHJcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1vcGVyYXRpb25zJztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IGVudGVyWm9uZSB9IGZyb20gJy4vb3BlcmF0b3JzL3pvbmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RvcmUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9pbnRlcm5hbFN0YXRlT3BlcmF0aW9uczogSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnNcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgZXZlbnQocykuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goZXZlbnQ6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuZGlzcGF0Y2goZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0cyBhIHNsaWNlIG9mIGRhdGEgZnJvbSB0aGUgc3RvcmUuXHJcbiAgICovXHJcbiAgc2VsZWN0PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IE9ic2VydmFibGU8VD47XHJcbiAgc2VsZWN0KHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgc2VsZWN0KHNlbGVjdG9yOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3Qgc2VsZWN0b3JGbiA9IGdldFNlbGVjdG9yRm4oc2VsZWN0b3IpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlU3RyZWFtLnBpcGUoXHJcbiAgICAgIG1hcChzZWxlY3RvckZuKSxcclxuICAgICAgY2F0Y2hFcnJvcihlcnIgPT4ge1xyXG4gICAgICAgIC8vIGlmIGVycm9yIGlzIFR5cGVFcnJvciB3ZSBzd2FsbG93IGl0IHRvIHByZXZlbnQgdXN1YWwgZXJyb3JzIHdpdGggcHJvcGVydHkgYWNjZXNzXHJcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXRocm93IG90aGVyIGVycm9yc1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfSksXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgIGVudGVyWm9uZSh0aGlzLl9uZ1pvbmUpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0IG9uZSBzbGljZSBvZiBkYXRhIGZyb20gdGhlIHN0b3JlLlxyXG4gICAqL1xyXG4gIHNlbGVjdE9uY2U8VD4oc2VsZWN0b3I6IChzdGF0ZTogYW55LCAuLi5zdGF0ZXM6IGFueVtdKSA9PiBUKTogT2JzZXJ2YWJsZTxUPjtcclxuICBzZWxlY3RPbmNlKHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgc2VsZWN0T25jZShzZWxlY3RvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLnNlbGVjdChzZWxlY3RvcikucGlwZSh0YWtlKDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBhIHNuYXBzaG90IGZyb20gdGhlIHN0YXRlLlxyXG4gICAqL1xyXG4gIHNlbGVjdFNuYXBzaG90PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IFQ7XHJcbiAgc2VsZWN0U25hcHNob3Qoc2VsZWN0b3I6IHN0cmluZyB8IGFueSk6IGFueTtcclxuICBzZWxlY3RTbmFwc2hvdChzZWxlY3RvcjogYW55KTogYW55IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSBnZXRTZWxlY3RvckZuKHNlbGVjdG9yKTtcclxuICAgIHJldHVybiBzZWxlY3RvckZuKHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gc3Vic2NyaWJlIHRvIHRoZSByb290IG9mIHRoZSBzdGF0ZVxyXG4gICAqL1xyXG4gIHN1YnNjcmliZShmbj86IGFueSk6IFN1YnNjcmlwdGlvbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVTdHJlYW0ucGlwZShlbnRlclpvbmUodGhpcy5fbmdab25lKSkuc3Vic2NyaWJlKGZuKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICBzbmFwc2hvdCgpOiBhbnkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5nZXRTdGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZS4gVGhpcyBtZXRob2QgaXMgdXNlZnVsXHJcbiAgICogZm9yIHBsdWdpbidzIHdobyBuZWVkIHRvIG1vZGlmeSB0aGUgc3RhdGUgZGlyZWN0bHkgb3IgdW5pdCB0ZXN0aW5nLlxyXG4gICAqL1xyXG4gIHJlc2V0KHN0YXRlOiBhbnkpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuc2V0U3RhdGUoc3RhdGUpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4uL3N0b3JlJztcclxuaW1wb3J0IHsgcHJvcEdldHRlciB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcblxyXG4vKipcclxuICogQWxsb3dzIHRoZSBzZWxlY3QgZGVjb3JhdG9yIHRvIGdldCBhY2Nlc3MgdG8gdGhlIERJIHN0b3JlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RGYWN0b3J5IHtcclxuICBzdGF0aWMgc3RvcmU6IFN0b3JlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gIHN0YXRpYyBjb25maWc6IE5neHNDb25maWcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgY29uc3RydWN0b3Ioc3RvcmU6IFN0b3JlLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICAgIFNlbGVjdEZhY3Rvcnkuc3RvcmUgPSBzdG9yZTtcclxuICAgIFNlbGVjdEZhY3RvcnkuY29uZmlnID0gY29uZmlnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciBmb3Igc2VsZWN0aW5nIGEgc2xpY2Ugb2Ygc3RhdGUgZnJvbSB0aGUgc3RvcmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0KHNlbGVjdG9yT3JGZWF0dXJlPywgLi4ucGF0aHM6IHN0cmluZ1tdKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm5OYW1lID0gJ19fJyArIG5hbWUgKyAnX19zZWxlY3Rvcic7XHJcblxyXG4gICAgaWYgKCFzZWxlY3Rvck9yRmVhdHVyZSkge1xyXG4gICAgICAvLyBpZiBmb28kID0+IG1ha2UgaXQganVzdCBmb29cclxuICAgICAgc2VsZWN0b3JPckZlYXR1cmUgPSBuYW1lLmxhc3RJbmRleE9mKCckJykgPT09IG5hbWUubGVuZ3RoIC0gMSA/IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSkgOiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNyZWF0ZVNlbGVjdCA9IGZuID0+IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBTZWxlY3RGYWN0b3J5LnN0b3JlO1xyXG5cclxuICAgICAgaWYgKCFzdG9yZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0RmFjdG9yeSBub3QgY29ubmVjdGVkIHRvIHN0b3JlIScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RvcmUuc2VsZWN0KGZuKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY3JlYXRlU2VsZWN0b3IgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IFNlbGVjdEZhY3RvcnkuY29uZmlnO1xyXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yT3JGZWF0dXJlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHByb3BzQXJyYXkgPSBwYXRocy5sZW5ndGggPyBbc2VsZWN0b3JPckZlYXR1cmUsIC4uLnBhdGhzXSA6IHNlbGVjdG9yT3JGZWF0dXJlLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wR2V0dGVyKHByb3BzQXJyYXksIGNvbmZpZyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3JPckZlYXR1cmVbTUVUQV9LRVldICYmIHNlbGVjdG9yT3JGZWF0dXJlW01FVEFfS0VZXS5wYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BHZXR0ZXIoc2VsZWN0b3JPckZlYXR1cmVbTUVUQV9LRVldLnBhdGguc3BsaXQoJy4nKSwgY29uZmlnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VsZWN0b3JPckZlYXR1cmU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRhcmdldFtzZWxlY3RvckZuTmFtZV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBAU2VsZWN0IGRlY29yYXRvciBhbmQgYSAnICsgc2VsZWN0b3JGbk5hbWUgKyAnIHByb3BlcnR5LicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkZWxldGUgdGFyZ2V0W25hbWVdKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHNlbGVjdG9yRm5OYW1lLCB7XHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpc1tzZWxlY3RvckZuTmFtZV0gfHwgKHRoaXNbc2VsZWN0b3JGbk5hbWVdID0gY3JlYXRlU2VsZWN0LmFwcGx5KHRoaXMsIFtjcmVhdGVTZWxlY3RvcigpXSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iLCIvKipcclxuICogSW5pdCBhY3Rpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbml0U3RhdGUge1xyXG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuICAgIC8vIE5PVEU6IE5vdCBuZWNlc3NhcnkgdG8gZGVjbGFyZSB0aGUgdHlwZSBpbiB0aGlzIHdheSBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4cy9zdG9yZS9wdWxsLzY0NCNpc3N1ZWNvbW1lbnQtNDM2MDAzMTM4XHJcbiAgICByZXR1cm4gJ0BASU5JVCc7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIGFjdGlvblxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFVwZGF0ZVN0YXRlIHtcclxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcbiAgICAvLyBOT1RFOiBOb3QgbmVjZXNzYXJ5IHRvIGRlY2xhcmUgdGhlIHR5cGUgaW4gdGhpcyB3YXkgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25neHMvc3RvcmUvcHVsbC82NDQjaXNzdWVjb21tZW50LTQzNjAwMzEzOFxyXG4gICAgcmV0dXJuICdAQFVQREFURV9TVEFURSc7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBPcHRpb25hbCwgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgUk9PVF9TVEFURV9UT0tFTiwgRkVBVFVSRV9TVEFURV9UT0tFTiwgTmd4c0NvbmZpZyB9IGZyb20gJy4vc3ltYm9scyc7XHJcbmltcG9ydCB7IFN0YXRlRmFjdG9yeSB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtZmFjdG9yeSc7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcbmltcG9ydCB7IEFjdGlvbnMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZXIsIEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnLi9zdG9yZSc7XHJcbmltcG9ydCB7IFNlbGVjdEZhY3RvcnkgfSBmcm9tICcuL2RlY29yYXRvcnMvc2VsZWN0JztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuL3BsdWdpbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgSW5pdFN0YXRlLCBVcGRhdGVTdGF0ZSB9IGZyb20gJy4vYWN0aW9ucy9hY3Rpb25zJztcclxuXHJcbi8qKlxyXG4gKiBSb290IG1vZHVsZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ATmdNb2R1bGUoKVxyXG5leHBvcnQgY2xhc3MgTmd4c1Jvb3RNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgc2VsZWN0OiBTZWxlY3RGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoUk9PVF9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogYW55W11cclxuICApIHtcclxuICAgIC8vIGFkZCBzdG9yZXMgdG8gdGhlIHN0YXRlIGdyYXBoIGFuZCByZXR1cm4gdGhlaXIgZGVmYXVsdHNcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBmYWN0b3J5LmFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlcyk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGVPcGVyYXRpb25zID0gaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xyXG4gICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgLy8gZ2V0IG91ciBjdXJyZW50IHN0cmVhbVxyXG4gICAgICBjb25zdCBjdXIgPSBzdGF0ZU9wZXJhdGlvbnMuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIC8vIHNldCB0aGUgc3RhdGUgdG8gdGhlIGN1cnJlbnQgKyBuZXdcclxuICAgICAgc3RhdGVPcGVyYXRpb25zLnNldFN0YXRlKHsgLi4uY3VyLCAuLi5yZXN1bHRzLmRlZmF1bHRzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbm5lY3Qgb3VyIGFjdGlvbnMgc3RyZWFtXHJcbiAgICBmYWN0b3J5LmNvbm5lY3RBY3Rpb25IYW5kbGVycygpO1xyXG5cclxuICAgIC8vIGRpc3BhdGNoIHRoZSBpbml0IGFjdGlvbiBhbmQgaW52b2tlIGluaXQgZnVuY3Rpb24gYWZ0ZXJcclxuICAgIHN0YXRlT3BlcmF0aW9ucy5kaXNwYXRjaChuZXcgSW5pdFN0YXRlKCkpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgICAgZmFjdG9yeS5pbnZva2VJbml0KHJlc3VsdHMuc3RhdGVzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmVhdHVyZSBtb2R1bGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQE5nTW9kdWxlKHt9KVxyXG5leHBvcnQgY2xhc3MgTmd4c0ZlYXR1cmVNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoRkVBVFVSRV9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogYW55W11bXVxyXG4gICkge1xyXG4gICAgLy8gU2luY2UgRkVBVFVSRV9TVEFURV9UT0tFTiBpcyBhIG11bHRpIHRva2VuLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmbGF0dGVuIGl0IFtbRmVhdHVyZTFTdGF0ZSwgRmVhdHVyZTJTdGF0ZV0sIFtGZWF0dXJlM1N0YXRlXV1cclxuICAgIGNvbnN0IGZsYXR0ZW5lZFN0YXRlcyA9IChbXSBhcyBhbnlbXSkuY29uY2F0KC4uLnN0YXRlcyk7XHJcblxyXG4gICAgLy8gYWRkIHN0b3JlcyB0byB0aGUgc3RhdGUgZ3JhcGggYW5kIHJldHVybiB0aGVpciBkZWZhdWx0c1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGZhY3RvcnkuYWRkQW5kUmV0dXJuRGVmYXVsdHMoZmxhdHRlbmVkU3RhdGVzKTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZU9wZXJhdGlvbnMgPSBpbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCk7XHJcbiAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAvLyBnZXQgb3VyIGN1cnJlbnQgc3RyZWFtXHJcbiAgICAgIGNvbnN0IGN1ciA9IHN0YXRlT3BlcmF0aW9ucy5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgLy8gc2V0IHRoZSBzdGF0ZSB0byB0aGUgY3VycmVudCArIG5ld1xyXG4gICAgICBzdGF0ZU9wZXJhdGlvbnMuc2V0U3RhdGUoeyAuLi5jdXIsIC4uLnJlc3VsdHMuZGVmYXVsdHMgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGVPcGVyYXRpb25zLmRpc3BhdGNoKG5ldyBVcGRhdGVTdGF0ZSgpKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAgIGZhY3RvcnkuaW52b2tlSW5pdChyZXN1bHRzLnN0YXRlcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTW9kdWxlT3B0aW9ucyA9IFBhcnRpYWw8Tmd4c0NvbmZpZz47XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbmd4c0NvbmZpZ0ZhY3Rvcnkob3B0aW9uczogTW9kdWxlT3B0aW9ucyk6IE5neHNDb25maWcge1xyXG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24obmV3IE5neHNDb25maWcoKSwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIGNvbmZpZztcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxNb2R1bGVPcHRpb25zPignUk9PVF9PUFRJT05TJyk7XHJcblxyXG4vKipcclxuICogTmd4cyBNb2R1bGVcclxuICovXHJcbkBOZ01vZHVsZSh7fSlcclxuZXhwb3J0IGNsYXNzIE5neHNNb2R1bGUge1xyXG4gIC8qKlxyXG4gICAqIFJvb3QgbW9kdWxlIGZhY3RvcnlcclxuICAgKi9cclxuICBzdGF0aWMgZm9yUm9vdChzdGF0ZXM6IGFueVtdID0gW10sIG9wdGlvbnM6IE1vZHVsZU9wdGlvbnMgPSB7fSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5neHNSb290TW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTdGF0ZUZhY3RvcnksXHJcbiAgICAgICAgU3RhdGVDb250ZXh0RmFjdG9yeSxcclxuICAgICAgICBBY3Rpb25zLFxyXG4gICAgICAgIEludGVybmFsQWN0aW9ucyxcclxuICAgICAgICBJbnRlcm5hbERpc3BhdGNoZXIsXHJcbiAgICAgICAgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgICAgICBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgICAgICBTdG9yZSxcclxuICAgICAgICBTdGF0ZVN0cmVhbSxcclxuICAgICAgICBTZWxlY3RGYWN0b3J5LFxyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgLi4uc3RhdGVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IFJPT1RfU1RBVEVfVE9LRU4sXHJcbiAgICAgICAgICB1c2VWYWx1ZTogc3RhdGVzXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwcm92aWRlOiBST09UX09QVElPTlMsXHJcbiAgICAgICAgICB1c2VWYWx1ZTogb3B0aW9uc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogTmd4c0NvbmZpZyxcclxuICAgICAgICAgIHVzZUZhY3Rvcnk6IG5neHNDb25maWdGYWN0b3J5LFxyXG4gICAgICAgICAgZGVwczogW1JPT1RfT1BUSU9OU11cclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGZWF0dXJlIG1vZHVsZSBmYWN0b3J5XHJcbiAgICovXHJcbiAgc3RhdGljIGZvckZlYXR1cmUoc3RhdGVzOiBhbnlbXSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5neHNGZWF0dXJlTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTdGF0ZUZhY3RvcnksXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlcixcclxuICAgICAgICAuLi5zdGF0ZXMsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogRkVBVFVSRV9TVEFURV9UT0tFTixcclxuICAgICAgICAgIG11bHRpOiB0cnVlLFxyXG4gICAgICAgICAgdXNlVmFsdWU6IHN0YXRlc1xyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZW5zdXJlU3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IEFjdGlvbk9wdGlvbnMgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgYSBtZXRob2Qgd2l0aCBhIGFjdGlvbiBpbmZvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBBY3Rpb24oYWN0aW9uczogYW55IHwgYW55W10sIG9wdGlvbnM/OiBBY3Rpb25PcHRpb25zKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcsIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPGFueT4pIHtcclxuICAgIGNvbnN0IG1ldGEgPSBlbnN1cmVTdG9yZU1ldGFkYXRhKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFjdGlvbnMpKSB7XHJcbiAgICAgIGFjdGlvbnMgPSBbYWN0aW9uc107XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xyXG4gICAgICBjb25zdCB0eXBlID0gYWN0aW9uLnR5cGU7XHJcblxyXG4gICAgICBpZiAoIWFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpb24gJHthY3Rpb24ubmFtZX0gaXMgbWlzc2luZyBhIHN0YXRpYyBcInR5cGVcIiBwcm9wZXJ0eWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW1ldGEuYWN0aW9uc1t0eXBlXSkge1xyXG4gICAgICAgIG1ldGEuYWN0aW9uc1t0eXBlXSA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtZXRhLmFjdGlvbnNbdHlwZV0ucHVzaCh7XHJcbiAgICAgICAgZm46IG5hbWUsXHJcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fSxcclxuICAgICAgICB0eXBlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgZW5zdXJlU3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IFN0b3JlT3B0aW9ucywgTUVUQV9LRVkgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbmNvbnN0IHN0YXRlTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXlthLXpBLVowLTlfXSskJyk7XHJcblxyXG4vKipcclxuICogRXJyb3IgbWVzc2FnZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdGVOYW1lRXJyb3JNZXNzYWdlID0gbmFtZSA9PlxyXG4gIGAke25hbWV9IGlzIG5vdCBhIHZhbGlkIHN0YXRlIG5hbWUuIEl0IG5lZWRzIHRvIGJlIGEgdmFsaWQgb2JqZWN0IHByb3BlcnR5IG5hbWUuYDtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgYSBjbGFzcyB3aXRoIG5neHMgc3RhdGUgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3RhdGU8VD4ob3B0aW9uczogU3RvcmVPcHRpb25zPFQ+KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55KSB7XHJcbiAgICBjb25zdCBtZXRhID0gZW5zdXJlU3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG5cclxuICAgIC8vIEhhbmRsZSBpbmhlcml0YW5jZVxyXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpLmhhc093blByb3BlcnR5KE1FVEFfS0VZKSkge1xyXG4gICAgICBjb25zdCBwYXJlbnRNZXRhID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClbTUVUQV9LRVldO1xyXG5cclxuICAgICAgbWV0YS5hY3Rpb25zID0ge1xyXG4gICAgICAgIC4uLm1ldGEuYWN0aW9ucyxcclxuICAgICAgICAuLi5wYXJlbnRNZXRhLmFjdGlvbnNcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBtZXRhLmNoaWxkcmVuID0gb3B0aW9ucy5jaGlsZHJlbjtcclxuICAgIG1ldGEuZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xyXG4gICAgbWV0YS5uYW1lID0gb3B0aW9ucy5uYW1lO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGVzIG11c3QgcmVnaXN0ZXIgYSAnbmFtZScgcHJvcGVydHlgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXN0YXRlTmFtZVJlZ2V4LnRlc3Qob3B0aW9ucy5uYW1lKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RhdGVOYW1lRXJyb3JNZXNzYWdlKG9wdGlvbnMubmFtZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICcuLi91dGlscy9zZWxlY3Rvci11dGlscyc7XHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZvciBtZW1vaXppbmcgYSBzdGF0ZSBzZWxlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3RvcihzZWxlY3RvcnM/OiBhbnlbXSkge1xyXG4gIHJldHVybiAodGFyZ2V0OiBhbnksIGtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpID0+IHtcclxuICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsRm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xyXG5cclxuICAgICAgY29uc3QgbWVtb2l6ZWRGbiA9IGNyZWF0ZVNlbGVjdG9yKFxyXG4gICAgICAgIHNlbGVjdG9ycyxcclxuICAgICAgICBvcmlnaW5hbEZuLFxyXG4gICAgICAgIHsgY29udGFpbmVyQ2xhc3M6IHRhcmdldCwgc2VsZWN0b3JOYW1lOiBrZXkgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgcmV0dXJuIG1lbW9pemVkRm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWxlY3RvcnMgb25seSB3b3JrIG9uIG1ldGhvZHMnKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ0c2xpYl8xLl9fZXh0ZW5kcyIsInRzbGliXzEuX192YWx1ZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUdBLElBQWEsZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQU0sa0JBQWtCLENBQUM7O0FBQzNFLElBQWEsbUJBQW1CLEdBQUcsSUFBSSxjQUFjLENBQU0scUJBQXFCLENBQUM7O0FBQ2pGLElBQWEsUUFBUSxHQUFHLFdBQVc7O0FBQ25DLElBQWEsaUJBQWlCLEdBQUcsb0JBQW9COztBQUVyRCxJQUFhLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBQyxjQUFjLENBQUM7Ozs7QUFPOUQ7Ozs7SUFnQkU7UUFDRSxJQUFJLENBQUMsYUFBYSxHQUFHO1lBQ25CLDJCQUEyQixFQUFFLEtBQUs7U0FDbkMsQ0FBQztLQUNIO0lBQ0gsaUJBQUM7Q0FBQTs7Ozs7Ozs7Ozs7OztBQ3FCRCxTQUFnQixtQkFBbUIsQ0FBQyxNQUFNO0lBQ3hDLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFD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