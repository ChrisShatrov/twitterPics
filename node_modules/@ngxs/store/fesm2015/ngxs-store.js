import { InjectionToken, Injectable, NgZone, Optional, SkipSelf, Inject, ErrorHandler, isDevMode, Injector, NgModule } from '@angular/core';
import { map, filter, shareReplay, exhaustMap, take, takeUntil, catchError, mergeMap, defaultIfEmpty, distinctUntilChanged } from 'rxjs/operators';
import { Observable, Subject, BehaviorSubject, of, forkJoin, empty, throwError, from } from 'rxjs';
import { TestBed } from '@angular/core/testing';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
const FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
const META_KEY = 'NGXS_META';
/** @type {?} */
const SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/** @type {?} */
const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/**
 * The NGXS config settings.
 */
class NgxsConfig {
    constructor() {
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getStoreMetadata(target) {
    return target[META_KEY];
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    const copyOfPaths = [...paths];
    return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    const segments = paths;
    /** @type {?} */
    let seg = 'store.' + segments[0];
    /** @type {?} */
    let i = 0;
    /** @type {?} */
    const l = segments.length;
    /** @type {?} */
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    const fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
function buildGraph(stateClasses) {
    /** @type {?} */
    const findName = (stateClass) => {
        /** @type {?} */
        const meta = stateClasses.find(g => g === stateClass);
        if (!meta) {
            throw new Error(`Child state not found: ${stateClass}`);
        }
        if (!meta[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        return meta[META_KEY].name;
    };
    return stateClasses.reduce((result, stateClass) => {
        if (!stateClass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        const { name, children } = stateClass[META_KEY];
        result[name] = (children || []).map(findName);
        return result;
    }, {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
function nameToState(states) {
    return states.reduce((result, stateClass) => {
        if (!stateClass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        /** @type {?} */
        const meta = stateClass[META_KEY];
        result[meta.name] = stateClass;
        return result;
    }, {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
function findFullParentPath(obj, newObj = {}) {
    /** @type {?} */
    const visit = (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    };
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
function topologicalSort(graph) {
    /** @type {?} */
    const sorted = [];
    /** @type {?} */
    const visited = {};
    /** @type {?} */
    const visit = (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((dep) => {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        });
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    };
    Object.keys(graph).forEach(k => visit(k));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns the type from an action instance.
 * @ignore
 * @param {?} action
 * @return {?}
 */
function getActionTypeFromInstance(action) {
    if (action.constructor && action.constructor.type) {
        return action.constructor.type;
    }
    return action.type;
}
/**
 * Matches a action
 * @ignore
 * @param {?} action1
 * @return {?}
 */
function actionMatcher(action1) {
    /** @type {?} */
    const type1 = getActionTypeFromInstance(action1);
    return function (action2) {
        return type1 === getActionTypeFromInstance(action2);
    };
}
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 *
 * @ignore
 * @type {?}
 */
const setValue = (obj, prop, val) => {
    obj = Object.assign({}, obj);
    /** @type {?} */
    const split = prop.split('.');
    /** @type {?} */
    const lastIndex = split.length - 1;
    split.reduce((acc, part, index) => {
        if (index === lastIndex) {
            acc[part] = val;
        }
        else {
            acc[part] = Array.isArray(acc[part]) ? [...acc[part]] : Object.assign({}, acc[part]);
        }
        return acc && acc[part];
    }, obj);
    return obj;
};
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @type {?}
 */
const getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will grab actions that have just been dispatched as well as actions that have completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofAction(...allowedTypes) {
    return ofActionOperator(allowedTypes);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been dispatched
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionDispatched(...allowedTypes) {
    return ofActionOperator(allowedTypes, "DISPATCHED" /* Dispatched */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been successfully completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionSuccessful(...allowedTypes) {
    return ofActionOperator(allowedTypes, "SUCCESSFUL" /* Successful */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been canceled
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionCanceled(...allowedTypes) {
    return ofActionOperator(allowedTypes, "CANCELED" /* Canceled */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just thrown an error
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionErrored(...allowedTypes) {
    return ofActionOperator(allowedTypes, "ERRORED" /* Errored */);
}
/**
 * @param {?} allowedTypes
 * @param {?=} status
 * @return {?}
 */
function ofActionOperator(allowedTypes, status) {
    /** @type {?} */
    const allowedMap = createAllowedMap(allowedTypes);
    return function (o) {
        return o.pipe(filterStatus(allowedMap, status), mapAction());
    };
}
/**
 * @param {?} allowedTypes
 * @param {?=} status
 * @return {?}
 */
function filterStatus(allowedTypes, status) {
    return filter((ctx) => {
        /** @type {?} */
        const actionType = getActionTypeFromInstance(ctx.action);
        /** @type {?} */
        const type = allowedTypes[actionType];
        return status ? type && ctx.status === status : type;
    });
}
/**
 * @return {?}
 */
function mapAction() {
    return map((ctx) => ctx.action);
}
/**
 * @param {?} types
 * @return {?}
 */
function createAllowedMap(types) {
    return types.reduce((acc, klass) => {
        acc[getActionTypeFromInstance(klass)] = true;
        return acc;
    }, {});
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Operator to run the `subscribe` in a Angular zone.
 * @template T
 * @param {?} zone
 * @return {?}
 */
function enterZone(zone) {
    return (source) => {
        return new Observable((sink) => {
            return source.subscribe({
                /**
                 * @param {?} x
                 * @return {?}
                 */
                next(x) {
                    zone.run(() => sink.next(x));
                },
                /**
                 * @param {?} e
                 * @return {?}
                 */
                error(e) {
                    zone.run(() => sink.error(e));
                },
                /**
                 * @return {?}
                 */
                complete() {
                    zone.run(() => sink.complete());
                }
            });
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
class OrderedSubject extends Subject {
    constructor() {
        super(...arguments);
        this._itemQueue = [];
        this._busyPushingNext = false;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    next(value) {
        if (this._busyPushingNext) {
            this._itemQueue.unshift(value);
            return;
        }
        this._busyPushingNext = true;
        super.next(value);
        while (this._itemQueue.length > 0) {
            /** @type {?} */
            const nextValue = this._itemQueue.pop();
            super.next(nextValue);
        }
        this._busyPushingNext = false;
    }
}
/**
 * Internal Action stream that is emitted anytime an action is dispatched.
 */
class InternalActions extends OrderedSubject {
}
InternalActions.decorators = [
    { type: Injectable }
];
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
class Actions extends Observable {
    /**
     * @param {?} actions$
     * @param {?} ngZone
     */
    constructor(actions$, ngZone) {
        super(observer => {
            actions$
                .pipe(enterZone(ngZone))
                .subscribe(res => observer.next(res), err => observer.error(err), () => observer.complete());
        });
    }
}
Actions.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Actions.ctorParameters = () => [
    { type: InternalActions },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Composes a array of functions from left to right. Example:
 *
 *      compose([fn, final])(state, action);
 *
 * then the funcs have a signature like:
 *
 *      function fn (state, action, next) {
 *          console.log('here', state, action, next);
 *          return next(state, action);
 *      }
 *
 *      function final (state, action) {
 *          console.log('here', state, action);
 *          return state;
 *      }
 *
 * the last function should not call `next`.
 *
 * @ignore
 * @type {?}
 */
const compose = funcs => (...args) => {
    /** @type {?} */
    const curr = funcs.shift();
    return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * BehaviorSubject of the entire state.
 * @ignore
 */
class StateStream extends BehaviorSubject {
    constructor() {
        super({});
    }
}
StateStream.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateStream.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Plugin manager class
 * @ignore
 */
class PluginManager {
    /**
     * @param {?} _parentManager
     * @param {?} _plugins
     */
    constructor(_parentManager, _plugins) {
        this._parentManager = _parentManager;
        this._plugins = _plugins;
        this.plugins = [];
        this.register();
    }
    /**
     * @private
     * @return {?}
     */
    register() {
        if (!this._plugins) {
            return;
        }
        this.plugins = this._plugins.map(plugin => {
            if (plugin.handle) {
                return plugin.handle.bind(plugin);
            }
            else {
                return plugin;
            }
        });
        if (this._parentManager) {
            this._parentManager.plugins.push(...this.plugins);
        }
    }
}
PluginManager.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PluginManager.ctorParameters = () => [
    { type: PluginManager, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: Array, decorators: [{ type: Inject, args: [NGXS_PLUGINS,] }, { type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal Action result stream that is emitted when an action is completed.
 * This is used as a method of returning the action result to the dispatcher
 * for the observable returned by the dispatch(...) call.
 * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
 */
class InternalDispatchedActionResults extends Subject {
}
InternalDispatchedActionResults.decorators = [
    { type: Injectable }
];
class InternalDispatcher {
    /**
     * @param {?} _errorHandler
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _pluginManager
     * @param {?} _stateStream
     * @param {?} _ngZone
     */
    constructor(_errorHandler, _actions, _actionResults, _pluginManager, _stateStream, _ngZone) {
        this._errorHandler = _errorHandler;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._pluginManager = _pluginManager;
        this._stateStream = _stateStream;
        this._ngZone = _ngZone;
    }
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    dispatch(event) {
        /** @type {?} */
        const result = this._ngZone.runOutsideAngular(() => {
            if (Array.isArray(event)) {
                return forkJoin(event.map(a => this.dispatchSingle(a)));
            }
            else {
                return this.dispatchSingle(event);
            }
        });
        result.subscribe({
            error: error => this._ngZone.run(() => this._errorHandler.handleError(error))
        });
        return result.pipe(enterZone(this._ngZone));
    }
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    dispatchSingle(action) {
        /** @type {?} */
        const prevState = this._stateStream.getValue();
        /** @type {?} */
        const plugins = this._pluginManager.plugins;
        return ((/** @type {?} */ (compose([
            ...plugins,
            (nextState, nextAction) => {
                if (nextState !== prevState) {
                    this._stateStream.next(nextState);
                }
                /** @type {?} */
                const actionResult$ = this.getActionResultStream(nextAction);
                actionResult$.subscribe(ctx => this._actions.next(ctx));
                this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                return this.createDispatchObservable(actionResult$);
            }
        ])(prevState, action)))).pipe(shareReplay());
    }
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    getActionResultStream(action) {
        return this._actionResults.pipe(filter((ctx) => ctx.action === action && ctx.status !== "DISPATCHED" /* Dispatched */), take(1), shareReplay());
    }
    /**
     * @private
     * @param {?} actionResult$
     * @return {?}
     */
    createDispatchObservable(actionResult$) {
        return actionResult$
            .pipe(exhaustMap((ctx) => {
            switch (ctx.status) {
                case "SUCCESSFUL" /* Successful */:
                    return of(this._stateStream.getValue());
                case "ERRORED" /* Errored */:
                    return throwError(ctx.error);
                default:
                    return empty();
            }
        }))
            .pipe(shareReplay());
    }
}
InternalDispatcher.decorators = [
    { type: Injectable }
];
/** @nocollapse */
InternalDispatcher.ctorParameters = () => [
    { type: ErrorHandler },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: PluginManager },
    { type: StateStream },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Object freeze code
 * https://github.com/jsdf/deep-freeze
 * @type {?}
 */
const deepFreeze = o => {
    Object.freeze(o);
    /** @type {?} */
    const oIsFunction = typeof o === 'function';
    /** @type {?} */
    const hasOwnProp = Object.prototype.hasOwnProperty;
    Object.getOwnPropertyNames(o).forEach(function (prop) {
        if (hasOwnProp.call(o, prop) &&
            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
            o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    });
    return o;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
class InternalStateOperations {
    /**
     * @param {?} _stateStream
     * @param {?} _dispatcher
     * @param {?} _config
     * @param {?} _testBed
     */
    constructor(_stateStream, _dispatcher, _config, _testBed) {
        this._stateStream = _stateStream;
        this._dispatcher = _dispatcher;
        this._config = _config;
        this._testBed = _testBed;
        this.verifyDevMode();
    }
    /**
     * Returns the root state operators.
     * @return {?}
     */
    getRootStateOperations() {
        /** @type {?} */
        const rootStateOperations = {
            getState: () => this._stateStream.getValue(),
            setState: newState => this._stateStream.next(newState),
            dispatch: actions => this._dispatcher.dispatch(actions)
        };
        if (this._config.developmentMode) {
            return this.ensureStateAndActionsAreImmutable(rootStateOperations);
        }
        return rootStateOperations;
    }
    /**
     * @private
     * @return {?}
     */
    verifyDevMode() {
        /** @type {?} */
        const isTestMode = this._testBed !== null;
        if (isTestMode)
            return;
        /** @type {?} */
        const isNgxsDevMode = this._config.developmentMode;
        /** @type {?} */
        const isNgDevMode = isDevMode();
        /** @type {?} */
        const incorrectProduction = !isNgDevMode && isNgxsDevMode;
        /** @type {?} */
        const incorrectDevelopment = isNgDevMode && !isNgxsDevMode;
        /** @type {?} */
        const example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
        if (incorrectProduction) {
            console.warn('Angular is running in production mode but NGXS is still running in the development mode!\n', 'Please set developmentMode to false on the NgxsModule options when in production mode.\n', example);
        }
        else if (incorrectDevelopment) {
            console.warn('RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n', example);
        }
    }
    /**
     * @private
     * @param {?} root
     * @return {?}
     */
    ensureStateAndActionsAreImmutable(root) {
        return {
            getState: () => root.getState(),
            setState: value => {
                /** @type {?} */
                const frozenValue = deepFreeze(value);
                return root.setState(frozenValue);
            },
            dispatch: actions => {
                return root.dispatch(actions);
            }
        };
    }
}
InternalStateOperations.decorators = [
    { type: Injectable }
];
/** @nocollapse */
InternalStateOperations.ctorParameters = () => [
    { type: StateStream },
    { type: InternalDispatcher },
    { type: NgxsConfig },
    { type: TestBed, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
class StateContextFactory {
    /**
     * @param {?} _internalStateOperations
     */
    constructor(_internalStateOperations) {
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Create the state context
     * @param {?} metadata
     * @return {?}
     */
    createStateContext(metadata) {
        /** @type {?} */
        const root = this._internalStateOperations.getRootStateOperations();
        return {
            /**
             * @return {?}
             */
            getState() {
                /** @type {?} */
                const state = root.getState();
                return getValue(state, metadata.depth);
            },
            /**
             * @param {?} val
             * @return {?}
             */
            patchState(val) {
                /** @type {?} */
                const isArray = Array.isArray(val);
                /** @type {?} */
                const isPrimitive = typeof val !== 'object';
                if (isArray) {
                    throw new Error('Patching arrays is not supported.');
                }
                else if (isPrimitive) {
                    throw new Error('Patching primitives is not supported.');
                }
                /** @type {?} */
                const state = root.getState();
                /** @type {?} */
                const local = getValue(state, metadata.depth);
                /** @type {?} */
                const clone = Object.assign({}, local);
                for (const k in val) {
                    clone[k] = val[k];
                }
                /** @type {?} */
                const newState = setValue(state, metadata.depth, clone);
                root.setState(newState);
                return newState;
            },
            /**
             * @param {?} val
             * @return {?}
             */
            setState(val) {
                /** @type {?} */
                let state = root.getState();
                state = setValue(state, metadata.depth, val);
                root.setState(state);
                return state;
            },
            /**
             * @param {?} actions
             * @return {?}
             */
            dispatch(actions) {
                return root.dispatch(actions);
            }
        };
    }
}
StateContextFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateContextFactory.ctorParameters = () => [
    { type: InternalStateOperations }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State factory class
 * @ignore
 */
class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._states = [];
        this._connected = false;
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    add(oneOrManyStateClasses) {
        /** @type {?} */
        let stateClasses;
        if (!Array.isArray(oneOrManyStateClasses)) {
            stateClasses = [oneOrManyStateClasses];
        }
        else {
            stateClasses = oneOrManyStateClasses;
        }
        /** @type {?} */
        const stateGraph = buildGraph(stateClasses);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const depths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(stateClasses);
        /** @type {?} */
        const mappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            /** @type {?} */
            const depth = depths[name];
            const { actions } = stateClass[META_KEY];
            let { defaults } = stateClass[META_KEY];
            stateClass[META_KEY].path = depth;
            stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this._config);
            // ensure our store hasn't already been added
            // but dont throw since it could be lazy
            // loaded from different paths
            /** @type {?} */
            const has = this.states.find(s => s.name === name);
            if (!has) {
                // create new instance of defaults
                if (Array.isArray(defaults)) {
                    defaults = [...defaults];
                }
                else if (isObject(defaults)) {
                    defaults = Object.assign({}, defaults);
                }
                else if (defaults === undefined) {
                    defaults = {};
                }
                /** @type {?} */
                const instance = this._injector.get(stateClass);
                mappedStores.push({
                    actions,
                    instance,
                    defaults,
                    name,
                    depth
                });
            }
        }
        this.states.push(...mappedStores);
        return mappedStores;
    }
    /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        if (stateClasses) {
            /** @type {?} */
            const states = this.add(stateClasses);
            /** @type {?} */
            const defaults = states.reduce((result, meta) => setValue(result, meta.depth, meta.defaults), {});
            return { defaults, states };
        }
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._connected)
            return;
        this._actions
            .pipe(filter((ctx) => ctx.status === "DISPATCHED" /* Dispatched */), mergeMap(({ action }) => this.invokeActions(this._actions, action).pipe(map(() => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ }))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError(error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error })))))))
            .subscribe(ctx => this._actionResults.next(ctx));
        this._connected = true;
    }
    /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    invokeInit(stateMetadatas) {
        for (const metadata of stateMetadatas) {
            /** @type {?} */
            const instance = metadata.instance;
            if (instance.ngxsOnInit) {
                /** @type {?} */
                const stateContext = this.createStateContext(metadata);
                instance.ngxsOnInit(stateContext);
            }
        }
    }
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    invokeActions(actions$, action) {
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const type = getActionTypeFromInstance(action);
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (result instanceof Observable) {
                            result = result.pipe(actionMeta.options.cancelUncompleted
                                ? takeUntil(actions$.pipe(ofActionDispatched(action)))
                                : map(r => r)); // map acts like a noop
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    createStateContext(metadata) {
        return this._stateContextFactory.createStateContext(metadata);
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function defaultEqualityCheck(a, b) {
    return a === b;
}
/**
 * @param {?} equalityCheck
 * @param {?} prev
 * @param {?} next
 * @return {?}
 */
function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
        return false;
    }
    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
    /** @type {?} */
    const length = prev.length;
    for (let i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Memoize a function on its last inputs only.
 * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
 *
 * @ignore
 * @template R, T
 * @param {?} func
 * @param {?=} equalityCheck
 * @return {?}
 */
function memoize(func, equalityCheck = defaultEqualityCheck) {
    /** @type {?} */
    let lastArgs = null;
    /** @type {?} */
    let lastResult = null;
    // we reference arguments instead of spreading them for performance reasons
    /**
     * @return {?}
     */
    function memoized() {
        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
            // apply arguments instead of spreading for performance.
            lastResult = func.apply(null, arguments);
        }
        lastArgs = arguments;
        return lastResult;
    }
    ((/** @type {?} */ (memoized))).reset = function () {
        // The hidden (for now) ability to reset the memoization
        lastArgs = null;
        lastResult = null;
    };
    return (/** @type {?} */ (memoized));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Function for creating a selector
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    const wrappedFn = function wrappedSelectorFn(...args) {
        /** @type {?} */
        const returnValue = originalFn(...args);
        if (returnValue instanceof Function) {
            /** @type {?} */
            const innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    /** @type {?} */
    const memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    const containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    const fn = state => {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        const selectorsToApply = [];
        if (containerClass) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            const metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push(...selectors);
        }
        // Determine arguments from the app state using the selectors
        if (selectorsToApply) {
            results.push(...selectorsToApply.map(a => getSelectorFn(a)(state)));
        }
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn(...results);
        }
        catch (ex) {
            if (ex instanceof TypeError) {
                return undefined;
            }
            throw ex;
        }
    };
    /** @type {?} */
    const selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    selectorMetaData.selectFromAppState = fn;
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
    }
    return memoizedFn;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
function getSelectorFn(selector) {
    /** @type {?} */
    const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Store {
    /**
     * @param {?} _ngZone
     * @param {?} _stateStream
     * @param {?} _internalStateOperations
     */
    constructor(_ngZone, _stateStream, _internalStateOperations) {
        this._ngZone = _ngZone;
        this._stateStream = _stateStream;
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    dispatch(event) {
        return this._internalStateOperations.getRootStateOperations().dispatch(event);
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    select(selector) {
        /** @type {?} */
        const selectorFn = getSelectorFn(selector);
        return this._stateStream.pipe(map(selectorFn), catchError(err => {
            // if error is TypeError we swallow it to prevent usual errors with property access
            if (err instanceof TypeError) {
                return of(undefined);
            }
            // rethrow other errors
            throw err;
        }), distinctUntilChanged(), enterZone(this._ngZone));
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    selectOnce(selector) {
        return this.select(selector).pipe(take(1));
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    selectSnapshot(selector) {
        /** @type {?} */
        const selectorFn = getSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    }
    /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    subscribe(fn) {
        return this._stateStream.pipe(enterZone(this._ngZone)).subscribe(fn);
    }
    /**
     * Return the raw value of the state.
     * @return {?}
     */
    snapshot() {
        return this._internalStateOperations.getRootStateOperations().getState();
    }
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    reset(state) {
        return this._internalStateOperations.getRootStateOperations().setState(state);
    }
}
Store.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Store.ctorParameters = () => [
    { type: NgZone },
    { type: StateStream },
    { type: InternalStateOperations }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Allows the select decorator to get access to the DI store.
 * @ignore
 */
class SelectFactory {
    /**
     * @param {?} store
     * @param {?} config
     */
    constructor(store, config) {
        SelectFactory.store = store;
        SelectFactory.config = config;
    }
}
SelectFactory.store = undefined;
SelectFactory.config = undefined;
SelectFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SelectFactory.ctorParameters = () => [
    { type: Store },
    { type: NgxsConfig }
];
/**
 * Decorator for selecting a slice of state from the store.
 * @param {?=} selectorOrFeature
 * @param {...?} paths
 * @return {?}
 */
function Select(selectorOrFeature, ...paths) {
    return function (target, name) {
        /** @type {?} */
        const selectorFnName = '__' + name + '__selector';
        if (!selectorOrFeature) {
            // if foo$ => make it just foo
            selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;
        }
        /** @type {?} */
        const createSelect = fn => {
            /** @type {?} */
            const store = SelectFactory.store;
            if (!store) {
                throw new Error('SelectFactory not connected to store!');
            }
            return store.select(fn);
        };
        /** @type {?} */
        const createSelector = () => {
            /** @type {?} */
            const config = SelectFactory.config;
            if (typeof selectorOrFeature === 'string') {
                /** @type {?} */
                const propsArray = paths.length ? [selectorOrFeature, ...paths] : selectorOrFeature.split('.');
                return propGetter(propsArray, config);
            }
            else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                return propGetter(selectorOrFeature[META_KEY].path.split('.'), config);
            }
            else {
                return selectorOrFeature;
            }
        };
        if (target[selectorFnName]) {
            throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
        }
        if (delete target[name]) {
            Object.defineProperty(target, selectorFnName, {
                writable: true,
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(target, name, {
                get: function () {
                    return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));
                },
                enumerable: true,
                configurable: true
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Init action
 */
class InitState {
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '@@INIT';
    }
}
/**
 * Update action
 */
class UpdateState {
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '@@UPDATE_STATE';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Root module
 * @ignore
 */
class NgxsRootModule {
    /**
     * @param {?} factory
     * @param {?} internalStateOperations
     * @param {?} store
     * @param {?} select
     * @param {?} states
     */
    constructor(factory, internalStateOperations, store, select, states) {
        // add stores to the state graph and return their defaults
        /** @type {?} */
        const results = factory.addAndReturnDefaults(states);
        /** @type {?} */
        const stateOperations = internalStateOperations.getRootStateOperations();
        if (results) {
            // get our current stream
            /** @type {?} */
            const cur = stateOperations.getState();
            // set the state to the current + new
            stateOperations.setState(Object.assign({}, cur, results.defaults));
        }
        // connect our actions stream
        factory.connectActionHandlers();
        // dispatch the init action and invoke init function after
        stateOperations.dispatch(new InitState()).subscribe(() => {
            if (results) {
                factory.invokeInit(results.states);
            }
        });
    }
}
NgxsRootModule.decorators = [
    { type: NgModule }
];
/** @nocollapse */
NgxsRootModule.ctorParameters = () => [
    { type: StateFactory },
    { type: InternalStateOperations },
    { type: Store },
    { type: SelectFactory },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [ROOT_STATE_TOKEN,] }] }
];
/**
 * Feature module
 * @ignore
 */
class NgxsFeatureModule {
    /**
     * @param {?} store
     * @param {?} internalStateOperations
     * @param {?} factory
     * @param {?} states
     */
    constructor(store, internalStateOperations, factory, states) {
        // Since FEATURE_STATE_TOKEN is a multi token, we need to
        // flatten it [[Feature1State, Feature2State], [Feature3State]]
        /** @type {?} */
        const flattenedStates = ((/** @type {?} */ ([]))).concat(...states);
        // add stores to the state graph and return their defaults
        /** @type {?} */
        const results = factory.addAndReturnDefaults(flattenedStates);
        /** @type {?} */
        const stateOperations = internalStateOperations.getRootStateOperations();
        if (results) {
            // get our current stream
            /** @type {?} */
            const cur = stateOperations.getState();
            // set the state to the current + new
            stateOperations.setState(Object.assign({}, cur, results.defaults));
        }
        stateOperations.dispatch(new UpdateState()).subscribe(() => {
            if (results) {
                factory.invokeInit(results.states);
            }
        });
    }
}
NgxsFeatureModule.decorators = [
    { type: NgModule, args: [{},] }
];
/** @nocollapse */
NgxsFeatureModule.ctorParameters = () => [
    { type: Store },
    { type: InternalStateOperations },
    { type: StateFactory },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [FEATURE_STATE_TOKEN,] }] }
];
/**
 * @param {?} options
 * @return {?}
 */
function ngxsConfigFactory(options) {
    /** @type {?} */
    const config = Object.assign(new NgxsConfig(), options);
    return config;
}
/** @type {?} */
const ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');
/**
 * Ngxs Module
 */
class NgxsModule {
    /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    static forRoot(states = [], options = {}) {
        return {
            ngModule: NgxsRootModule,
            providers: [
                StateFactory,
                StateContextFactory,
                Actions,
                InternalActions,
                InternalDispatcher,
                InternalDispatchedActionResults,
                InternalStateOperations,
                Store,
                StateStream,
                SelectFactory,
                PluginManager,
                ...states,
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                },
                {
                    provide: ROOT_OPTIONS,
                    useValue: options
                },
                {
                    provide: NgxsConfig,
                    useFactory: ngxsConfigFactory,
                    deps: [ROOT_OPTIONS]
                }
            ]
        };
    }
    /**
     * Feature module factory
     * @param {?} states
     * @return {?}
     */
    static forFeature(states) {
        return {
            ngModule: NgxsFeatureModule,
            providers: [
                StateFactory,
                PluginManager,
                ...states,
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: states
                }
            ]
        };
    }
}
NgxsModule.decorators = [
    { type: NgModule, args: [{},] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates a method with a action information.
 * @param {?} actions
 * @param {?=} options
 * @return {?}
 */
function Action(actions, options) {
    return function (target, name, descriptor) {
        /** @type {?} */
        const meta = ensureStoreMetadata(target.constructor);
        if (!Array.isArray(actions)) {
            actions = [actions];
        }
        for (const action of actions) {
            /** @type {?} */
            const type = action.type;
            if (!action.type) {
                throw new Error(`Action ${action.name} is missing a static "type" property`);
            }
            if (!meta.actions[type]) {
                meta.actions[type] = [];
            }
            meta.actions[type].push({
                fn: name,
                options: options || {},
                type
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');
/**
 * Error message
 * @ignore
 * @type {?}
 */
const stateNameErrorMessage = name => `${name} is not a valid state name. It needs to be a valid object property name.`;
/**
 * Decorates a class with ngxs state information.
 * @template T
 * @param {?} options
 * @return {?}
 */
function State(options) {
    return function (target) {
        /** @type {?} */
        const meta = ensureStoreMetadata(target);
        // Handle inheritance
        if (Object.getPrototypeOf(target).hasOwnProperty(META_KEY)) {
            /** @type {?} */
            const parentMeta = Object.getPrototypeOf(target)[META_KEY];
            meta.actions = Object.assign({}, meta.actions, parentMeta.actions);
        }
        meta.children = options.children;
        meta.defaults = options.defaults;
        meta.name = options.name;
        if (!options.name) {
            throw new Error(`States must register a 'name' property`);
        }
        if (!stateNameRegex.test(options.name)) {
            throw new Error(stateNameErrorMessage(options.name));
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorator for memoizing a state selector.
 * @param {?=} selectors
 * @return {?}
 */
function Selector(selectors) {
    return (target, key, descriptor) => {
        if (descriptor.value !== null) {
            /** @type {?} */
            const originalFn = descriptor.value;
            /** @type {?} */
            const memoizedFn = createSelector(selectors, originalFn, { containerClass: target, selectorName: key });
            return {
                configurable: true,
                /**
                 * @return {?}
                 */
                get() {
                    return memoizedFn;
                }
            };
        }
        else {
            throw new Error('Selectors only work on methods');
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxsModule, Action, Store, State, Select, Actions, getSelectorMetadata, getStoreMetadata, ensureStoreMetadata, ensureSelectorMetadata, ofAction, ofActionDispatched, ofActionSuccessful, ofActionCanceled, ofActionErrored, Selector, getActionTypeFromInstance, actionMatcher, createSelector, NGXS_PLUGINS, StateStream, setValue, getValue, InitState, UpdateState, InternalActions as ɵg, OrderedSubject as ɵf, SelectFactory as ɵe, InternalDispatchedActionResults as ɵn, InternalDispatcher as ɵo, StateContextFactory as ɵp, StateFactory as ɵm, InternalStateOperations as ɵq, NgxsFeatureModule as ɵb, NgxsRootModule as ɵa, ROOT_OPTIONS as ɵd, ngxsConfigFactory as ɵc, PluginManager as ɵr, FEATURE_STATE_TOKEN as ɵi, META_KEY as ɵj, NgxsConfig as ɵl, ROOT_STATE_TOKEN as ɵh, SELECTOR_META_KEY as ɵk };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4cy1zdG9yZS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5neHMvc3RvcmUvc3JjL3N5bWJvbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9pbnRlcm5hbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy91dGlscy91dGlscy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL29wZXJhdG9ycy9vZi1hY3Rpb24udHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9vcGVyYXRvcnMvem9uZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2FjdGlvbnMtc3RyZWFtLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvY29tcG9zZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLXN0cmVhbS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3BsdWdpbi1tYW5hZ2VyLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvaW50ZXJuYWwvZGlzcGF0Y2hlci50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL2ZyZWV6ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnkudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvbWVtb2l6ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL3NlbGVjdG9yLXV0aWxzLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvc3RvcmUudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9kZWNvcmF0b3JzL3NlbGVjdC50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2FjdGlvbnMvYWN0aW9ucy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL21vZHVsZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvYWN0aW9uLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvZGVjb3JhdG9ycy9zdGF0ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvc2VsZWN0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignUk9PVF9TVEFURV9UT0tFTicpO1xyXG5leHBvcnQgY29uc3QgRkVBVFVSRV9TVEFURV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdGRUFUVVJFX1NUQVRFX1RPS0VOJyk7XHJcbmV4cG9ydCBjb25zdCBNRVRBX0tFWSA9ICdOR1hTX01FVEEnO1xyXG5leHBvcnQgY29uc3QgU0VMRUNUT1JfTUVUQV9LRVkgPSAnTkdYU19TRUxFQ1RPUl9NRVRBJztcclxuXHJcbmV4cG9ydCBjb25zdCBOR1hTX1BMVUdJTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05HWFNfUExVR0lOUycpO1xyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luQ29uc3RydWN0b3IgPSBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBOZ3hzUGx1Z2luO1xyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luRm4gPSAoc3RhdGU6IGFueSwgbXV0YXRpb246IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5GbikgPT4gYW55O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBOR1hTIGNvbmZpZyBzZXR0aW5ncy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ3hzQ29uZmlnIHtcclxuICAvKipcclxuICAgKiBSdW4gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gVGhpcyB3aWxsIGFkZCBhZGRpdGlvbmFsIGRlYnVnZ2luZyBmZWF0dXJlczpcclxuICAgKiAtIE9iamVjdC5mcmVlemUgb24gdGhlIHN0YXRlIGFuZCBhY3Rpb25zIHRvIGd1YXJhbnRlZSBpbW11dGFiaWxpdHlcclxuICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICovXHJcbiAgZGV2ZWxvcG1lbnRNb2RlOiBib29sZWFuO1xyXG4gIGNvbXBhdGliaWxpdHk6IHtcclxuICAgIC8qKlxyXG4gICAgICogU3VwcG9ydCBhIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cclxuICAgICAqIFRoaXMgd2lsbCBjaXJ1bXZlbnQgc29tZSBvcHRpbWlzYXRpb25zIHRoYXQgdmlvbGF0ZSBhIHN0cmljdCBDU1AgdGhyb3VnaCB0aGUgdXNlIG9mIGBuZXcgRnVuY3Rpb24oLi4uKWAuXHJcbiAgICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICAgKi9cclxuICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogYm9vbGVhbjtcclxuICB9O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY29tcGF0aWJpbGl0eSA9IHtcclxuICAgICAgc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5OiBmYWxzZVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBjb250ZXh0IHByb3ZpZGVkIHRvIHRoZSBhY3Rpb25zIGluIHRoZSBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDb250ZXh0PFQ+IHtcclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICovXHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldFN0YXRlKHZhbDogVCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGNoIHRoZSBleGlzdGluZyBzdGF0ZSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgKi9cclxuICBwYXRjaFN0YXRlKHZhbDogUGFydGlhbDxUPik7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoIGEgbmV3IGFjdGlvbiBhbmQgcmV0dXJuIHRoZSBkaXNwYXRjaGVkIG9ic2VydmFibGUuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTmV4dFBsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnkpID0+IGFueTtcclxuXHJcbi8qKlxyXG4gKiBQbHVnaW4gaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB0aGUgc3RhdGUvYWN0aW9uIGJlZm9yZSBpdHMgc3VibWl0dGVkIHRvIHRoZSBzdGF0ZSBoYW5kbGVycy5cclxuICAgKi9cclxuICBoYW5kbGUoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pOiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBzdG9yZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmVPcHRpb25zPFQ+IHtcclxuICAvKipcclxuICAgKiBOYW1lIG9mIHRoZSBzdGF0ZS4gUmVxdWlyZWQuXHJcbiAgICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgdGhlIHN0YXRlLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgZW1wdHkgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGRlZmF1bHRzPzogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogU3ViIHN0YXRlcyBmb3IgdGhlIGdpdmVuIHN0YXRlLlxyXG4gICAqL1xyXG4gIGNoaWxkcmVuPzogYW55W107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY3Rpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIGEgYWN0aW9uIGRlY29yYXRvci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uT3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogQ2FuY2VsIHRoZSBwcmV2aW91cyB1bmNvbXBsZXRlZCBvYnNlcnZhYmxlKHMpLlxyXG4gICAqL1xyXG4gIGNhbmNlbFVuY29tcGxldGVkPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9uIGluaXQgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNPbkluaXQge1xyXG4gIG5neHNPbkluaXQoY3R4PzogU3RhdGVDb250ZXh0PGFueT4pOiB2b2lkIHwgYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTGlmZUN5Y2xlID0gUGFydGlhbDxOZ3hzT25Jbml0PjtcclxuIiwiaW1wb3J0IHsgTUVUQV9LRVksIEFjdGlvbk9wdGlvbnMsIFNFTEVDVE9SX01FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0S2V5TWFwPFQ+IHtcclxuICBba2V5OiBzdHJpbmddOiBUO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3Mge1xyXG4gIFtNRVRBX0tFWV0/OiBNZXRhRGF0YU1vZGVsO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTdGF0ZUtleUdyYXBoID0gT2JqZWN0S2V5TWFwPHN0cmluZ1tdPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uSGFuZGxlck1ldGFEYXRhIHtcclxuICBmbjogc3RyaW5nO1xyXG4gIG9wdGlvbnM6IEFjdGlvbk9wdGlvbnM7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlT3BlcmF0aW9uczxUPiB7XHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuICBzZXRTdGF0ZSh2YWw6IFQpO1xyXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXRhRGF0YU1vZGVsIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgYWN0aW9uczogT2JqZWN0S2V5TWFwPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIHBhdGg6IHN0cmluZztcclxuICBzZWxlY3RGcm9tQXBwU3RhdGU6IFNlbGVjdEZyb21TdGF0ZTtcclxuICBjaGlsZHJlbjogU3RhdGVDbGFzc1tdO1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNlbGVjdEZyb21TdGF0ZSA9IChzdGF0ZTogYW55KSA9PiBhbnk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGU7XHJcbiAgb3JpZ2luYWxGbjogRnVuY3Rpb247XHJcbiAgY29udGFpbmVyQ2xhc3M6IGFueTtcclxuICBzZWxlY3Rvck5hbWU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXBwZWRTdG9yZSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBpbnN0YW5jZTogYW55O1xyXG4gIGRlcHRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBjbGFzcyBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0KTogTWV0YURhdGFNb2RlbCB7XHJcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoTUVUQV9LRVkpKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IE1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIGFjdGlvbnM6IHt9LFxyXG4gICAgICBkZWZhdWx0czoge30sXHJcbiAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICBpbnN0YW5jZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBNRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuICByZXR1cm4gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgY2xhc3MgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpOiBNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGFuZCByZXR1cm5zIGl0LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQpOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KFNFTEVDVE9SX01FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcclxuICAgICAgY29udGFpbmVyQ2xhc3M6IG51bGwsXHJcbiAgICAgIHNlbGVjdG9yTmFtZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBTRUxFQ1RPUl9NRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W1NFTEVDVE9SX01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhcyBmYXN0IGFzIHRoZSBgZmFzdFByb3BHZXR0ZXJgIGJ1dCBpcyBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgY29tcGxpYW50LlxyXG4gKiBTZWUgcGVyZiBoaXQ6IGh0dHBzOi8vanNwZXJmLmNvbS9mYXN0LXZhbHVlLWdldHRlci1naXZlbi1wYXRoLzFcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGxpYW50UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IGNvcHlPZlBhdGhzID0gWy4uLnBhdGhzXTtcclxuICByZXR1cm4gb2JqID0+IGNvcHlPZlBhdGhzLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW46XHJcbiAqIC0gcGx1Y2sgKE9ic2VydmFibGUgb3BlcmF0b3IpXHJcbiAqIC0gbWVtb2l6ZVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBmYXN0UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aHM7XHJcbiAgbGV0IHNlZyA9ICdzdG9yZS4nICsgc2VnbWVudHNbMF07XHJcbiAgbGV0IGkgPSAwO1xyXG4gIGNvbnN0IGwgPSBzZWdtZW50cy5sZW5ndGg7XHJcblxyXG4gIGxldCBleHByID0gc2VnO1xyXG4gIHdoaWxlICgrK2kgPCBsKSB7XHJcbiAgICBleHByID0gZXhwciArICcgJiYgJyArIChzZWcgPSBzZWcgKyAnLicgKyBzZWdtZW50c1tpXSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignc3RvcmUnLCAncmV0dXJuICcgKyBleHByICsgJzsnKTtcclxuXHJcbiAgcmV0dXJuIDwoeDogYW55KSA9PiBhbnk+Zm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5ICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5LnN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeSkge1xyXG4gICAgcmV0dXJuIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFzdFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0YXRlcywgaXQgd2lsbCByZXR1cm4gYSBvYmplY3QgZ3JhcGguIEV4YW1wbGU6XHJcbiAqICAgIGNvbnN0IHN0YXRlcyA9IFtcclxuICogICAgICBDYXJ0LFxyXG4gKiAgICAgIENhcnRTYXZlZCxcclxuICogICAgICBDYXJ0U2F2ZWRJdGVtc1xyXG4gKiAgICBdXHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiBTdGF0ZUtleUdyYXBoIHtcclxuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc2VzLmZpbmQoZyA9PiBnID09PSBzdGF0ZUNsYXNzKTtcclxuICAgIGlmICghbWV0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vdCBmb3VuZDogJHtzdGF0ZUNsYXNzfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbWV0YVtNRVRBX0tFWV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWV0YVtNRVRBX0tFWV0ubmFtZTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc3RhdGVDbGFzc2VzLnJlZHVjZTxTdGF0ZUtleUdyYXBoPigocmVzdWx0OiBTdGF0ZUtleUdyYXBoLCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBpZiAoIXN0YXRlQ2xhc3NbTUVUQV9LRVldKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGVzIG11c3QgYmUgZGVjb3JhdGVkIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBuYW1lLCBjaGlsZHJlbiB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICByZXN1bHRbbmFtZV0gPSAoY2hpbGRyZW4gfHwgW10pLm1hcChmaW5kTmFtZSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgc3RhdGVzIGFycmF5LCByZXR1cm5zIG9iamVjdCBncmFwaFxyXG4gKiByZXR1cm5pbmcgdGhlIG5hbWUgYW5kIHN0YXRlIG1ldGFkYXRhLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IHsgbWV0YWRhdGEgfVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVUb1N0YXRlKHN0YXRlczogU3RhdGVDbGFzc1tdKTogT2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+IHtcclxuICByZXR1cm4gc3RhdGVzLnJlZHVjZTxPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4+KChyZXN1bHQ6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgaWYgKCFzdGF0ZUNsYXNzW01FVEFfS0VZXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuICAgIHJlc3VsdFttZXRhLm5hbWVdID0gc3RhdGVDbGFzcztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSwge30pO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgcmVsYXRpb25zaGlwIGdyYXBoIHdpbGwgcmV0dXJuIHRoZSBmdWxsIHBhdGhcclxuICogZm9yIHRoZSBjaGlsZCBpdGVtcy4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgciA9IHtcclxuICogICAgY2FydDogJ2NhcnQnLFxyXG4gKiAgICBzYXZlZDogJ2NhcnQuc2F2ZWQnLFxyXG4gKiAgICBpdGVtczogJ2NhcnQuc2F2ZWQuaXRlbXMnXHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZ1bGxQYXJlbnRQYXRoKG9iajogU3RhdGVLZXlHcmFwaCwgbmV3T2JqOiBPYmplY3RLZXlNYXA8c3RyaW5nPiA9IHt9KTogT2JqZWN0S2V5TWFwPHN0cmluZz4ge1xyXG4gIGNvbnN0IHZpc2l0ID0gKGNoaWxkOiBTdGF0ZUtleUdyYXBoLCBrZXlUb0ZpbmQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjaGlsZFtrZXldLmluZGV4T2Yoa2V5VG9GaW5kKSA+PSAwKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQoY2hpbGQsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQob2JqLCBrZXkpO1xyXG4gICAgICBuZXdPYmpba2V5XSA9IHBhcmVudCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdPYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG9iamVjdCBncmFwaCwgaXQgd2lsbCByZXR1cm4gdGhlIGl0ZW1zIHRvcG9sb2dpY2FsbHkgc29ydGVkIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHJlc3VsdHMgPSBbXHJcbiAqICAgICdpdGVtcycsXHJcbiAqICAgICdzYXZlZCcsXHJcbiAqICAgICdjYXJ0J1xyXG4gKiAgXTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvcG9sb2dpY2FsU29ydChncmFwaDogU3RhdGVLZXlHcmFwaCk6IHN0cmluZ1tdIHtcclxuICBjb25zdCBzb3J0ZWQ6IHN0cmluZ1tdID0gW107XHJcbiAgY29uc3QgdmlzaXRlZDogT2JqZWN0S2V5TWFwPGJvb2xlYW4+ID0ge307XHJcblxyXG4gIGNvbnN0IHZpc2l0ID0gKG5hbWU6IHN0cmluZywgYW5jZXN0b3JzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW5jZXN0b3JzKSkge1xyXG4gICAgICBhbmNlc3RvcnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhbmNlc3RvcnMucHVzaChuYW1lKTtcclxuICAgIHZpc2l0ZWRbbmFtZV0gPSB0cnVlO1xyXG5cclxuICAgIGdyYXBoW25hbWVdLmZvckVhY2goKGRlcDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGlmIChhbmNlc3RvcnMuaW5kZXhPZihkZXApID49IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENpcmN1bGFyIGRlcGVuZGVuY3kgJyR7ZGVwfScgaXMgcmVxdWlyZWQgYnkgJyR7bmFtZX0nOiAke2FuY2VzdG9ycy5qb2luKCcgLT4gJyl9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2aXNpdGVkW2RlcF0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZpc2l0KGRlcCwgYW5jZXN0b3JzLnNsaWNlKDApKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChzb3J0ZWQuaW5kZXhPZihuYW1lKSA8IDApIHtcclxuICAgICAgc29ydGVkLnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT2JqZWN0LmtleXMoZ3JhcGgpLmZvckVhY2goayA9PiB2aXNpdChrKSk7XHJcblxyXG4gIHJldHVybiBzb3J0ZWQucmV2ZXJzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgb2JqZWN0IG9yIG5vdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0eXBlIGZyb20gYW4gYWN0aW9uIGluc3RhbmNlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb246IGFueSk6IHN0cmluZyB7XHJcbiAgaWYgKGFjdGlvbi5jb25zdHJ1Y3RvciAmJiBhY3Rpb24uY29uc3RydWN0b3IudHlwZSkge1xyXG4gICAgcmV0dXJuIGFjdGlvbi5jb25zdHJ1Y3Rvci50eXBlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFjdGlvbi50eXBlO1xyXG59XHJcblxyXG4vKipcclxuICogTWF0Y2hlcyBhIGFjdGlvblxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uTWF0Y2hlcihhY3Rpb24xOiBhbnkpIHtcclxuICBjb25zdCB0eXBlMSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uMSk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbihhY3Rpb24yOiBhbnkpIHtcclxuICAgIHJldHVybiB0eXBlMSA9PT0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24yKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICBzZXRWYWx1ZSh7IGZvbzogeyBiYXI6IHsgZWF0OiBmYWxzZSB9IH0gfSxcclxuICogICAgICAnZm9vLmJhci5lYXQnLCB0cnVlKSAvLz0+IHsgZm9vOiB7IGJhcjogeyBlYXQ6IHRydWUgfSB9IH1cclxuICpcclxuICogV2hpbGUgaXQgdHJhdmVyc2VzIGl0IGFsc28gY3JlYXRlcyBuZXcgb2JqZWN0cyBmcm9tIHRvcCBkb3duLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2V0VmFsdWUgPSAob2JqOiBhbnksIHByb3A6IHN0cmluZywgdmFsOiBhbnkpID0+IHtcclxuICBvYmogPSB7IC4uLm9iaiB9O1xyXG5cclxuICBjb25zdCBzcGxpdCA9IHByb3Auc3BsaXQoJy4nKTtcclxuICBjb25zdCBsYXN0SW5kZXggPSBzcGxpdC5sZW5ndGggLSAxO1xyXG5cclxuICBzcGxpdC5yZWR1Y2UoKGFjYywgcGFydCwgaW5kZXgpID0+IHtcclxuICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XHJcbiAgICAgIGFjY1twYXJ0XSA9IHZhbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFjY1twYXJ0XSA9IEFycmF5LmlzQXJyYXkoYWNjW3BhcnRdKSA/IFsuLi5hY2NbcGFydF1dIDogeyAuLi5hY2NbcGFydF0gfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWNjICYmIGFjY1twYXJ0XTtcclxuICB9LCBvYmopO1xyXG5cclxuICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0VmFsdWUgPSAob2JqOiBhbnksIHByb3A6IHN0cmluZykgPT5cclxuICBwcm9wLnNwbGl0KCcuJykucmVkdWNlKChhY2M6IGFueSwgcGFydDogc3RyaW5nKSA9PiBhY2MgJiYgYWNjW3BhcnRdLCBvYmopO1xyXG4iLCJpbXBvcnQgeyBPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBBY3Rpb25Db250ZXh0LCBBY3Rpb25TdGF0dXMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb248VD4oYWxsb3dlZFR5cGUpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD47XHJcbmV4cG9ydCBmdW5jdGlvbiBvZkFjdGlvbjxUPiguLi5hbGxvd2VkVHlwZXMpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD47XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gZGlzcGF0Y2hlZCBhcyB3ZWxsIGFzIGFjdGlvbnMgdGhhdCBoYXZlIGNvbXBsZXRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgYmVlbiBkaXNwYXRjaGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25EaXNwYXRjaGVkKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMsIEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIE9OTFkgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uU3VjY2Vzc2Z1bCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSeEpTIG9wZXJhdG9yIGZvciBzZWxlY3Rpbmcgb3V0IHNwZWNpZmljIGFjdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBPTkxZIGdyYWIgYWN0aW9ucyB0aGF0IGhhdmUganVzdCBiZWVuIGNhbmNlbGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25DYW5jZWxlZCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgdGhyb3duIGFuIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25FcnJvcmVkKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMsIEFjdGlvblN0YXR1cy5FcnJvcmVkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXM6IGFueVtdLCBzdGF0dXM/OiBBY3Rpb25TdGF0dXMpIHtcclxuICBjb25zdCBhbGxvd2VkTWFwID0gY3JlYXRlQWxsb3dlZE1hcChhbGxvd2VkVHlwZXMpO1xyXG4gIHJldHVybiBmdW5jdGlvbihvOiBPYnNlcnZhYmxlPGFueT4pIHtcclxuICAgIHJldHVybiBvLnBpcGUoXHJcbiAgICAgIGZpbHRlclN0YXR1cyhhbGxvd2VkTWFwLCBzdGF0dXMpLFxyXG4gICAgICBtYXBBY3Rpb24oKVxyXG4gICAgKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJTdGF0dXMoYWxsb3dlZFR5cGVzOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSwgc3RhdHVzPzogQWN0aW9uU3RhdHVzKSB7XHJcbiAgcmV0dXJuIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCBhY3Rpb25UeXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShjdHguYWN0aW9uKTtcclxuICAgIGNvbnN0IHR5cGUgPSBhbGxvd2VkVHlwZXNbYWN0aW9uVHlwZV07XHJcbiAgICByZXR1cm4gc3RhdHVzID8gdHlwZSAmJiBjdHguc3RhdHVzID09PSBzdGF0dXMgOiB0eXBlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBBY3Rpb24oKSB7XHJcbiAgcmV0dXJuIG1hcCgoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguYWN0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQWxsb3dlZE1hcCh0eXBlczogYW55W10pOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSB7XHJcbiAgcmV0dXJuIHR5cGVzLnJlZHVjZSgoYWNjOiBhbnksIGtsYXNzOiBhbnkpID0+IHtcclxuICAgIGFjY1tnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGtsYXNzKV0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGFjYztcclxuICB9LCB7fSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogT3BlcmF0b3IgdG8gcnVuIHRoZSBgc3Vic2NyaWJlYCBpbiBhIEFuZ3VsYXIgem9uZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnRlclpvbmU8VD4oem9uZTogTmdab25lKSB7XHJcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc2luazogT2JzZXJ2ZXI8VD4pID0+IHtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoe1xyXG4gICAgICAgIG5leHQoeCkge1xyXG4gICAgICAgICAgem9uZS5ydW4oKCkgPT4gc2luay5uZXh0KHgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yKGUpIHtcclxuICAgICAgICAgIHpvbmUucnVuKCgpID0+IHNpbmsuZXJyb3IoZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGxldGUoKSB7XHJcbiAgICAgICAgICB6b25lLnJ1bigoKSA9PiBzaW5rLmNvbXBsZXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBlbnRlclpvbmUgfSBmcm9tICcuL29wZXJhdG9ycy96b25lJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0dXMgb2YgYSBkaXNwYXRjaGVkIGFjdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudW0gQWN0aW9uU3RhdHVzIHtcclxuICBEaXNwYXRjaGVkID0gJ0RJU1BBVENIRUQnLFxyXG4gIFN1Y2Nlc3NmdWwgPSAnU1VDQ0VTU0ZVTCcsXHJcbiAgQ2FuY2VsZWQgPSAnQ0FOQ0VMRUQnLFxyXG4gIEVycm9yZWQgPSAnRVJST1JFRCdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25Db250ZXh0IHtcclxuICBzdGF0dXM6IEFjdGlvblN0YXR1cztcclxuICBhY3Rpb246IGFueTtcclxuICBlcnJvcj86IEVycm9yO1xyXG59XHJcblxyXG4vKipcclxuICogQ3VzdG9tIFN1YmplY3QgdGhhdCBlbnN1cmVzIHRoYXQgc3Vic2NyaWJlcnMgYXJlIG5vdGlmaWVkIG9mIHZhbHVlcyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFycml2ZWQuXHJcbiAqIEEgc3RhbmRhcmQgU3ViamVjdCBkb2VzIG5vdCBoYXZlIHRoaXMgZ3VhcmFudGVlLlxyXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBjb2RlOlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqICAgY29uc3Qgc3ViamVjdCA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcclxuICAgICBzdWJqZWN0LnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICBpZiAodmFsdWUgPT09ICdzdGFydCcpIHN1YmplY3QubmV4dCgnZW5kJyk7XHJcbiAgICAgfSk7XHJcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4geyB9KTtcclxuICAgICBzdWJqZWN0Lm5leHQoJ3N0YXJ0Jyk7XHJcbiAqIGBgYFxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIHN0YW5kYXJkIGBTdWJqZWN0PFQ+YCB0aGUgc2Vjb25kIHN1YnNjcmliZXIgd291bGQgcmVjaWV2ZSBgZW5kYCBhbmQgdGhlbiBgc3RhcnRgLlxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIGBPcmRlcmVkU3ViamVjdDxUPmAgdGhlIHNlY29uZCBzdWJzY3JpYmVyIHdvdWxkIHJlY2lldmUgYHN0YXJ0YCBhbmQgdGhlbiBgZW5kYC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBPcmRlcmVkU3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xyXG4gIHByaXZhdGUgX2l0ZW1RdWV1ZTogVFtdID0gW107XHJcbiAgcHJpdmF0ZSBfYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcblxyXG4gIG5leHQodmFsdWU/OiBUKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fYnVzeVB1c2hpbmdOZXh0KSB7XHJcbiAgICAgIHRoaXMuX2l0ZW1RdWV1ZS51bnNoaWZ0KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYnVzeVB1c2hpbmdOZXh0ID0gdHJ1ZTtcclxuICAgIHN1cGVyLm5leHQodmFsdWUpO1xyXG4gICAgd2hpbGUgKHRoaXMuX2l0ZW1RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHRoaXMuX2l0ZW1RdWV1ZS5wb3AoKTtcclxuICAgICAgc3VwZXIubmV4dChuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEludGVybmFsQWN0aW9ucyBleHRlbmRzIE9yZGVyZWRTdWJqZWN0PEFjdGlvbkNvbnRleHQ+IHt9XHJcblxyXG4vKipcclxuICogQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cclxuICpcclxuICogWW91IGNhbiBsaXN0ZW4gdG8gdGhpcyBpbiBzZXJ2aWNlcyB0byByZWFjdCB3aXRob3V0IHN0b3Jlcy5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEFjdGlvbnMgZXh0ZW5kcyBPYnNlcnZhYmxlPGFueT4ge1xyXG4gIGNvbnN0cnVjdG9yKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIG5nWm9uZTogTmdab25lKSB7XHJcbiAgICBzdXBlcihvYnNlcnZlciA9PiB7XHJcbiAgICAgIGFjdGlvbnMkXHJcbiAgICAgICAgLnBpcGUoZW50ZXJab25lKG5nWm9uZSkpXHJcbiAgICAgICAgLnN1YnNjcmliZShyZXMgPT4gb2JzZXJ2ZXIubmV4dChyZXMpLCBlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSwgKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvbXBvc2VzIGEgYXJyYXkgb2YgZnVuY3Rpb25zIGZyb20gbGVmdCB0byByaWdodC4gRXhhbXBsZTpcclxuICpcclxuICogICAgICBjb21wb3NlKFtmbiwgZmluYWxdKShzdGF0ZSwgYWN0aW9uKTtcclxuICpcclxuICogdGhlbiB0aGUgZnVuY3MgaGF2ZSBhIHNpZ25hdHVyZSBsaWtlOlxyXG4gKlxyXG4gKiAgICAgIGZ1bmN0aW9uIGZuIChzdGF0ZSwgYWN0aW9uLCBuZXh0KSB7XHJcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKCdoZXJlJywgc3RhdGUsIGFjdGlvbiwgbmV4dCk7XHJcbiAqICAgICAgICAgIHJldHVybiBuZXh0KHN0YXRlLCBhY3Rpb24pO1xyXG4gKiAgICAgIH1cclxuICpcclxuICogICAgICBmdW5jdGlvbiBmaW5hbCAoc3RhdGUsIGFjdGlvbikge1xyXG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnaGVyZScsIHN0YXRlLCBhY3Rpb24pO1xyXG4gKiAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAqICAgICAgfVxyXG4gKlxyXG4gKiB0aGUgbGFzdCBmdW5jdGlvbiBzaG91bGQgbm90IGNhbGwgYG5leHRgLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29tcG9zZSA9IGZ1bmNzID0+ICguLi5hcmdzKSA9PiB7XHJcbiAgY29uc3QgY3VyciA9IGZ1bmNzLnNoaWZ0KCk7XHJcbiAgcmV0dXJuIGN1cnIoLi4uYXJncywgKC4uLm5leHRBcmdzKSA9PiBjb21wb3NlKGZ1bmNzKSguLi5uZXh0QXJncykpO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuLyoqXHJcbiAqIEJlaGF2aW9yU3ViamVjdCBvZiB0aGUgZW50aXJlIHN0YXRlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZVN0cmVhbSBleHRlbmRzIEJlaGF2aW9yU3ViamVjdDxhbnk+IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKHt9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmd4c1BsdWdpbkZuLCBOR1hTX1BMVUdJTlMsIE5neHNQbHVnaW4gfSBmcm9tICcuL3N5bWJvbHMnO1xyXG5cclxuLyoqXHJcbiAqIFBsdWdpbiBtYW5hZ2VyIGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFBsdWdpbk1hbmFnZXIge1xyXG4gIHBsdWdpbnM6IE5neHNQbHVnaW5GbltdID0gW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRNYW5hZ2VyOiBQbHVnaW5NYW5hZ2VyLFxyXG4gICAgQEluamVjdChOR1hTX1BMVUdJTlMpXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgcHJpdmF0ZSBfcGx1Z2luczogTmd4c1BsdWdpbltdXHJcbiAgKSB7XHJcbiAgICB0aGlzLnJlZ2lzdGVyKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlZ2lzdGVyKCkge1xyXG4gICAgaWYgKCF0aGlzLl9wbHVnaW5zKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zLm1hcChwbHVnaW4gPT4ge1xyXG4gICAgICBpZiAocGx1Z2luLmhhbmRsZSkge1xyXG4gICAgICAgIHJldHVybiBwbHVnaW4uaGFuZGxlLmJpbmQocGx1Z2luKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGx1Z2luO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fcGFyZW50TWFuYWdlcikge1xyXG4gICAgICB0aGlzLl9wYXJlbnRNYW5hZ2VyLnBsdWdpbnMucHVzaCguLi50aGlzLnBsdWdpbnMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBFcnJvckhhbmRsZXIsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgZm9ya0pvaW4sIGVtcHR5LCBTdWJqZWN0LCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHNoYXJlUmVwbGF5LCBmaWx0ZXIsIGV4aGF1c3RNYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBjb21wb3NlIH0gZnJvbSAnLi4vdXRpbHMvY29tcG9zZSc7XHJcbmltcG9ydCB7IEludGVybmFsQWN0aW9ucywgQWN0aW9uU3RhdHVzLCBBY3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBTdGF0ZVN0cmVhbSB9IGZyb20gJy4vc3RhdGUtc3RyZWFtJztcclxuaW1wb3J0IHsgUGx1Z2luTWFuYWdlciB9IGZyb20gJy4uL3BsdWdpbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgZW50ZXJab25lIH0gZnJvbSAnLi4vb3BlcmF0b3JzL3pvbmUnO1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIEFjdGlvbiByZXN1bHQgc3RyZWFtIHRoYXQgaXMgZW1pdHRlZCB3aGVuIGFuIGFjdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAqIFRoaXMgaXMgdXNlZCBhcyBhIG1ldGhvZCBvZiByZXR1cm5pbmcgdGhlIGFjdGlvbiByZXN1bHQgdG8gdGhlIGRpc3BhdGNoZXJcclxuICogZm9yIHRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGJ5IHRoZSBkaXNwYXRjaCguLi4pIGNhbGwuXHJcbiAqIFRoZSBkaXNwYXRjaGVyIHRoZW4gYXN5bmNocm9ub3VzbHkgcHVzaGVzIHRoZSByZXN1bHQgZnJvbSB0aGlzIHN0cmVhbSBvbnRvIHRoZSBtYWluIGFjdGlvbiBzdHJlYW0gYXMgYSByZXN1bHQuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIGV4dGVuZHMgU3ViamVjdDxBY3Rpb25Db250ZXh0PiB7fVxyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxEaXNwYXRjaGVyIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2Vycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgIHByaXZhdGUgX3BsdWdpbk1hbmFnZXI6IFBsdWdpbk1hbmFnZXIsXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZVxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyBldmVudChzKS5cclxuICAgKi9cclxuICBkaXNwYXRjaChldmVudDogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oZXZlbnQubWFwKGEgPT4gdGhpcy5kaXNwYXRjaFNpbmdsZShhKSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoU2luZ2xlKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmVzdWx0LnN1YnNjcmliZSh7XHJcbiAgICAgIGVycm9yOiBlcnJvciA9PiB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuX2Vycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvcikpXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0LnBpcGUoZW50ZXJab25lKHRoaXMuX25nWm9uZSkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkaXNwYXRjaFNpbmdsZShhY3Rpb246IGFueSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbk1hbmFnZXIucGx1Z2lucztcclxuXHJcbiAgICByZXR1cm4gKGNvbXBvc2UoW1xyXG4gICAgICAuLi5wbHVnaW5zLFxyXG4gICAgICAobmV4dFN0YXRlLCBuZXh0QWN0aW9uKSA9PiB7XHJcbiAgICAgICAgaWYgKG5leHRTdGF0ZSAhPT0gcHJldlN0YXRlKSB7XHJcbiAgICAgICAgICB0aGlzLl9zdGF0ZVN0cmVhbS5uZXh0KG5leHRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjdGlvblJlc3VsdCQgPSB0aGlzLmdldEFjdGlvblJlc3VsdFN0cmVhbShuZXh0QWN0aW9uKTtcclxuICAgICAgICBhY3Rpb25SZXN1bHQkLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9ucy5uZXh0KGN0eCkpO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMubmV4dCh7IGFjdGlvbjogbmV4dEFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEaXNwYXRjaE9ic2VydmFibGUoYWN0aW9uUmVzdWx0JCk7XHJcbiAgICAgIH1cclxuICAgIF0pKHByZXZTdGF0ZSwgYWN0aW9uKSBhcyBPYnNlcnZhYmxlPGFueT4pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEFjdGlvblJlc3VsdFN0cmVhbShhY3Rpb246IGFueSk6IE9ic2VydmFibGU8QWN0aW9uQ29udGV4dD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGlvblJlc3VsdHMucGlwZShcclxuICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5hY3Rpb24gPT09IGFjdGlvbiAmJiBjdHguc3RhdHVzICE9PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgIHRha2UoMSksXHJcbiAgICAgIHNoYXJlUmVwbGF5KClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZURpc3BhdGNoT2JzZXJ2YWJsZShhY3Rpb25SZXN1bHQkOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiBhY3Rpb25SZXN1bHQkXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGV4aGF1c3RNYXAoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4ge1xyXG4gICAgICAgICAgc3dpdGNoIChjdHguc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWw6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG9mKHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICBjYXNlIEFjdGlvblN0YXR1cy5FcnJvcmVkOlxyXG4gICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGN0eC5lcnJvcik7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKVxyXG4gICAgICAucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIE9iamVjdCBmcmVlemUgY29kZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNkZi9kZWVwLWZyZWV6ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRlZXBGcmVlemUgPSBvID0+IHtcclxuICBPYmplY3QuZnJlZXplKG8pO1xyXG5cclxuICBjb25zdCBvSXNGdW5jdGlvbiA9IHR5cGVvZiBvID09PSAnZnVuY3Rpb24nO1xyXG4gIGNvbnN0IGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuICAgIGlmIChcclxuICAgICAgaGFzT3duUHJvcC5jYWxsKG8sIHByb3ApICYmXHJcbiAgICAgIChvSXNGdW5jdGlvbiA/IHByb3AgIT09ICdjYWxsZXInICYmIHByb3AgIT09ICdjYWxsZWUnICYmIHByb3AgIT09ICdhcmd1bWVudHMnIDogdHJ1ZSkgJiZcclxuICAgICAgb1twcm9wXSAhPT0gbnVsbCAmJlxyXG4gICAgICAodHlwZW9mIG9bcHJvcF0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvW3Byb3BdID09PSAnZnVuY3Rpb24nKSAmJlxyXG4gICAgICAhT2JqZWN0LmlzRnJvemVuKG9bcHJvcF0pXHJcbiAgICApIHtcclxuICAgICAgZGVlcEZyZWV6ZShvW3Byb3BdKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG87XHJcbn07XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIGlzRGV2TW9kZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVGVzdEJlZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvdGVzdGluZyc7XHJcblxyXG5pbXBvcnQgeyBTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgZGVlcEZyZWV6ZSB9IGZyb20gJy4uL3V0aWxzL2ZyZWV6ZSc7XHJcblxyXG4vKipcclxuICogU3RhdGUgQ29udGV4dCBmYWN0b3J5IGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEludGVybmFsU3RhdGVPcGVyYXRpb25zIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX3N0YXRlU3RyZWFtOiBTdGF0ZVN0cmVhbSxcclxuICAgIHByaXZhdGUgX2Rpc3BhdGNoZXI6IEludGVybmFsRGlzcGF0Y2hlcixcclxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcclxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3Rlc3RCZWQ6IFRlc3RCZWRcclxuICApIHtcclxuICAgIHRoaXMudmVyaWZ5RGV2TW9kZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcm9vdCBzdGF0ZSBvcGVyYXRvcnMuXHJcbiAgICovXHJcbiAgZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpOiBTdGF0ZU9wZXJhdGlvbnM8YW55PiB7XHJcbiAgICBjb25zdCByb290U3RhdGVPcGVyYXRpb25zID0ge1xyXG4gICAgICBnZXRTdGF0ZTogKCkgPT4gdGhpcy5fc3RhdGVTdHJlYW0uZ2V0VmFsdWUoKSxcclxuICAgICAgc2V0U3RhdGU6IG5ld1N0YXRlID0+IHRoaXMuX3N0YXRlU3RyZWFtLm5leHQobmV3U3RhdGUpLFxyXG4gICAgICBkaXNwYXRjaDogYWN0aW9ucyA9PiB0aGlzLl9kaXNwYXRjaGVyLmRpc3BhdGNoKGFjdGlvbnMpXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLl9jb25maWcuZGV2ZWxvcG1lbnRNb2RlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVuc3VyZVN0YXRlQW5kQWN0aW9uc0FyZUltbXV0YWJsZShyb290U3RhdGVPcGVyYXRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm9vdFN0YXRlT3BlcmF0aW9ucztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdmVyaWZ5RGV2TW9kZSgpIHtcclxuICAgIGNvbnN0IGlzVGVzdE1vZGUgPSB0aGlzLl90ZXN0QmVkICE9PSBudWxsO1xyXG4gICAgaWYgKGlzVGVzdE1vZGUpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBpc05neHNEZXZNb2RlID0gdGhpcy5fY29uZmlnLmRldmVsb3BtZW50TW9kZTtcclxuICAgIGNvbnN0IGlzTmdEZXZNb2RlID0gaXNEZXZNb2RlKCk7XHJcbiAgICBjb25zdCBpbmNvcnJlY3RQcm9kdWN0aW9uID0gIWlzTmdEZXZNb2RlICYmIGlzTmd4c0Rldk1vZGU7XHJcbiAgICBjb25zdCBpbmNvcnJlY3REZXZlbG9wbWVudCA9IGlzTmdEZXZNb2RlICYmICFpc05neHNEZXZNb2RlO1xyXG4gICAgY29uc3QgZXhhbXBsZSA9ICdOZ3hzTW9kdWxlLmZvclJvb3Qoc3RhdGVzLCB7IGRldmVsb3BtZW50TW9kZTogIWVudmlyb25tZW50LnByb2R1Y3Rpb24gfSknO1xyXG5cclxuICAgIGlmIChpbmNvcnJlY3RQcm9kdWN0aW9uKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnQW5ndWxhciBpcyBydW5uaW5nIGluIHByb2R1Y3Rpb24gbW9kZSBidXQgTkdYUyBpcyBzdGlsbCBydW5uaW5nIGluIHRoZSBkZXZlbG9wbWVudCBtb2RlIVxcbicsXHJcbiAgICAgICAgJ1BsZWFzZSBzZXQgZGV2ZWxvcG1lbnRNb2RlIHRvIGZhbHNlIG9uIHRoZSBOZ3hzTW9kdWxlIG9wdGlvbnMgd2hlbiBpbiBwcm9kdWN0aW9uIG1vZGUuXFxuJyxcclxuICAgICAgICBleGFtcGxlXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2UgaWYgKGluY29ycmVjdERldmVsb3BtZW50KSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnUkVDT01NRU5EQVRJT046IFNldCBkZXZlbG9wbWVudE1vZGUgdG8gdHJ1ZSBvbiB0aGUgTmd4c01vZHVsZSB3aGVuIEFuZ3VsYXIgaXMgcnVubmluZyBpbiBkZXZlbG9wbWVudCBtb2RlLlxcbicsXHJcbiAgICAgICAgZXhhbXBsZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBlbnN1cmVTdGF0ZUFuZEFjdGlvbnNBcmVJbW11dGFibGUocm9vdDogU3RhdGVPcGVyYXRpb25zPGFueT4pOiBTdGF0ZU9wZXJhdGlvbnM8YW55PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnZXRTdGF0ZTogKCkgPT4gcm9vdC5nZXRTdGF0ZSgpLFxyXG4gICAgICBzZXRTdGF0ZTogdmFsdWUgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyb3plblZhbHVlID0gZGVlcEZyZWV6ZSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJvb3Quc2V0U3RhdGUoZnJvemVuVmFsdWUpO1xyXG4gICAgICB9LFxyXG4gICAgICBkaXNwYXRjaDogYWN0aW9ucyA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHJvb3QuZGlzcGF0Y2goYWN0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHsgU3RhdGVDb250ZXh0IH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IE1hcHBlZFN0b3JlIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgc2V0VmFsdWUsIGdldFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMnO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIENvbnRleHQgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZUNvbnRleHRGYWN0b3J5IHtcclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pbnRlcm5hbFN0YXRlT3BlcmF0aW9uczogSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgc3RhdGUgY29udGV4dFxyXG4gICAqL1xyXG4gIGNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YTogTWFwcGVkU3RvcmUpOiBTdGF0ZUNvbnRleHQ8YW55PiB7XHJcbiAgICBjb25zdCByb290ID0gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0U3RhdGUoKTogYW55IHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcclxuICAgICAgICByZXR1cm4gZ2V0VmFsdWUoc3RhdGUsIG1ldGFkYXRhLmRlcHRoKTtcclxuICAgICAgfSxcclxuICAgICAgcGF0Y2hTdGF0ZSh2YWw6IGFueSk6IGFueSB7XHJcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsKTtcclxuICAgICAgICBjb25zdCBpc1ByaW1pdGl2ZSA9IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnO1xyXG5cclxuICAgICAgICBpZiAoaXNBcnJheSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRjaGluZyBhcnJheXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGNoaW5nIHByaW1pdGl2ZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gcm9vdC5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsID0gZ2V0VmFsdWUoc3RhdGUsIG1ldGFkYXRhLmRlcHRoKTtcclxuICAgICAgICBjb25zdCBjbG9uZSA9IHsgLi4ubG9jYWwgfTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHZhbCkge1xyXG4gICAgICAgICAgY2xvbmVba10gPSB2YWxba107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHNldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCwgY2xvbmUpO1xyXG4gICAgICAgIHJvb3Quc2V0U3RhdGUobmV3U3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0U3RhdGUodmFsOiBhbnkpOiBhbnkge1xyXG4gICAgICAgIGxldCBzdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcclxuICAgICAgICBzdGF0ZSA9IHNldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCwgdmFsKTtcclxuICAgICAgICByb290LnNldFN0YXRlKHN0YXRlKTtcclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgIH0sXHJcbiAgICAgIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgICAgICByZXR1cm4gcm9vdC5kaXNwYXRjaChhY3Rpb25zKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0b3IsIEluamVjdGFibGUsIFNraXBTZWxmLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgZm9ya0pvaW4sIGZyb20sIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgc2hhcmVSZXBsYXksIHRha2VVbnRpbCwgbWFwLCBjYXRjaEVycm9yLCBmaWx0ZXIsIG1lcmdlTWFwLCBkZWZhdWx0SWZFbXB0eSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzTGlmZUN5Y2xlLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7XHJcbiAgdG9wb2xvZ2ljYWxTb3J0LFxyXG4gIGJ1aWxkR3JhcGgsXHJcbiAgZmluZEZ1bGxQYXJlbnRQYXRoLFxyXG4gIG5hbWVUb1N0YXRlLFxyXG4gIHByb3BHZXR0ZXIsXHJcbiAgaXNPYmplY3QsXHJcbiAgU3RhdGVDbGFzcyxcclxuICBNYXBwZWRTdG9yZVxyXG59IGZyb20gJy4vaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZSwgc2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbEFjdGlvbnMsIEFjdGlvblN0YXR1cywgQWN0aW9uQ29udGV4dCB9IGZyb20gJy4uL2FjdGlvbnMtc3RyZWFtJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyB9IGZyb20gJy4uL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtY29udGV4dC1mYWN0b3J5JztcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBmYWN0b3J5IGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFN0YXRlRmFjdG9yeSB7XHJcbiAgZ2V0IHN0YXRlcygpOiBNYXBwZWRTdG9yZVtdIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXMgOiB0aGlzLl9zdGF0ZXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zdGF0ZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcclxuICBwcml2YXRlIF9jb25uZWN0ZWQgPSBmYWxzZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXHJcbiAgICBwcml2YXRlIF9jb25maWc6IE5neHNDb25maWcsXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgQFNraXBTZWxmKClcclxuICAgIHByaXZhdGUgX3BhcmVudEZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcclxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcclxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXHJcbiAgICBwcml2YXRlIF9zdGF0ZUNvbnRleHRGYWN0b3J5OiBTdGF0ZUNvbnRleHRGYWN0b3J5XHJcbiAgKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBuZXcgc3RhdGUgdG8gdGhlIGdsb2JhbCBkZWZzLlxyXG4gICAqL1xyXG4gIGFkZChvbmVPck1hbnlTdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3MgfCBTdGF0ZUNsYXNzW10pOiBNYXBwZWRTdG9yZVtdIHtcclxuICAgIGxldCBzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NbXTtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShvbmVPck1hbnlTdGF0ZUNsYXNzZXMpKSB7XHJcbiAgICAgIHN0YXRlQ2xhc3NlcyA9IFtvbmVPck1hbnlTdGF0ZUNsYXNzZXNdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhdGVDbGFzc2VzID0gb25lT3JNYW55U3RhdGVDbGFzc2VzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXRlR3JhcGggPSBidWlsZEdyYXBoKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBjb25zdCBzb3J0ZWRTdGF0ZXMgPSB0b3BvbG9naWNhbFNvcnQoc3RhdGVHcmFwaCk7XHJcbiAgICBjb25zdCBkZXB0aHMgPSBmaW5kRnVsbFBhcmVudFBhdGgoc3RhdGVHcmFwaCk7XHJcbiAgICBjb25zdCBuYW1lR3JhcGggPSBuYW1lVG9TdGF0ZShzdGF0ZUNsYXNzZXMpO1xyXG4gICAgY29uc3QgbWFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZFN0YXRlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZUNsYXNzID0gbmFtZUdyYXBoW25hbWVdO1xyXG5cclxuICAgICAgaWYgKCFzdGF0ZUNsYXNzW01FVEFfS0VZXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGVzIG11c3QgYmUgZGVjb3JhdGVkIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRlcHRoID0gZGVwdGhzW25hbWVdO1xyXG4gICAgICBjb25zdCB7IGFjdGlvbnMgfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldO1xyXG4gICAgICBsZXQgeyBkZWZhdWx0cyB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcblxyXG4gICAgICBzdGF0ZUNsYXNzW01FVEFfS0VZXS5wYXRoID0gZGVwdGg7XHJcbiAgICAgIHN0YXRlQ2xhc3NbTUVUQV9LRVldLnNlbGVjdEZyb21BcHBTdGF0ZSA9IHByb3BHZXR0ZXIoZGVwdGguc3BsaXQoJy4nKSwgdGhpcy5fY29uZmlnKTtcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxyXG4gICAgICAvLyBidXQgZG9udCB0aHJvdyBzaW5jZSBpdCBjb3VsZCBiZSBsYXp5XHJcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xyXG4gICAgICBjb25zdCBoYXMgPSB0aGlzLnN0YXRlcy5maW5kKHMgPT4gcy5uYW1lID09PSBuYW1lKTtcclxuICAgICAgaWYgKCFoYXMpIHtcclxuICAgICAgICAvLyBjcmVhdGUgbmV3IGluc3RhbmNlIG9mIGRlZmF1bHRzXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XHJcbiAgICAgICAgICBkZWZhdWx0cyA9IFsuLi5kZWZhdWx0c107XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZhdWx0cykpIHtcclxuICAgICAgICAgIGRlZmF1bHRzID0geyAuLi5kZWZhdWx0cyB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgZGVmYXVsdHMgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpO1xyXG5cclxuICAgICAgICBtYXBwZWRTdG9yZXMucHVzaCh7XHJcbiAgICAgICAgICBhY3Rpb25zLFxyXG4gICAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgICBkZWZhdWx0cyxcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBkZXB0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGF0ZXMucHVzaCguLi5tYXBwZWRTdG9yZXMpO1xyXG5cclxuICAgIHJldHVybiBtYXBwZWRTdG9yZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBzZXQgb2Ygc3RhdGVzIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIHRoZSBkZWZhdWxzdHNcclxuICAgKi9cclxuICBhZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZUNsYXNzZXM6IGFueVtdKTogeyBkZWZhdWx0czogYW55OyBzdGF0ZXM6IE1hcHBlZFN0b3JlW10gfSB7XHJcbiAgICBpZiAoc3RhdGVDbGFzc2VzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlcyA9IHRoaXMuYWRkKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3RhdGVzLnJlZHVjZShcclxuICAgICAgICAocmVzdWx0OiBhbnksIG1ldGE6IE1hcHBlZFN0b3JlKSA9PiBzZXRWYWx1ZShyZXN1bHQsIG1ldGEuZGVwdGgsIG1ldGEuZGVmYXVsdHMpLFxyXG4gICAgICAgIHt9XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiB7IGRlZmF1bHRzLCBzdGF0ZXMgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgdGhlIGFjdGlvbnMgdG8gdGhlIGhhbmRsZXJzXHJcbiAgICovXHJcbiAgY29ubmVjdEFjdGlvbkhhbmRsZXJzKCkge1xyXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkgcmV0dXJuO1xyXG4gICAgdGhpcy5fYWN0aW9uc1xyXG4gICAgICAucGlwZShcclxuICAgICAgICBmaWx0ZXIoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4gY3R4LnN0YXR1cyA9PT0gQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQpLFxyXG4gICAgICAgIG1lcmdlTWFwKCh7IGFjdGlvbiB9KSA9PlxyXG4gICAgICAgICAgdGhpcy5pbnZva2VBY3Rpb25zKHRoaXMuX2FjdGlvbnMsIGFjdGlvbikucGlwZShcclxuICAgICAgICAgICAgbWFwKCgpID0+IDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsIH0pLFxyXG4gICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSg8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQgfSksXHJcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyb3IgPT4gb2YoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkVycm9yZWQsIGVycm9yIH0pKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgICAuc3Vic2NyaWJlKGN0eCA9PiB0aGlzLl9hY3Rpb25SZXN1bHRzLm5leHQoY3R4KSk7XHJcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlIHRoZSBpbml0IGZ1bmN0aW9uIG9uIHRoZSBzdGF0ZXMuXHJcbiAgICovXHJcbiAgaW52b2tlSW5pdChzdGF0ZU1ldGFkYXRhczogTWFwcGVkU3RvcmVbXSkge1xyXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiBzdGF0ZU1ldGFkYXRhcykge1xyXG4gICAgICBjb25zdCBpbnN0YW5jZTogTmd4c0xpZmVDeWNsZSA9IG1ldGFkYXRhLmluc3RhbmNlO1xyXG5cclxuICAgICAgaWYgKGluc3RhbmNlLm5neHNPbkluaXQpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgICAgICAgaW5zdGFuY2Uubmd4c09uSW5pdChzdGF0ZUNvbnRleHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2UgYWN0aW9ucyBvbiB0aGUgc3RhdGVzLlxyXG4gICAqL1xyXG4gIGludm9rZUFjdGlvbnMoYWN0aW9ucyQ6IEludGVybmFsQWN0aW9ucywgYWN0aW9uKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiB0aGlzLnN0YXRlcykge1xyXG4gICAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pO1xyXG4gICAgICBjb25zdCBhY3Rpb25NZXRhcyA9IG1ldGFkYXRhLmFjdGlvbnNbdHlwZV07XHJcblxyXG4gICAgICBpZiAoYWN0aW9uTWV0YXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk1ldGEgb2YgYWN0aW9uTWV0YXMpIHtcclxuICAgICAgICAgIGNvbnN0IHN0YXRlQ29udGV4dCA9IHRoaXMuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YS5pbnN0YW5jZVthY3Rpb25NZXRhLmZuXShzdGF0ZUNvbnRleHQsIGFjdGlvbik7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZyb20ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcclxuICAgICAgICAgICAgICAgIGFjdGlvbk1ldGEub3B0aW9ucy5jYW5jZWxVbmNvbXBsZXRlZFxyXG4gICAgICAgICAgICAgICAgICA/IHRha2VVbnRpbChhY3Rpb25zJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChhY3Rpb24pKSlcclxuICAgICAgICAgICAgICAgICAgOiBtYXAociA9PiByKVxyXG4gICAgICAgICAgICAgICk7IC8vIG1hcCBhY3RzIGxpa2UgYSBub29wXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gb2Yoe30pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhyb3dFcnJvcihlKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xyXG4gICAgICByZXN1bHRzLnB1c2gob2Yoe30pKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9ya0pvaW4ocmVzdWx0cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIHN0YXRlIGNvbnRleHRcclxuICAgKi9cclxuICBwcml2YXRlIGNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YTogTWFwcGVkU3RvcmUpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUNvbnRleHRGYWN0b3J5LmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgfVxyXG59XHJcbiIsImZ1bmN0aW9uIGRlZmF1bHRFcXVhbGl0eUNoZWNrKGE6IGFueSwgYjogYW55KSB7XHJcbiAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKFxyXG4gIGVxdWFsaXR5Q2hlY2s6IChhOiBhbnksIGI6IGFueSkgPT4gYm9vbGVhbixcclxuICBwcmV2OiBJQXJndW1lbnRzIHwgbnVsbCxcclxuICBuZXh0OiBJQXJndW1lbnRzIHwgbnVsbFxyXG4pIHtcclxuICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cclxuICBjb25zdCBsZW5ndGggPSBwcmV2Lmxlbmd0aDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZW1vaXplIGEgZnVuY3Rpb24gb24gaXRzIGxhc3QgaW5wdXRzIG9ubHkuXHJcbiAqIE9yaW5naW5hbGx5IGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3Jlc2VsZWN0L2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZTxSLCBUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSPihmdW5jOiBULCBlcXVhbGl0eUNoZWNrID0gZGVmYXVsdEVxdWFsaXR5Q2hlY2spOiBUIHtcclxuICBsZXQgbGFzdEFyZ3M6IElBcmd1bWVudHMgfCBudWxsID0gbnVsbDtcclxuICBsZXQgbGFzdFJlc3VsdDogYW55ID0gbnVsbDtcclxuICAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcclxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcclxuICAgIGlmICghYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwoZXF1YWxpdHlDaGVjaywgbGFzdEFyZ3MsIGFyZ3VtZW50cykpIHtcclxuICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGZvciBwZXJmb3JtYW5jZS5cclxuICAgICAgbGFzdFJlc3VsdCA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcclxuICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gIH1cclxuICAoPGFueT5tZW1vaXplZCkucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIFRoZSBoaWRkZW4gKGZvciBub3cpIGFiaWxpdHkgdG8gcmVzZXQgdGhlIG1lbW9pemF0aW9uXHJcbiAgICBsYXN0QXJncyA9IG51bGw7XHJcbiAgICBsYXN0UmVzdWx0ID0gbnVsbDtcclxuICB9O1xyXG4gIHJldHVybiBtZW1vaXplZCBhcyBUO1xyXG59XHJcbiIsImltcG9ydCB7IFNlbGVjdEZyb21TdGF0ZSwgZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSwgZ2V0U2VsZWN0b3JNZXRhZGF0YSwgZ2V0U3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlscy9tZW1vaXplJztcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBzZWxlY3RvclxyXG4gKiBAcGFyYW0gc2VsZWN0b3JzIFRoZSBzZWxlY3RvcnMgdG8gdXNlIHRvIGNyZWF0ZSB0aGUgYXJndW1lbnRzIG9mIHRoaXMgZnVuY3Rpb25cclxuICogQHBhcmFtIG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGJlaW5nIG1hZGUgaW50byBhIHNlbGVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoXHJcbiAgc2VsZWN0b3JzOiBhbnlbXSxcclxuICBvcmlnaW5hbEZuOiBhbnksXHJcbiAgY3JlYXRpb25NZXRhZGF0YT86IHsgY29udGFpbmVyQ2xhc3M6IGFueTsgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfVxyXG4pIHtcclxuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkU2VsZWN0b3JGbiguLi5hcmdzKSB7XHJcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9yaWdpbmFsRm4oLi4uYXJncyk7XHJcbiAgICBpZiAocmV0dXJuVmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICBjb25zdCBpbm5lck1lbW9pemVkRm4gPSBtZW1vaXplLmFwcGx5KG51bGwsIFtyZXR1cm5WYWx1ZV0pO1xyXG4gICAgICByZXR1cm4gaW5uZXJNZW1vaXplZEZuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gIH07XHJcbiAgY29uc3QgbWVtb2l6ZWRGbiA9IG1lbW9pemUod3JhcHBlZEZuKTtcclxuICBjb25zdCBjb250YWluZXJDbGFzcyA9IGNyZWF0aW9uTWV0YWRhdGEgJiYgY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuXHJcbiAgY29uc3QgZm4gPSBzdGF0ZSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0b3JzVG9BcHBseSA9IFtdO1xyXG5cclxuICAgIGlmIChjb250YWluZXJDbGFzcykge1xyXG4gICAgICAvLyBJZiB3ZSBhcmUgb24gYSBzdGF0ZSBjbGFzcywgYWRkIGl0IGFzIHRoZSBmaXJzdCBzZWxlY3RvciBwYXJhbWV0ZXJcclxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBnZXRTdG9yZU1ldGFkYXRhKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgaWYgKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlbGVjdG9ycykge1xyXG4gICAgICBzZWxlY3RvcnNUb0FwcGx5LnB1c2goLi4uc2VsZWN0b3JzKTtcclxuICAgIH1cclxuICAgIC8vIERldGVybWluZSBhcmd1bWVudHMgZnJvbSB0aGUgYXBwIHN0YXRlIHVzaW5nIHRoZSBzZWxlY3RvcnNcclxuICAgIGlmIChzZWxlY3RvcnNUb0FwcGx5KSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaCguLi5zZWxlY3RvcnNUb0FwcGx5Lm1hcChhID0+IGdldFNlbGVjdG9yRm4oYSkoc3RhdGUpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlIGxhbWJkYSB0cmllcyB0byBhY2Nlc3MgYSBzb21ldGhpbmcgb24gdGhlXHJcbiAgICAvLyBzdGF0ZSB0aGF0IGRvZXNuJ3QgZXhpc3QsIGl0IHdpbGwgdGhyb3cgYSBUeXBlRXJyb3IuXHJcbiAgICAvLyBzaW5jZSB0aGlzIGlzIHF1aXRlIHVzdWFsIGJlaGF2aW91ciwgd2Ugc2ltcGx5IHJldHVybiB1bmRlZmluZWQgaWYgc28uXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gbWVtb2l6ZWRGbiguLi5yZXN1bHRzKTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXg7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc2VsZWN0b3JNZXRhRGF0YSA9IGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEobWVtb2l6ZWRGbik7XHJcbiAgc2VsZWN0b3JNZXRhRGF0YS5vcmlnaW5hbEZuID0gb3JpZ2luYWxGbjtcclxuICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdEZyb21BcHBTdGF0ZSA9IGZuO1xyXG4gIGlmIChjcmVhdGlvbk1ldGFkYXRhKSB7XHJcbiAgICBzZWxlY3Rvck1ldGFEYXRhLmNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuICAgIHNlbGVjdG9yTWV0YURhdGEuc2VsZWN0b3JOYW1lID0gY3JlYXRpb25NZXRhZGF0YS5zZWxlY3Rvck5hbWU7XHJcbiAgfVxyXG4gIHJldHVybiBtZW1vaXplZEZuO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIGdldCB0aGUgc2VsZWN0ZWQgc2xpY2UgZnJvbSB0aGUgYXBwIHN0YXRlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvckZuKHNlbGVjdG9yOiBhbnkpOiBTZWxlY3RGcm9tU3RhdGUge1xyXG4gIGNvbnN0IG1ldGFkYXRhID0gZ2V0U2VsZWN0b3JNZXRhZGF0YShzZWxlY3RvcikgfHwgZ2V0U3RvcmVNZXRhZGF0YShzZWxlY3Rvcik7XHJcbiAgcmV0dXJuIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5zZWxlY3RGcm9tQXBwU3RhdGUpIHx8IHNlbGVjdG9yO1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBnZXRTZWxlY3RvckZuIH0gZnJvbSAnLi91dGlscy9zZWxlY3Rvci11dGlscyc7XHJcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1vcGVyYXRpb25zJztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IGVudGVyWm9uZSB9IGZyb20gJy4vb3BlcmF0b3JzL3pvbmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RvcmUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9pbnRlcm5hbFN0YXRlT3BlcmF0aW9uczogSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnNcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgZXZlbnQocykuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goZXZlbnQ6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuZGlzcGF0Y2goZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0cyBhIHNsaWNlIG9mIGRhdGEgZnJvbSB0aGUgc3RvcmUuXHJcbiAgICovXHJcbiAgc2VsZWN0PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IE9ic2VydmFibGU8VD47XHJcbiAgc2VsZWN0KHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgc2VsZWN0KHNlbGVjdG9yOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3Qgc2VsZWN0b3JGbiA9IGdldFNlbGVjdG9yRm4oc2VsZWN0b3IpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlU3RyZWFtLnBpcGUoXHJcbiAgICAgIG1hcChzZWxlY3RvckZuKSxcclxuICAgICAgY2F0Y2hFcnJvcihlcnIgPT4ge1xyXG4gICAgICAgIC8vIGlmIGVycm9yIGlzIFR5cGVFcnJvciB3ZSBzd2FsbG93IGl0IHRvIHByZXZlbnQgdXN1YWwgZXJyb3JzIHdpdGggcHJvcGVydHkgYWNjZXNzXHJcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXRocm93IG90aGVyIGVycm9yc1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfSksXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgIGVudGVyWm9uZSh0aGlzLl9uZ1pvbmUpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0IG9uZSBzbGljZSBvZiBkYXRhIGZyb20gdGhlIHN0b3JlLlxyXG4gICAqL1xyXG4gIHNlbGVjdE9uY2U8VD4oc2VsZWN0b3I6IChzdGF0ZTogYW55LCAuLi5zdGF0ZXM6IGFueVtdKSA9PiBUKTogT2JzZXJ2YWJsZTxUPjtcclxuICBzZWxlY3RPbmNlKHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgc2VsZWN0T25jZShzZWxlY3RvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLnNlbGVjdChzZWxlY3RvcikucGlwZSh0YWtlKDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBhIHNuYXBzaG90IGZyb20gdGhlIHN0YXRlLlxyXG4gICAqL1xyXG4gIHNlbGVjdFNuYXBzaG90PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IFQ7XHJcbiAgc2VsZWN0U25hcHNob3Qoc2VsZWN0b3I6IHN0cmluZyB8IGFueSk6IGFueTtcclxuICBzZWxlY3RTbmFwc2hvdChzZWxlY3RvcjogYW55KTogYW55IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSBnZXRTZWxlY3RvckZuKHNlbGVjdG9yKTtcclxuICAgIHJldHVybiBzZWxlY3RvckZuKHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gc3Vic2NyaWJlIHRvIHRoZSByb290IG9mIHRoZSBzdGF0ZVxyXG4gICAqL1xyXG4gIHN1YnNjcmliZShmbj86IGFueSk6IFN1YnNjcmlwdGlvbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVTdHJlYW0ucGlwZShlbnRlclpvbmUodGhpcy5fbmdab25lKSkuc3Vic2NyaWJlKGZuKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICBzbmFwc2hvdCgpOiBhbnkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5nZXRTdGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZS4gVGhpcyBtZXRob2QgaXMgdXNlZnVsXHJcbiAgICogZm9yIHBsdWdpbidzIHdobyBuZWVkIHRvIG1vZGlmeSB0aGUgc3RhdGUgZGlyZWN0bHkgb3IgdW5pdCB0ZXN0aW5nLlxyXG4gICAqL1xyXG4gIHJlc2V0KHN0YXRlOiBhbnkpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuc2V0U3RhdGUoc3RhdGUpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4uL3N0b3JlJztcclxuaW1wb3J0IHsgcHJvcEdldHRlciB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcblxyXG4vKipcclxuICogQWxsb3dzIHRoZSBzZWxlY3QgZGVjb3JhdG9yIHRvIGdldCBhY2Nlc3MgdG8gdGhlIERJIHN0b3JlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RGYWN0b3J5IHtcclxuICBzdGF0aWMgc3RvcmU6IFN0b3JlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gIHN0YXRpYyBjb25maWc6IE5neHNDb25maWcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgY29uc3RydWN0b3Ioc3RvcmU6IFN0b3JlLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICAgIFNlbGVjdEZhY3Rvcnkuc3RvcmUgPSBzdG9yZTtcclxuICAgIFNlbGVjdEZhY3RvcnkuY29uZmlnID0gY29uZmlnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciBmb3Igc2VsZWN0aW5nIGEgc2xpY2Ugb2Ygc3RhdGUgZnJvbSB0aGUgc3RvcmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0KHNlbGVjdG9yT3JGZWF0dXJlPywgLi4ucGF0aHM6IHN0cmluZ1tdKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm5OYW1lID0gJ19fJyArIG5hbWUgKyAnX19zZWxlY3Rvcic7XHJcblxyXG4gICAgaWYgKCFzZWxlY3Rvck9yRmVhdHVyZSkge1xyXG4gICAgICAvLyBpZiBmb28kID0+IG1ha2UgaXQganVzdCBmb29cclxuICAgICAgc2VsZWN0b3JPckZlYXR1cmUgPSBuYW1lLmxhc3RJbmRleE9mKCckJykgPT09IG5hbWUubGVuZ3RoIC0gMSA/IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSkgOiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNyZWF0ZVNlbGVjdCA9IGZuID0+IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBTZWxlY3RGYWN0b3J5LnN0b3JlO1xyXG5cclxuICAgICAgaWYgKCFzdG9yZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0RmFjdG9yeSBub3QgY29ubmVjdGVkIHRvIHN0b3JlIScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RvcmUuc2VsZWN0KGZuKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY3JlYXRlU2VsZWN0b3IgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IFNlbGVjdEZhY3RvcnkuY29uZmlnO1xyXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yT3JGZWF0dXJlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHByb3BzQXJyYXkgPSBwYXRocy5sZW5ndGggPyBbc2VsZWN0b3JPckZlYXR1cmUsIC4uLnBhdGhzXSA6IHNlbGVjdG9yT3JGZWF0dXJlLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wR2V0dGVyKHByb3BzQXJyYXksIGNvbmZpZyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3JPckZlYXR1cmVbTUVUQV9LRVldICYmIHNlbGVjdG9yT3JGZWF0dXJlW01FVEFfS0VZXS5wYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BHZXR0ZXIoc2VsZWN0b3JPckZlYXR1cmVbTUVUQV9LRVldLnBhdGguc3BsaXQoJy4nKSwgY29uZmlnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VsZWN0b3JPckZlYXR1cmU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRhcmdldFtzZWxlY3RvckZuTmFtZV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBAU2VsZWN0IGRlY29yYXRvciBhbmQgYSAnICsgc2VsZWN0b3JGbk5hbWUgKyAnIHByb3BlcnR5LicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkZWxldGUgdGFyZ2V0W25hbWVdKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHNlbGVjdG9yRm5OYW1lLCB7XHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpc1tzZWxlY3RvckZuTmFtZV0gfHwgKHRoaXNbc2VsZWN0b3JGbk5hbWVdID0gY3JlYXRlU2VsZWN0LmFwcGx5KHRoaXMsIFtjcmVhdGVTZWxlY3RvcigpXSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iLCIvKipcclxuICogSW5pdCBhY3Rpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbml0U3RhdGUge1xyXG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuICAgIC8vIE5PVEU6IE5vdCBuZWNlc3NhcnkgdG8gZGVjbGFyZSB0aGUgdHlwZSBpbiB0aGlzIHdheSBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4cy9zdG9yZS9wdWxsLzY0NCNpc3N1ZWNvbW1lbnQtNDM2MDAzMTM4XHJcbiAgICByZXR1cm4gJ0BASU5JVCc7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIGFjdGlvblxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFVwZGF0ZVN0YXRlIHtcclxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcbiAgICAvLyBOT1RFOiBOb3QgbmVjZXNzYXJ5IHRvIGRlY2xhcmUgdGhlIHR5cGUgaW4gdGhpcyB3YXkgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25neHMvc3RvcmUvcHVsbC82NDQjaXNzdWVjb21tZW50LTQzNjAwMzEzOFxyXG4gICAgcmV0dXJuICdAQFVQREFURV9TVEFURSc7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBPcHRpb25hbCwgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgUk9PVF9TVEFURV9UT0tFTiwgRkVBVFVSRV9TVEFURV9UT0tFTiwgTmd4c0NvbmZpZyB9IGZyb20gJy4vc3ltYm9scyc7XHJcbmltcG9ydCB7IFN0YXRlRmFjdG9yeSB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtZmFjdG9yeSc7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcbmltcG9ydCB7IEFjdGlvbnMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZXIsIEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnLi9zdG9yZSc7XHJcbmltcG9ydCB7IFNlbGVjdEZhY3RvcnkgfSBmcm9tICcuL2RlY29yYXRvcnMvc2VsZWN0JztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuL3BsdWdpbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgSW5pdFN0YXRlLCBVcGRhdGVTdGF0ZSB9IGZyb20gJy4vYWN0aW9ucy9hY3Rpb25zJztcclxuXHJcbi8qKlxyXG4gKiBSb290IG1vZHVsZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ATmdNb2R1bGUoKVxyXG5leHBvcnQgY2xhc3MgTmd4c1Jvb3RNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgc2VsZWN0OiBTZWxlY3RGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoUk9PVF9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogYW55W11cclxuICApIHtcclxuICAgIC8vIGFkZCBzdG9yZXMgdG8gdGhlIHN0YXRlIGdyYXBoIGFuZCByZXR1cm4gdGhlaXIgZGVmYXVsdHNcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBmYWN0b3J5LmFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlcyk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGVPcGVyYXRpb25zID0gaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xyXG4gICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgLy8gZ2V0IG91ciBjdXJyZW50IHN0cmVhbVxyXG4gICAgICBjb25zdCBjdXIgPSBzdGF0ZU9wZXJhdGlvbnMuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIC8vIHNldCB0aGUgc3RhdGUgdG8gdGhlIGN1cnJlbnQgKyBuZXdcclxuICAgICAgc3RhdGVPcGVyYXRpb25zLnNldFN0YXRlKHsgLi4uY3VyLCAuLi5yZXN1bHRzLmRlZmF1bHRzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbm5lY3Qgb3VyIGFjdGlvbnMgc3RyZWFtXHJcbiAgICBmYWN0b3J5LmNvbm5lY3RBY3Rpb25IYW5kbGVycygpO1xyXG5cclxuICAgIC8vIGRpc3BhdGNoIHRoZSBpbml0IGFjdGlvbiBhbmQgaW52b2tlIGluaXQgZnVuY3Rpb24gYWZ0ZXJcclxuICAgIHN0YXRlT3BlcmF0aW9ucy5kaXNwYXRjaChuZXcgSW5pdFN0YXRlKCkpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgICAgZmFjdG9yeS5pbnZva2VJbml0KHJlc3VsdHMuc3RhdGVzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmVhdHVyZSBtb2R1bGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQE5nTW9kdWxlKHt9KVxyXG5leHBvcnQgY2xhc3MgTmd4c0ZlYXR1cmVNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoRkVBVFVSRV9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogYW55W11bXVxyXG4gICkge1xyXG4gICAgLy8gU2luY2UgRkVBVFVSRV9TVEFURV9UT0tFTiBpcyBhIG11bHRpIHRva2VuLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmbGF0dGVuIGl0IFtbRmVhdHVyZTFTdGF0ZSwgRmVhdHVyZTJTdGF0ZV0sIFtGZWF0dXJlM1N0YXRlXV1cclxuICAgIGNvbnN0IGZsYXR0ZW5lZFN0YXRlcyA9IChbXSBhcyBhbnlbXSkuY29uY2F0KC4uLnN0YXRlcyk7XHJcblxyXG4gICAgLy8gYWRkIHN0b3JlcyB0byB0aGUgc3RhdGUgZ3JhcGggYW5kIHJldHVybiB0aGVpciBkZWZhdWx0c1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGZhY3RvcnkuYWRkQW5kUmV0dXJuRGVmYXVsdHMoZmxhdHRlbmVkU3RhdGVzKTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZU9wZXJhdGlvbnMgPSBpbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCk7XHJcbiAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAvLyBnZXQgb3VyIGN1cnJlbnQgc3RyZWFtXHJcbiAgICAgIGNvbnN0IGN1ciA9IHN0YXRlT3BlcmF0aW9ucy5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgLy8gc2V0IHRoZSBzdGF0ZSB0byB0aGUgY3VycmVudCArIG5ld1xyXG4gICAgICBzdGF0ZU9wZXJhdGlvbnMuc2V0U3RhdGUoeyAuLi5jdXIsIC4uLnJlc3VsdHMuZGVmYXVsdHMgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGVPcGVyYXRpb25zLmRpc3BhdGNoKG5ldyBVcGRhdGVTdGF0ZSgpKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAgIGZhY3RvcnkuaW52b2tlSW5pdChyZXN1bHRzLnN0YXRlcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTW9kdWxlT3B0aW9ucyA9IFBhcnRpYWw8Tmd4c0NvbmZpZz47XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbmd4c0NvbmZpZ0ZhY3Rvcnkob3B0aW9uczogTW9kdWxlT3B0aW9ucyk6IE5neHNDb25maWcge1xyXG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24obmV3IE5neHNDb25maWcoKSwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIGNvbmZpZztcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxNb2R1bGVPcHRpb25zPignUk9PVF9PUFRJT05TJyk7XHJcblxyXG4vKipcclxuICogTmd4cyBNb2R1bGVcclxuICovXHJcbkBOZ01vZHVsZSh7fSlcclxuZXhwb3J0IGNsYXNzIE5neHNNb2R1bGUge1xyXG4gIC8qKlxyXG4gICAqIFJvb3QgbW9kdWxlIGZhY3RvcnlcclxuICAgKi9cclxuICBzdGF0aWMgZm9yUm9vdChzdGF0ZXM6IGFueVtdID0gW10sIG9wdGlvbnM6IE1vZHVsZU9wdGlvbnMgPSB7fSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5neHNSb290TW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTdGF0ZUZhY3RvcnksXHJcbiAgICAgICAgU3RhdGVDb250ZXh0RmFjdG9yeSxcclxuICAgICAgICBBY3Rpb25zLFxyXG4gICAgICAgIEludGVybmFsQWN0aW9ucyxcclxuICAgICAgICBJbnRlcm5hbERpc3BhdGNoZXIsXHJcbiAgICAgICAgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgICAgICBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgICAgICBTdG9yZSxcclxuICAgICAgICBTdGF0ZVN0cmVhbSxcclxuICAgICAgICBTZWxlY3RGYWN0b3J5LFxyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgLi4uc3RhdGVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IFJPT1RfU1RBVEVfVE9LRU4sXHJcbiAgICAgICAgICB1c2VWYWx1ZTogc3RhdGVzXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwcm92aWRlOiBST09UX09QVElPTlMsXHJcbiAgICAgICAgICB1c2VWYWx1ZTogb3B0aW9uc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogTmd4c0NvbmZpZyxcclxuICAgICAgICAgIHVzZUZhY3Rvcnk6IG5neHNDb25maWdGYWN0b3J5LFxyXG4gICAgICAgICAgZGVwczogW1JPT1RfT1BUSU9OU11cclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGZWF0dXJlIG1vZHVsZSBmYWN0b3J5XHJcbiAgICovXHJcbiAgc3RhdGljIGZvckZlYXR1cmUoc3RhdGVzOiBhbnlbXSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5neHNGZWF0dXJlTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTdGF0ZUZhY3RvcnksXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlcixcclxuICAgICAgICAuLi5zdGF0ZXMsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogRkVBVFVSRV9TVEFURV9UT0tFTixcclxuICAgICAgICAgIG11bHRpOiB0cnVlLFxyXG4gICAgICAgICAgdXNlVmFsdWU6IHN0YXRlc1xyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZW5zdXJlU3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IEFjdGlvbk9wdGlvbnMgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgYSBtZXRob2Qgd2l0aCBhIGFjdGlvbiBpbmZvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBBY3Rpb24oYWN0aW9uczogYW55IHwgYW55W10sIG9wdGlvbnM/OiBBY3Rpb25PcHRpb25zKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcsIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPGFueT4pIHtcclxuICAgIGNvbnN0IG1ldGEgPSBlbnN1cmVTdG9yZU1ldGFkYXRhKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFjdGlvbnMpKSB7XHJcbiAgICAgIGFjdGlvbnMgPSBbYWN0aW9uc107XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xyXG4gICAgICBjb25zdCB0eXBlID0gYWN0aW9uLnR5cGU7XHJcblxyXG4gICAgICBpZiAoIWFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpb24gJHthY3Rpb24ubmFtZX0gaXMgbWlzc2luZyBhIHN0YXRpYyBcInR5cGVcIiBwcm9wZXJ0eWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW1ldGEuYWN0aW9uc1t0eXBlXSkge1xyXG4gICAgICAgIG1ldGEuYWN0aW9uc1t0eXBlXSA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtZXRhLmFjdGlvbnNbdHlwZV0ucHVzaCh7XHJcbiAgICAgICAgZm46IG5hbWUsXHJcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fSxcclxuICAgICAgICB0eXBlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgZW5zdXJlU3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IFN0b3JlT3B0aW9ucywgTUVUQV9LRVkgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbmNvbnN0IHN0YXRlTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXlthLXpBLVowLTlfXSskJyk7XHJcblxyXG4vKipcclxuICogRXJyb3IgbWVzc2FnZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdGVOYW1lRXJyb3JNZXNzYWdlID0gbmFtZSA9PlxyXG4gIGAke25hbWV9IGlzIG5vdCBhIHZhbGlkIHN0YXRlIG5hbWUuIEl0IG5lZWRzIHRvIGJlIGEgdmFsaWQgb2JqZWN0IHByb3BlcnR5IG5hbWUuYDtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgYSBjbGFzcyB3aXRoIG5neHMgc3RhdGUgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3RhdGU8VD4ob3B0aW9uczogU3RvcmVPcHRpb25zPFQ+KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55KSB7XHJcbiAgICBjb25zdCBtZXRhID0gZW5zdXJlU3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG5cclxuICAgIC8vIEhhbmRsZSBpbmhlcml0YW5jZVxyXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpLmhhc093blByb3BlcnR5KE1FVEFfS0VZKSkge1xyXG4gICAgICBjb25zdCBwYXJlbnRNZXRhID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClbTUVUQV9LRVldO1xyXG5cclxuICAgICAgbWV0YS5hY3Rpb25zID0ge1xyXG4gICAgICAgIC4uLm1ldGEuYWN0aW9ucyxcclxuICAgICAgICAuLi5wYXJlbnRNZXRhLmFjdGlvbnNcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBtZXRhLmNoaWxkcmVuID0gb3B0aW9ucy5jaGlsZHJlbjtcclxuICAgIG1ldGEuZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xyXG4gICAgbWV0YS5uYW1lID0gb3B0aW9ucy5uYW1lO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGVzIG11c3QgcmVnaXN0ZXIgYSAnbmFtZScgcHJvcGVydHlgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXN0YXRlTmFtZVJlZ2V4LnRlc3Qob3B0aW9ucy5uYW1lKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RhdGVOYW1lRXJyb3JNZXNzYWdlKG9wdGlvbnMubmFtZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICcuLi91dGlscy9zZWxlY3Rvci11dGlscyc7XHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZvciBtZW1vaXppbmcgYSBzdGF0ZSBzZWxlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3RvcihzZWxlY3RvcnM/OiBhbnlbXSkge1xyXG4gIHJldHVybiAodGFyZ2V0OiBhbnksIGtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpID0+IHtcclxuICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsRm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xyXG5cclxuICAgICAgY29uc3QgbWVtb2l6ZWRGbiA9IGNyZWF0ZVNlbGVjdG9yKFxyXG4gICAgICAgIHNlbGVjdG9ycyxcclxuICAgICAgICBvcmlnaW5hbEZuLFxyXG4gICAgICAgIHsgY29udGFpbmVyQ2xhc3M6IHRhcmdldCwgc2VsZWN0b3JOYW1lOiBrZXkgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgcmV0dXJuIG1lbW9pemVkRm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWxlY3RvcnMgb25seSB3b3JrIG9uIG1ldGhvZHMnKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUdBLE1BQWEsZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQU0sa0JBQWtCLENBQUM7O0FBQzNFLE1BQWEsbUJBQW1CLEdBQUcsSUFBSSxjQUFjLENBQU0scUJBQXFCLENBQUM7O0FBQ2pGLE1BQWEsUUFBUSxHQUFHLFdBQVc7O0FBQ25DLE1BQWEsaUJBQWlCLEdBQUcsb0JBQW9COztBQUVyRCxNQUFhLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBQyxjQUFjLENBQUM7Ozs7QUFPOUQsTUFBYSxVQUFVO0lBZ0JyQjtRQUNFLElBQUksQ0FBQyxhQUFhLEdBQUc7WUFDbkIsMkJBQTJCLEVBQUUsS0FBSztTQUNuQyxDQUFDO0tBQ0g7Q0FDRjs7Ozs7O0FDcENEOzs7Ozs7O0FBeURBLFNBQWdCLG1CQUFtQixDQUFDLE1BQU07SUFDeEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7O2NBQzlCLGVBQWUsR0FBa0I7WUFD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